--- lsof/print.c-org	2006-03-28 01:04:30.000000000 +0200
+++ lsof/print.c	2007-03-03 14:59:58.000000000 +0100
@@ -148,124 +148,7 @@
 static void
 fill_portmap()
 {
-	char buf[128], *cp, *nm;
-	CLIENT *c;
-	int h, port, pr;
-	MALLOC_S nl;
-	struct pmaplist *p = (struct pmaplist *)NULL;
-	struct porttab *pt;
-	struct rpcent *r;
-	struct TIMEVAL_LSOF tm;
-
-#if	!defined(CAN_USE_CLNT_CREATE)
-	struct hostent *he;
-	struct sockaddr_in ia;
-	int s = RPC_ANYSOCK;
-#endif	/* !defined(CAN_USE_CLNT_CREATE) */
-
-/*
- * Construct structures for communicating with the portmapper.
- */
-
-#if	!defined(CAN_USE_CLNT_CREATE)
-	zeromem(&ia, sizeof(ia));
-	ia.sin_family = AF_INET;
-	if ((he = gethostbyname("localhost")))
-	    MEMMOVE((caddr_t)&ia.sin_addr, he->h_addr, he->h_length);
-	ia.sin_port = htons(PMAPPORT);
-#endif	/* !defined(CAN_USE_CLNT_CREATE) */
-
-	tm.tv_sec = 60;
-	tm.tv_usec = 0;
-/*
- * Get an RPC client handle.  Then ask for a dump of the port map.
- */
-
-#if	defined(CAN_USE_CLNT_CREATE)
-	if (!(c = clnt_create("localhost", PMAPPROG, PMAPVERS, "tcp")))
-#else	/* !defined(CAN_USE_CLNT_CREATE) */
-	if (!(c = clnttcp_create(&ia, PMAPPROG, PMAPVERS, &s, 0, 0)))
-#endif	/* defined(CAN_USE_CLNT_CREATE) */
-
-	    return;
-	if (clnt_call(c, PMAPPROC_DUMP, XDR_VOID, NULL, XDR_PMAPLIST,
-		      (caddr_t)&p, tm)
-	!= RPC_SUCCESS) {
-	    clnt_destroy(c);
-	    return;
-	}
-/*
- * Loop through the port map dump, creating portmap table entries from TCP
- * and UDP members.
- */
-	for (; p; p = p->pml_next) {
-	
-	/*
-	 * Determine the port map entry's protocol; ignore all but TCP and UDP.
-	 */
-	    if (p->pml_map.pm_prot == IPPROTO_TCP)
-		pr = 2;
-	    else if (p->pml_map.pm_prot == IPPROTO_UDP)
-		pr = 3;
-	    else
-		continue;
-	/*
-	 * See if there's already a portmap entry for this port.  If there is,
-	 * ignore this entry.
-	 */
-	    h = HASHPORT((port = (int)p->pml_map.pm_port));
-	    for (pt = Pth[pr][h]; pt; pt = pt->next) {
-		if (pt->port == port)
-		    break;
-	    }
-	    if (pt)
-		continue;
-	/*
-	 * Save the registration name or number.
-	 */
-	    cp = (char *)NULL;
-	    if ((r = (struct rpcent *)getrpcbynumber(p->pml_map.pm_prog))) {
-		if (r->r_name && strlen(r->r_name))
-		    cp = r->r_name;
-	    }
-	    if (!cp) {
-		(void) snpf(buf, sizeof(buf), "%lu",
-			    (unsigned long)p->pml_map.pm_prog);
-		cp = buf;
-	    }
-	    if (!strlen(cp))
-		continue;
-	/*
-	 * Allocate space for the portmap name entry and copy it there.
-	 */
-	    if (!(nm = mkstrcpy(cp, &nl))) {
-		(void) fprintf(stderr,
-		    "%s: can't allocate space for portmap entry: ", Pn);
-		safestrprt(cp, stderr, 1);
-		Exit(1);
-	    }
-	    if (!nl) {
-		(void) free((FREE_P *)nm);
-		continue;
-	    }
-	/*
-	 * Allocate and fill a porttab struct entry for the portmap table.
-	 * Link it to the head of its hash bucket, and make it the new head.
-	 */
-	    if (!(pt = (struct porttab *)malloc(sizeof(struct porttab)))) {
-		(void) fprintf(stderr,
-		    "%s: can't allocate porttab entry for portmap: ", Pn);
-		safestrprt(nm, stderr, 1);
-		Exit(1);
-	    }
-	    pt->name = nm;
-	    pt->nl = nl;
-	    pt->port = port;
-	    pt->next = Pth[pr][h];
-	    pt->ss = 0;
-	    Pth[pr][h] = pt;
-	}
-	clnt_destroy(c);
+	return;
 }
 
 
