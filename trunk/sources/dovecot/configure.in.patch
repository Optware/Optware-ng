--- ../a.org/configure.in	2007-04-15 22:18:53.000000000 +0200
+++ configure.in	2007-04-15 22:20:57.000000000 +0200
@@ -768,30 +768,7 @@
 dnl * make sure size_t isn't signed. we'd probably work fine with it, but
 dnl * it's more likely vulnerable to buffer overflows. Anyway, C99 specifies
 dnl * that it's unsigned and only some old systems define it as signed.
-AC_CACHE_CHECK([whether size_t is signed],signed_size_t,[
-  AC_RUN_IFELSE([AC_LANG_SOURCE([[
-    #include <sys/types.h>
-    int main() {
-      /* return 0 if we're signed */
-      exit((size_t)(int)-1 <= 0 ? 0 : 1);
-    }
-  ]])],[
-    signed_size_t=yes
-
-    echo
-    echo "Your system's size_t is a signed integer, Dovecot isn't designed to"
-    echo "support it. It probably works just fine, but it's less resistant to"
-    echo "buffer overflows. If you're not worried about this and still want to"
-    echo "compile Dovecot, set ignore_signed_size=1 environment."
-  
-    if test "$ignore_signed_size" = ""; then
-      AC_MSG_ERROR([aborting])
-    fi
-    echo "..ignoring as requested.."
-  ],[
-    signed_size_t=no
-  ],[])
-])
+
 dnl Note: we check size_t rather than ssize_t here, because on OSX 10.2
 dnl ssize_t = int and size_t = unsigned long. We're mostly concerned about
 dnl printf format here, so check the size_t one.
@@ -883,45 +860,9 @@
 AC_MSG_RESULT($i_cv_field_tm_gmtoff)
 
 dnl * how large time_t values does gmtime() accept?
-AC_CACHE_CHECK([how large time_t values gmtime() accepts],gmtime_max_time_t,[
-  AC_RUN_IFELSE([AC_LANG_SOURCE([[
-    #include <stdio.h>
-    #include <time.h>
-    int main() {
-      FILE *f;
-      int bits;
-      time_t t;
-  
-      for (bits = 1, t = 1; t > 0; ++bits, t <<= 1) {
-	if (gmtime(&t) == NULL) {
-	  bits--;
-	  break;
-	}
-      }
-      if (bits > 40) {
-	/* Solaris 9 breaks after 55 bits. Perhaps other systems break earlier.
-	   Let's just do the same as Cyrus folks and limit it to 40 bits. */
-	bits = 40;
-      }
-  
-      f = fopen("conftest.temp", "w");
-      if (f == NULL) {
-	perror("fopen()");
-	return 1;
-      }
-      fprintf(f, "%d", bits);
-      fclose(f);
-      return 0;
-    }
-  ]])],[
-    gmtime_max_time_t=`cat conftest.temp`
-    rm -f conftest.temp
-  ], [
-    printf "check failed, assuming "
-    gmtime_max_time_t=31
-  ],[])
-])
-AC_DEFINE_UNQUOTED(TIME_T_MAX_BITS, $gmtime_max_time_t, max. time_t bits gmtime() can handle)
+dnl * Set to 32 because we can't calculate it if we are cross compiling.
+
+AC_DEFINE_UNQUOTED(TIME_T_MAX_BITS, 32, max. time_t bits gmtime() can handle)
 
 dnl * do we have struct iovec
 AC_MSG_CHECKING([for struct iovec])
@@ -993,114 +934,8 @@
 ])
 
 dnl * If mmap() plays nicely with write()
-AC_CACHE_CHECK([whether shared mmaps get updated by write()s],mmap_plays_with_write,[
-  AC_TRY_RUN([
-    #include <stdio.h>
-    #include <sys/types.h>
-    #include <sys/stat.h>
-    #include <unistd.h>
-    #include <fcntl.h>
-    #include <sys/mman.h>
-    int main() {
-      /* return 0 if we're signed */
-      int f = open("conftest.mmap", O_RDWR|O_CREAT|O_TRUNC);
-      void *mem;
-      if (f == -1) {
-	perror("open()");
-	return 1;
-      }
-      unlink("conftest.mmap");
-  
-      write(f, "1", 2);
-      mem = mmap(NULL, 2, PROT_READ|PROT_WRITE, MAP_SHARED, f, 0);
-      if (mem == MAP_FAILED) {
-	perror("mmap()");
-	return 1;
-      }
-      strcpy(mem, "2");
-      msync(mem, 2, MS_SYNC);
-      lseek(f, 0, SEEK_SET);
-      write(f, "3", 2);
-    
-      return strcmp(mem, "3") == 0 ? 0 : 1;
-    }
-  ], [
-    mmap_plays_with_write=yes
-  ], [
-    mmap_plays_with_write=no
-  ])
-])
-if test $mmap_plays_with_write = no; then
-  AC_DEFINE(MMAP_CONFLICTS_WRITE,, [Define if shared mmaps don't get updated by write()s])
-fi
 
 dnl * see if fd passing works
-AC_CACHE_CHECK([whether fd passing works],fd_passing,[
-  for i in 1 2; do
-    old_cflags="$CFLAGS"
-    CFLAGS="$CFLAGS -I$srcdir/src/lib $srcdir/src/lib/fdpass.c"
-    if test $i = 2; then
-      CFLAGS="$CFLAGS -DBUGGY_CMSG_MACROS"
-    fi
-  
-    AC_TRY_RUN([
-      #include <sys/types.h>
-      #include <sys/socket.h>
-      #include <sys/wait.h>
-      #include <sys/stat.h>
-      #include <unistd.h>
-      #include <fcntl.h>
-      #include "fdpass.h"
-      
-      int main(void)
-      {
-	      int fd[2], send_fd, recv_fd, status;
-	      struct stat st, st2;
-	      char data;
-      
-	      send_fd = open("conftest.fdpass", O_CREAT|O_WRONLY);
-	      if (send_fd == -1) return 2;
-	      unlink("conftest.fdpass");
-	      if (fstat(send_fd, &st) < 0) return 2;
-	      if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) return 2;
-      
-	      switch (fork()) {
-	      case -1:
-		      return 2;
-	      case 0:
-		      alarm(1);
-		      if (fd_send(fd[0], send_fd, &data, 1) != 1) return 2;
-		      return 0;
-	      default:
-		      alarm(2);
-		      if (wait(&status) == -1)
-			return 2;
-		      if (status != 0)
-			return status;
-		      if (fd_read(fd[1], &data, 1, &recv_fd) != 1) return 1;
-		      if (fstat(recv_fd, &st2) < 0) return 2;
-		      return st.st_ino == st2.st_ino ? 0 : 1;
-	      }
-      }
-    ], [
-      CFLAGS=$old_cflags
-      if test $i = 2; then
-	fd_passing=buggy_cmsg_macros
-      else
-        fd_passing=yes
-      fi
-      break
-    ], [
-      dnl no, try with BUGGY_CMSG_MACROS
-      CFLAGS=$old_cflags
-      fd_passing=no
-    ])
-  done
-]);
-
-if test $fd_passing = buggy_cmsg_macros; then
-  AC_DEFINE(BUGGY_CMSG_MACROS,, Define if you have buggy CMSG macros)
-fi
 
 dnl * Solaris compatible sendfile()
 AC_CHECK_LIB(sendfile, sendfile, [
@@ -1256,81 +1091,6 @@
   AC_MSG_RESULT(no)
 ])
 
-dnl ***
-dnl *** va_copy checks (from GLIB)
-dnl ***
-
-AC_CACHE_CHECK([for an implementation of va_copy()],lib_cv_va_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	va_copy (args2, args1);
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv_va_copy=yes],
-	[lib_cv_va_copy=no],[])
-])
-AC_CACHE_CHECK([for an implementation of __va_copy()],lib_cv___va_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	__va_copy (args2, args1);
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv___va_copy=yes],
-	[lib_cv___va_copy=no],[])
-])
-
-if test "x$lib_cv_va_copy" = "xyes"; then
-  va_copy_func=va_copy
-else if test "x$lib_cv___va_copy" = "xyes"; then
-  va_copy_func=__va_copy
-fi
-fi
-
-if test -n "$va_copy_func"; then
-  AC_DEFINE_UNQUOTED(VA_COPY,$va_copy_func,[A 'va_copy' style function])
-fi
-
-AC_CACHE_CHECK([whether va_lists can be copied by value],lib_cv_va_val_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	args2 = args1;
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv_va_val_copy=yes],
-	[lib_cv_va_val_copy=no],[])
-])
-
-if test "x$lib_cv_va_val_copy" = "xno"; then
-  AC_DEFINE(VA_COPY_AS_ARRAY,1, ['va_lists' cannot be copies as values])
-fi
-
 dnl **
 dnl ** SSL
 dnl **
