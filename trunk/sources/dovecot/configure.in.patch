--- /tmp/configure.in	2006-07-30 14:30:25.504944553 +0200
+++ configure.in	2006-07-30 15:51:52.000000000 +0200
@@ -721,33 +721,6 @@
 
 AC_DEFINE_UNQUOTED(PRIuUOFF_T, "$uofft_fmt", printf() format for uoff_t)
 
-dnl * make sure size_t isn't signed. we'd probably work fine with it, but
-dnl * it's more likely vulnerable to buffer overflows. Anyway, C99 specifies
-dnl * that it's unsigned and only some old systems define it as signed.
-AC_MSG_CHECKING([whether size_t is signed])
-AC_RUN_IFELSE([AC_LANG_SOURCE([[
-  #include <sys/types.h>
-  int main() {
-    /* return 0 if we're signed */
-    exit((size_t)(int)-1 <= 0 ? 0 : 1);
-  }
-]])],[
-  AC_MSG_RESULT(yes)
-
-  echo
-  echo "Your system's size_t is a signed integer, Dovecot isn't designed to"
-  echo "support it. It probably works just fine, but it's less resistant to"
-  echo "buffer overflows. If you're not worried about this and still want to"
-  echo "compile Dovecot, set ignore_signed_size=1 environment."
-
-  if test "$ignore_signed_size" = ""; then
-    AC_MSG_ERROR([aborting])
-  fi
-  echo "..ignoring as requested.."
-],[
-  AC_MSG_RESULT(no)
-],[])
-
 dnl Note: we check size_t rather than ssize_t here, because on OSX 10.2
 dnl ssize_t = int and size_t = unsigned long. We're mostly concerned about
 dnl printf format here, so check the size_t one.
@@ -840,44 +813,7 @@
 
 dnl * how large time_t values does gmtime() accept?
 AC_MSG_CHECKING([how large time_t values gmtime() accepts])
-AC_RUN_IFELSE([AC_LANG_SOURCE([[
-  #include <stdio.h>
-  #include <time.h>
-  int main() {
-    FILE *f;
-    int bits;
-    time_t t;
-
-    for (bits = 1, t = 1; t > 0; ++bits, t <<= 1) {
-      if (gmtime(&t) == NULL) {
-        bits--;
-	break;
-      }
-    }
-    if (bits > 40) {
-      /* Solaris 9 breaks after 55 bits. Perhaps other systems break earlier.
-         Let's just do the same as Cyrus folks and limit it to 40 bits. */
-      bits = 40;
-    }
-
-    f = fopen("conftest.temp", "w");
-    if (f == NULL) {
-      perror("fopen()");
-      return 1;
-    }
-    fprintf(f, "%d", bits);
-    fclose(f);
-    return 0;
-  }
-]])],[
-  max_bits=`cat conftest.temp`
-  rm -f conftest.temp
-  AC_MSG_RESULT($max_bits)
-], [
-  AC_MSG_RESULT([check failed, assuming 31])
-  max_bits=31
-],[])
-AC_DEFINE_UNQUOTED(TIME_T_MAX_BITS, $max_bits, max. time_t bits gmtime() can handle)
+AC_DEFINE_UNQUOTED(TIME_T_MAX_BITS, 32, max. time_t bits gmtime() can handle)
 
 dnl * do we have struct iovec
 AC_MSG_CHECKING([for struct iovec])
@@ -948,109 +884,6 @@
   AC_MSG_RESULT(no)
 ])
 
-dnl * If mmap() plays nicely with write()
-AC_MSG_CHECKING([whether shared mmaps get updated by write()s])
-AC_TRY_RUN([
-  #include <stdio.h>
-  #include <sys/types.h>
-  #include <sys/stat.h>
-  #include <unistd.h>
-  #include <fcntl.h>
-  #include <sys/mman.h>
-  int main() {
-    /* return 0 if we're signed */
-    int f = open("conftest.mmap", O_RDWR|O_CREAT|O_TRUNC);
-    void *mem;
-    if (f == -1) {
-      perror("open()");
-      return 1;
-    }
-    unlink("conftest.mmap");
-
-    write(f, "1", 2);
-    mem = mmap(NULL, 2, PROT_READ|PROT_WRITE, MAP_SHARED, f, 0);
-    if (mem == MAP_FAILED) {
-      perror("mmap()");
-      return 1;
-    }
-    strcpy(mem, "2");
-    msync(mem, 2, MS_SYNC);
-    lseek(f, 0, SEEK_SET);
-    write(f, "3", 2);
-  
-    return strcmp(mem, "3") == 0 ? 0 : 1;
-  }
-], [
-  AC_MSG_RESULT(yes)
-], [
-  AC_MSG_RESULT(no)
-  AC_DEFINE(MMAP_CONFLICTS_WRITE,, [Define if shared mmaps don't get updated by write()s])
-])
-
-dnl * see if fd passing works
-AC_MSG_CHECKING([whether fd passing works])
-for i in 1 2; do
-  old_cflags="$CFLAGS"
-  CFLAGS="$CFLAGS -I$srcdir/src/lib $srcdir/src/lib/fdpass.c"
-  if test $i = 2; then
-    CFLAGS="$CFLAGS -DBUGGY_CMSG_MACROS"
-  fi
-
-  AC_TRY_RUN([
-    #include <sys/types.h>
-    #include <sys/socket.h>
-    #include <sys/wait.h>
-    #include <sys/stat.h>
-    #include <unistd.h>
-    #include <fcntl.h>
-    #include "fdpass.h"
-    
-    int main(void)
-    {
-	    int fd[2], send_fd, recv_fd, status;
-	    struct stat st, st2;
-	    char data;
-    
-	    send_fd = open("conftest.fdpass", O_CREAT|O_WRONLY);
-	    if (send_fd == -1) return 2;
-	    unlink("conftest.fdpass");
-	    if (fstat(send_fd, &st) < 0) return 2;
-	    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) return 2;
-    
-	    switch (fork()) {
-	    case -1:
-		    return 2;
-	    case 0:
-		    alarm(1);
-		    if (fd_send(fd[0], send_fd, &data, 1) != 1) return 2;
-		    return 0;
-	    default:
-		    alarm(2);
-		    if (wait(&status) == -1)
-		      return 2;
-		    if (status != 0)
-		      return status;
-		    if (fd_read(fd[1], &data, 1, &recv_fd) != 1) return 1;
-		    if (fstat(recv_fd, &st2) < 0) return 2;
-		    return st.st_ino == st2.st_ino ? 0 : 1;
-	    }
-    }
-  ], [
-    CFLAGS=$old_cflags
-    if test $i = 2; then
-      AC_DEFINE(BUGGY_CMSG_MACROS,, Define if you have buggy CMSG macros)
-    fi
-    AC_MSG_RESULT(yes)
-    break
-  ], [
-    dnl no, try with BUGGY_CMSG_MACROS
-    CFLAGS=$old_cflags
-    if test $i = 2; then
-      AC_MSG_RESULT(no)
-    fi
-  ])
-done
-
 dnl * Solaris compatible sendfile()
 AC_CHECK_LIB(sendfile, sendfile, [
   LIBS="$LIBS -lsendfile"
@@ -1171,81 +1004,6 @@
   AC_MSG_RESULT(no)
 ])
 
-dnl ***
-dnl *** va_copy checks (from GLIB)
-dnl ***
-
-AC_CACHE_CHECK([for an implementation of va_copy()],lib_cv_va_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	va_copy (args2, args1);
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv_va_copy=yes],
-	[lib_cv_va_copy=no],[])
-])
-AC_CACHE_CHECK([for an implementation of __va_copy()],lib_cv___va_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	__va_copy (args2, args1);
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv___va_copy=yes],
-	[lib_cv___va_copy=no],[])
-])
-
-if test "x$lib_cv_va_copy" = "xyes"; then
-  va_copy_func=va_copy
-else if test "x$lib_cv___va_copy" = "xyes"; then
-  va_copy_func=__va_copy
-fi
-fi
-
-if test -n "$va_copy_func"; then
-  AC_DEFINE_UNQUOTED(VA_COPY,$va_copy_func,[A 'va_copy' style function])
-fi
-
-AC_CACHE_CHECK([whether va_lists can be copied by value],lib_cv_va_val_copy,[
-	AC_RUN_IFELSE([AC_LANG_SOURCE([[
-	#include <stdarg.h>
-	void f (int i, ...) {
-	va_list args1, args2;
-	va_start (args1, i);
-	args2 = args1;
-	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
-	  exit (1);
-	va_end (args1); va_end (args2);
-	}
-	int main() {
-	  f (0, 42);
-	  return 0;
-	}]])],
-	[lib_cv_va_val_copy=yes],
-	[lib_cv_va_val_copy=no],[])
-])
-
-if test "x$lib_cv_va_val_copy" = "xno"; then
-  AC_DEFINE(VA_COPY_AS_ARRAY,1, ['va_lists' cannot be copies as values])
-fi
-
 dnl **
 dnl ** SSL
 dnl **
