diff -pruN libsdl-1.2/build-scripts/makedep.sh libsdl-1.2-palm/build-scripts/makedep.sh
--- libsdl-1.2/build-scripts/makedep.sh	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/build-scripts/makedep.sh	2009-11-17 17:43:26.000000000 -0800
@@ -48,6 +48,18 @@ do  echo "Generating dependencies for $s
     fi
     echo "\$(objects)/$obj: $src \\" >>${output}.new
     search_deps $src | sort | uniq >>${output}.new
+
+    # PALM - adding -O2 to improve SDL_MixAudio perf (default is -O0; see bb file)
+    if test x"$src" = x"./src/audio/SDL_mixer.c"; then
+	    cat >>${output}.new <<__EOF__
+
+	\$(LIBTOOL) --mode=compile \$(CC) \$(CFLAGS) \$(EXTRA_CFLAGS) -O2 -c $src  -o \$@
+
+__EOF__
+	    continue;
+    fi
+    # /PALM
+
     case $ext in
         c) cat >>${output}.new <<__EOF__
 
diff -pruN libsdl-1.2/c libsdl-1.2-palm/c
--- libsdl-1.2/c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/c	2009-04-14 15:52:34.000000000 -0700
@@ -0,0 +1,3 @@
+#!/bin/bash
+echo "c"
+make 2>&1 | /opt/nova/piranha/c.pl 
diff -pruN libsdl-1.2/configure.in libsdl-1.2-palm/configure.in
--- libsdl-1.2/configure.in	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/configure.in	2009-10-22 13:54:47.000000000 -0700
@@ -244,6 +244,14 @@ if test x$enable_joystick != xyes; then
 else
     SOURCES="$SOURCES $srcdir/src/joystick/*.c"
 fi
+AC_ARG_ENABLE(haptic,
+AC_HELP_STRING([--enable-haptic], [Enable the haptic (force feedback) subsystem [[default=yes]]]),
+              , enable_haptic=yes)
+if test x$enable_haptic != xyes; then
+    AC_DEFINE(SDL_HAPTIC_DISABLED)
+else
+    SOURCES="$SOURCES $srcdir/src/haptic/*.c"
+fi
 AC_ARG_ENABLE(cdrom,
 AC_HELP_STRING([--enable-cdrom], [Enable the cdrom subsystem [[default=yes]]]),
               , enable_cdrom=yes)
@@ -865,6 +873,25 @@ AC_HELP_STRING([--enable-ipod], [configu
     fi
 }
 
+#PALM
+CheckWebos()
+{
+    AC_ARG_ENABLE(webos,
+AC_HELP_STRING([--enable-webos], [configure SDL to work with Palm webOS [[default=no]]]),
+        , enable_webos=no)
+
+    if test x$enable_webos = xyes; then
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -Werror-implicit-function-declaration -DPALM"
+        SOURCES="$SOURCES $srcdir/src/events/webos/*.c"
+        # Switch these two lines to get events in standalone mode
+        SOURCES="$SOURCES $srcdir/src/events/webos/integrated/*.c"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lnapp -lPiranha"
+        #SOURCES="$SOURCES $srcdir/src/events/webos/standalone/*.c"
+        #EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lhid -lPiranha"
+    fi
+}
+#/PALM
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -1222,7 +1249,7 @@ AC_HELP_STRING([--enable-video-fbcon], [
         if test x$video_fbcon = xyes; then
             AC_CHECK_FUNCS(getpagesize)
             AC_DEFINE(SDL_VIDEO_DRIVER_FBCON)
-            SOURCES="$SOURCES $srcdir/src/video/fbcon/*.c"
+            SOURCES="$SOURCES $srcdir/src/video/fbcon/*.c $srcdir/src/video/fbcon/*.cc"
             have_video=yes
         fi
     fi
@@ -1555,6 +1582,31 @@ AC_HELP_STRING([--enable-video-dummy], [
     fi
 }
 
+#PALM
+AC_ARG_ENABLE(video-opengles,
+AC_HELP_STRING([--enable-video-opengles], [include OpenGL-ES context creation [[default=no]]]),
+              , enable_video_opengles=no)
+
+CheckOpenGLES()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengles = xyes; then
+        AC_MSG_CHECKING(for OpenGLES (Generic) support)
+        video_opengles=no
+        AC_TRY_COMPILE([
+        #include <GLES/gl.h>
+        #include <GLES/egl.h>
+        ],[
+        ],[
+        video_opengles=yes
+        ])
+        AC_MSG_RESULT($video_opengles)
+        if test x$video_opengles = xyes; then
+            AC_DEFINE(SDL_VIDEO_OPENGL_ES)
+        fi
+    fi
+}
+#/PALM
+
 dnl Check to see if OpenGL support is desired
 AC_ARG_ENABLE(video-opengl,
 AC_HELP_STRING([--enable-video-opengl], [include OpenGL context creation [[default=yes]]]),
@@ -2255,6 +2307,9 @@ case "$host" in
         CheckX11
         CheckNANOX
         CheckFBCON
+        #PALM
+        CheckWebos
+        #/PALM
         CheckDirectFB
         CheckPS2GS
         CheckGGI
@@ -2265,6 +2320,9 @@ case "$host" in
         CheckQtopia
         CheckPicoGUI
         CheckOpenGLX11
+        #PALM
+        CheckOpenGLES
+        #/PALM
         CheckInputEvents
         CheckTslib
         CheckUSBHID
@@ -2297,11 +2355,32 @@ case "$host" in
           case $ARCH in
             linux)
                 AC_DEFINE(SDL_JOYSTICK_LINUX)
-                SOURCES="$SOURCES $srcdir/src/joystick/linux/*.c"
+                #PALM
+                if test x$enable_webos = xyes; then
+                  SOURCES="$SOURCES $srcdir/src/joystick/webos/*.c"
+                else
+                  SOURCES="$SOURCES $srcdir/src/joystick/linux/*.c"
+                fi
+                #/PALM
                 have_joystick=yes
             ;;
           esac
         fi
+	# Set up files for the haptic library
+        if test x$enable_haptic = xyes; then
+           if test x$use_input_events = xyes; then
+             case $ARCH in
+               linux)
+                   AC_DEFINE(SDL_HAPTIC_LINUX)
+                   SOURCES="$SOURCES $srcdir/src/haptic/linux/*.c"
+                   have_haptic=yes
+                   if test x$enable_webos = xyes; then
+                    EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lpalmvibe" 
+                   fi
+               ;;
+             esac
+           fi
+        fi
         # Set up files for the cdrom library
         if test x$enable_cdrom = xyes; then
           case $ARCH in
diff -pruN libsdl-1.2/include/SDL_config.h libsdl-1.2-palm/include/SDL_config.h
--- libsdl-1.2/include/SDL_config.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_config.h	2009-10-01 19:51:52.000000000 -0700
@@ -1,3 +1,4 @@
+/* include/SDL_config.h.  Generated from SDL_config.h.in by configure.  */
 /*
     SDL - Simple DirectMedia Layer
     Copyright (C) 1997-2006 Sam Lantinga
@@ -23,23 +24,290 @@
 #ifndef _SDL_config_h
 #define _SDL_config_h
 
+/* This is a set of defines to configure the SDL features */
+
+/* General platform specific identifiers */
 #include "SDL_platform.h"
 
-/* Add any platform that doesn't build using the configure system */
-#if defined(__DREAMCAST__)
-#include "SDL_config_dreamcast.h"
-#elif defined(__MACOS__)
-#include "SDL_config_macos.h"
-#elif defined(__MACOSX__)
-#include "SDL_config_macosx.h"
-#elif defined(__SYMBIAN32__)
-#include "SDL_config_symbian.h"  /* must be before win32! */
-#elif defined(__WIN32__)
-#include "SDL_config_win32.h"
-#elif defined(__OS2__)
-#include "SDL_config_os2.h"
+/* Make sure that this isn't included by Visual C++ */
+#ifdef _MSC_VER
+#error You should copy include/SDL_config.h.default to include/SDL_config.h
+#endif
+
+/* C language features */
+/* #undef const */
+/* #undef inline */
+/* #undef volatile */
+
+/* C datatypes */
+/* #undef size_t */
+/* #undef int8_t */
+/* #undef uint8_t */
+/* #undef int16_t */
+/* #undef uint16_t */
+/* #undef int32_t */
+/* #undef uint32_t */
+/* #undef int64_t */
+/* #undef uint64_t */
+/* #undef uintptr_t */
+#define SDL_HAS_64BIT_TYPE 1
+
+/* Endianness */
+#define SDL_BYTEORDER 1234
+
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+#if HAVE_LIBC
+
+/* Useful headers */
+#define HAVE_ALLOCA_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_SIGNAL_H 1
+/* #undef HAVE_ALTIVEC_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_ALLOCA 1
+#ifndef _WIN32 /* Don't use C runtime versions of these on Windows */
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_UNSETENV 1
+#endif
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_BCOPY 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+/* #undef HAVE_MEMCMP */
+#define HAVE_STRLEN 1
+/* #undef HAVE_STRLCPY */
+/* #undef HAVE_STRLCAT */
+#define HAVE_STRDUP 1
+/* #undef HAVE__STRREV */
+/* #undef HAVE__STRUPR */
+/* #undef HAVE__STRLWR */
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+/* #undef HAVE_ITOA */
+/* #undef HAVE__LTOA */
+/* #undef HAVE__UITOA */
+/* #undef HAVE__ULTOA */
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+/* #undef HAVE__I64TOA */
+/* #undef HAVE__UI64TOA */
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+/* #undef HAVE_STRTOD */
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+/* #undef HAVE__STRICMP */
+#define HAVE_STRCASECMP 1
+/* #undef HAVE__STRNICMP */
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+#define HAVE_ICONV 1
+#define HAVE_SIGACTION 1
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP 1
+/* #undef HAVE_CLOCK_GETTIME */
+#define HAVE_DLVSYM 1
+#define HAVE_GETPAGESIZE 1
+#define HAVE_MPROTECT 1
+
 #else
-#include "SDL_config_minimal.h"
-#endif /* platform config */
+/* We may need some replacement for stdarg.h here */
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_AUDIO_DISABLED */
+#define SDL_CDROM_DISABLED 1
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+/* #undef SDL_LOADSO_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+
+/* Enable various audio drivers */
+#define SDL_AUDIO_DRIVER_ALSA 1
+#define SDL_AUDIO_DRIVER_ALSA_DYNAMIC "libasound.so.2"
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_BAUDIO */
+/* #undef SDL_AUDIO_DRIVER_BSD */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DART */
+/* #undef SDL_AUDIO_DRIVER_DC */
+/* #undef SDL_AUDIO_DRIVER_DISK */
+#define SDL_AUDIO_DRIVER_DUMMY 1
+/* #undef SDL_AUDIO_DRIVER_DMEDIA */
+/* #undef SDL_AUDIO_DRIVER_DSOUND */
+/* #undef SDL_AUDIO_DRIVER_PULSE */
+/* #undef SDL_AUDIO_DRIVER_PULSE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_MINT */
+/* #undef SDL_AUDIO_DRIVER_MMEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUD */
+/* #undef SDL_AUDIO_DRIVER_QNXNTO */
+/* #undef SDL_AUDIO_DRIVER_SNDMGR */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+/* #undef SDL_AUDIO_DRIVER_WAVEOUT */
+
+/* Enable various cdrom drivers */
+/* #undef SDL_CDROM_AIX */
+/* #undef SDL_CDROM_BEOS */
+/* #undef SDL_CDROM_BSDI */
+/* #undef SDL_CDROM_DC */
+/* #undef SDL_CDROM_DUMMY */
+/* #undef SDL_CDROM_FREEBSD */
+/* #undef SDL_CDROM_LINUX */
+/* #undef SDL_CDROM_MACOS */
+/* #undef SDL_CDROM_MACOSX */
+/* #undef SDL_CDROM_MINT */
+/* #undef SDL_CDROM_OPENBSD */
+/* #undef SDL_CDROM_OS2 */
+/* #undef SDL_CDROM_OSF */
+/* #undef SDL_CDROM_QNX */
+/* #undef SDL_CDROM_WIN32 */
+
+/* Enable various input drivers */
+#define SDL_INPUT_LINUXEV 1
+/* #undef SDL_INPUT_TSLIB */
+/* #undef SDL_JOYSTICK_BEOS */
+/* #undef SDL_JOYSTICK_DC */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+#define SDL_JOYSTICK_LINUX 1
+/* #undef SDL_JOYSTICK_MACOS */
+/* #undef SDL_JOYSTICK_MINT */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_RISCOS */
+/* #undef SDL_JOYSTICK_WINMM */
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H */
+#define SDL_HAPTIC_LINUX 1
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_BEOS */
+/* #undef SDL_LOADSO_DLCOMPAT */
+#define SDL_LOADSO_DLOPEN 1
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_MACOS */
+/* #undef SDL_LOADSO_OS2 */
+/* #undef SDL_LOADSO_WIN32 */
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_BEOS */
+/* #undef SDL_THREAD_DC */
+/* #undef SDL_THREAD_OS2 */
+/* #undef SDL_THREAD_PTH */
+#define SDL_THREAD_PTHREAD 1
+#define SDL_THREAD_PTHREAD_RECURSIVE_MUTEX 1
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_SPROC */
+/* #undef SDL_THREAD_WIN32 */
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_BEOS */
+/* #undef SDL_TIMER_DC */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_MACOS */
+/* #undef SDL_TIMER_MINT */
+/* #undef SDL_TIMER_OS2 */
+/* #undef SDL_TIMER_RISCOS */
+#define SDL_TIMER_UNIX 1
+/* #undef SDL_TIMER_WIN32 */
+/* #undef SDL_TIMER_WINCE */
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_AALIB */
+/* #undef SDL_VIDEO_DRIVER_BWINDOW */
+/* #undef SDL_VIDEO_DRIVER_DC */
+/* #undef SDL_VIDEO_DRIVER_DDRAW */
+/* #undef SDL_VIDEO_DRIVER_DGA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DRAWSPROCKET */
+/* #undef SDL_VIDEO_DRIVER_DUMMY */
+#define SDL_VIDEO_DRIVER_FBCON 1
+/* #undef SDL_VIDEO_DRIVER_GAPI */
+/* #undef SDL_VIDEO_DRIVER_GEM */
+/* #undef SDL_VIDEO_DRIVER_GGI */
+/* #undef SDL_VIDEO_DRIVER_IPOD */
+/* #undef SDL_VIDEO_DRIVER_NANOX */
+/* #undef SDL_VIDEO_DRIVER_OS2FS */
+/* #undef SDL_VIDEO_DRIVER_PHOTON */
+/* #undef SDL_VIDEO_DRIVER_PICOGUI */
+/* #undef SDL_VIDEO_DRIVER_PS2GS */
+/* #undef SDL_VIDEO_DRIVER_QTOPIA */
+/* #undef SDL_VIDEO_DRIVER_QUARTZ */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+/* #undef SDL_VIDEO_DRIVER_SVGALIB */
+/* #undef SDL_VIDEO_DRIVER_TOOLBOX */
+/* #undef SDL_VIDEO_DRIVER_VGL */
+/* #undef SDL_VIDEO_DRIVER_WINDIB */
+/* #undef SDL_VIDEO_DRIVER_WSCONS */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_X11_DGAMOUSE */
+/* #undef SDL_VIDEO_DRIVER_X11_DPMS */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRENDER */
+/* #undef SDL_VIDEO_DRIVER_X11_VIDMODE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINERAMA */
+/* #undef SDL_VIDEO_DRIVER_X11_XME */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XV */
+/* #undef SDL_VIDEO_DRIVER_XBIOS */
+
+/* Enable OpenGL support */
+/* #undef SDL_VIDEO_OPENGL */
+/* #undef SDL_VIDEO_OPENGL_GLX */
+/* #undef SDL_VIDEO_OPENGL_WGL */
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+// PALM
+/* Enable OpenGL-ES support */
+#define SDL_VIDEO_OPENGL_ES 1
+///PALM
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+/* #undef SDL_HERMES_BLITTERS */
+/* #undef SDL_ALTIVEC_BLITTERS */
 
 #endif /* _SDL_config_h */
diff -pruN libsdl-1.2/include/SDL_config.h.in libsdl-1.2-palm/include/SDL_config.h.in
--- libsdl-1.2/include/SDL_config.h.in	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_config.h.in	2009-09-30 12:32:56.000000000 -0700
@@ -216,6 +216,7 @@
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
+#undef SDL_HAPTIC_LINUX
 
 /* Enable various shared object loading systems */
 #undef SDL_LOADSO_BEOS
@@ -298,6 +299,11 @@
 #undef SDL_VIDEO_OPENGL_OSMESA
 #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC
 
+// PALM
+/* Enable OpenGL-ES support */
+#undef SDL_VIDEO_OPENGL_ES
+///PALM
+
 /* Enable assembly routines */
 #undef SDL_ASSEMBLY_ROUTINES
 #undef SDL_HERMES_BLITTERS
diff -pruN libsdl-1.2/include/SDL.h libsdl-1.2-palm/include/SDL.h
--- libsdl-1.2/include/SDL.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/include/SDL.h	2009-09-30 12:30:44.000000000 -0700
@@ -1,94 +1,95 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2006 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-
-/* Main include header for the SDL library */
-
-#ifndef _SDL_H
-#define _SDL_H
-
-#include "SDL_main.h"
-#include "SDL_stdinc.h"
-#include "SDL_audio.h"
-#include "SDL_cdrom.h"
-#include "SDL_cpuinfo.h"
-#include "SDL_endian.h"
-#include "SDL_error.h"
-#include "SDL_events.h"
-#include "SDL_loadso.h"
-#include "SDL_mutex.h"
-#include "SDL_rwops.h"
-#include "SDL_thread.h"
-#include "SDL_timer.h"
-#include "SDL_video.h"
-#include "SDL_version.h"
-
-#include "begin_code.h"
-/* Set up for C function definitions, even when using C++ */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* As of version 0.5, SDL is loaded dynamically into the application */
-
-/* These are the flags which may be passed to SDL_Init() -- you should
-   specify the subsystems which you will be using in your application.
-*/
-#define	SDL_INIT_TIMER		0x00000001
-#define SDL_INIT_AUDIO		0x00000010
-#define SDL_INIT_VIDEO		0x00000020
-#define SDL_INIT_CDROM		0x00000100
-#define SDL_INIT_JOYSTICK	0x00000200
-#define SDL_INIT_NOPARACHUTE	0x00100000	/* Don't catch fatal signals */
-#define SDL_INIT_EVENTTHREAD	0x01000000	/* Not supported on all OS's */
-#define SDL_INIT_EVERYTHING	0x0000FFFF
-
-/* This function loads the SDL dynamically linked library and initializes 
- * the subsystems specified by 'flags' (and those satisfying dependencies)
- * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
- * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
- */
-extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);
-
-/* This function initializes specific SDL subsystems */
-extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);
-
-/* This function cleans up specific SDL subsystems */
-extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);
-
-/* This function returns mask of the specified subsystems which have
-   been initialized.
-   If 'flags' is 0, it returns a mask of all initialized subsystems.
-*/
-extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);
-
-/* This function cleans up all initialized subsystems and unloads the
- * dynamically linked library.  You should call it upon all exit conditions.
- */
-extern DECLSPEC void SDLCALL SDL_Quit(void);
-
-/* Ends C function definitions when using C++ */
-#ifdef __cplusplus
-}
-#endif
-#include "close_code.h"
-
-#endif /* _SDL_H */
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+/* Main include header for the SDL library */
+
+#ifndef _SDL_H
+#define _SDL_H
+
+#include "SDL_main.h"
+#include "SDL_stdinc.h"
+#include "SDL_audio.h"
+#include "SDL_cdrom.h"
+#include "SDL_cpuinfo.h"
+#include "SDL_endian.h"
+#include "SDL_error.h"
+#include "SDL_events.h"
+#include "SDL_loadso.h"
+#include "SDL_mutex.h"
+#include "SDL_rwops.h"
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_video.h"
+#include "SDL_version.h"
+
+#include "begin_code.h"
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* As of version 0.5, SDL is loaded dynamically into the application */
+
+/* These are the flags which may be passed to SDL_Init() -- you should
+   specify the subsystems which you will be using in your application.
+*/
+#define	SDL_INIT_TIMER		0x00000001
+#define SDL_INIT_AUDIO		0x00000010
+#define SDL_INIT_VIDEO		0x00000020
+#define SDL_INIT_CDROM		0x00000100
+#define SDL_INIT_JOYSTICK	0x00000200
+#define SDL_INIT_HAPTIC		0x00001000
+#define SDL_INIT_NOPARACHUTE	0x00100000	/* Don't catch fatal signals */
+#define SDL_INIT_EVENTTHREAD	0x01000000	/* Not supported on all OS's */
+#define SDL_INIT_EVERYTHING	0x0000FFFF
+
+/* This function loads the SDL dynamically linked library and initializes 
+ * the subsystems specified by 'flags' (and those satisfying dependencies)
+ * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
+ * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
+ */
+extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);
+
+/* This function initializes specific SDL subsystems */
+extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);
+
+/* This function cleans up specific SDL subsystems */
+extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);
+
+/* This function returns mask of the specified subsystems which have
+   been initialized.
+   If 'flags' is 0, it returns a mask of all initialized subsystems.
+*/
+extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);
+
+/* This function cleans up all initialized subsystems and unloads the
+ * dynamically linked library.  You should call it upon all exit conditions.
+ */
+extern DECLSPEC void SDLCALL SDL_Quit(void);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_H */
diff -pruN libsdl-1.2/include/SDL_haptic.h libsdl-1.2-palm/include/SDL_haptic.h
--- libsdl-1.2/include/SDL_haptic.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_haptic.h	2009-09-30 12:41:23.000000000 -0700
@@ -0,0 +1,1173 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+/**
+ * \file SDL_haptic.h
+ *
+ * \brief The SDL Haptic subsystem allows you to control haptic (force feedback)
+ *  devices.
+ *
+ * The basic usage is as follows:
+ *   - Initialize the Subsystem (SDL_INIT_HAPTIC).
+ *   - Open a Haptic Device.
+ *     - SDL_HapticOpen(...) to open from index.
+ *     - SDL_HapticOpenFromJoystick(...) to open from an existing joystick.
+ *   - Create an effect (SDL_HapticEffect).
+ *   - Upload the effect with SDL_HapticNewEffect(...).
+ *   - Run the effect with SDL_HapticRunEffect(...).
+ *   - (optional) Free the effect with SDL_HapticDestroyEffect(...).
+ *   - Close the haptic device with SDL_HapticClose(...).
+ *
+ * Example:
+ *
+ * \code
+ * int test_haptic( SDL_Joystick * joystick ) {
+ *    SDL_Haptic *haptic;
+ *    SDL_HapticEffect effect;
+ *    int effect_id;
+ *
+ *    // Open the device
+ *    haptic = SDL_HapticOpenFromJoystick( joystick );
+ *    if (haptic == NULL) return -1; // Most likely joystick isn't haptic
+ *
+ *    // See if it can do sine waves
+ *    if ((SDL_HapticQuery(haptic) & SDL_HAPTIC_SINE)==0) {
+ *       SDL_HapticClose(haptic); // No sine effect
+ *       return -1;
+ *    }
+ *
+ *    // Create the effect
+ *    memset( &effect, 0, sizeof(SDL_HapticEffect) ); // 0 is safe default
+ *    effect.type = SDL_HAPTIC_SINE;
+ *    effect.periodic.direction.type = SDL_HAPTIC_POLAR; // Polar coordinates
+ *    effect.periodic.direction.dir[0] = 18000; // Force comes from south
+ *    effect.periodic.period = 1000; // 1000 ms
+ *    effect.periodic.magnitude = 20000; // 20000/32767 strength
+ *    effect.periodic.length = 5000; // 5 seconds long
+ *    effect.periodic.attack_length = 1000; // Takes 1 second to get max strength
+ *    effect.periodic.fade_length = 1000; // Takes 1 second to fade away
+ *
+ *    // Upload the effect
+ *    effect_id = SDL_HapticNewEffect( haptic, &effect );
+ *
+ *    // Test the effect
+ *    SDL_HapticRunEffect( haptic, effect_id, 1 );
+ *    SDL_Delay( 5000); // Wait for the effect to finish
+ *
+ *    // We destroy the effect, although closing the device also does this
+ *    SDL_HapticDestroyEffect( haptic, effect_id );
+ *
+ *    // Close the device
+ *    SDL_HapticClose(haptic);
+ *
+ *    return 0; // Success
+ * }
+ * \endcode
+ *
+ * \author Edgar Simo Serra
+ */
+
+#ifndef _SDL_haptic_h
+#define _SDL_haptic_h
+
+#include "SDL_stdinc.h"
+#include "SDL_error.h"
+#include "SDL_joystick.h"
+
+#include "begin_code.h"
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+/* *INDENT-OFF* */
+extern "C" {
+   /* *INDENT-ON* */                                                         
+#endif /* __cplusplus */
+
+/**
+ * \typedef SDL_Haptic
+ *
+ * \brief The haptic structure used to identify an SDL haptic.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticOpenFromJoystick
+ * \sa SDL_HapticClose
+ */
+struct _SDL_Haptic;
+typedef struct _SDL_Haptic SDL_Haptic;
+
+
+/*
+ * Different haptic features a device can have.
+ */
+/**
+ * \def SDL_HAPTIC_CONSTANT
+ *
+ * \brief Constant haptic effect.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_CONSTANT   (1<<0)    /* Constant effect supported */
+/**
+ * \def SDL_HAPTIC_SINE
+ *
+ * \brief Periodic haptic effect that simulates sine waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SINE       (1<<1)    /* Sine wave effect supported */
+/**
+ * \def SDL_HAPTIC_SQUARE
+ *
+ * \brief Periodic haptic effect that simulates square waves.
+ * 
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SQUARE     (1<<2)    /* Square wave effect supported */
+/**
+ * \def SDL_HAPTIC_TRIANGLE
+ *
+ * \brief Periodic haptic effect that simulates triangular waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_TRIANGLE   (1<<3)    /* Triangle wave effect supported */
+/**
+ * \def SDL_HAPTIC_SAWTOOTHUP
+ *
+ * \brief Periodic haptic effect that simulates saw tooth up waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SAWTOOTHUP (1<<4)    /* Sawtoothup wave effect supported */
+/**
+ * \def SDL_HAPTIC_SAWTOOTHDOWN
+ *
+ * \brief Periodic haptic effect that simulates saw tooth down waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SAWTOOTHDOWN (1<<5)  /* Sawtoothdown wave effect supported */
+/**
+ * \def SDL_HAPTIC_RAMP
+ *
+ * \brief Ramp haptic effect.
+ *
+ * \sa SDL_HapticRamp
+ */
+#define SDL_HAPTIC_RAMP       (1<<6)    /* Ramp effect supported */
+/**
+ * \def SDL_HAPTIC_SPRING
+ *
+ * \brief Condition haptic effect that simulates a spring.  Effect is based on the
+ * axes position.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_SPRING     (1<<7)    /* Spring effect supported - uses axes position */
+/**
+ * \def SDL_HAPTIC_DAMPER
+ *
+ * \brief Condition haptic effect that simulates dampening.  Effect is based on the
+ * axes velocity.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_DAMPER     (1<<8)    /* Damper effect supported - uses axes velocity */
+/**
+ * \def SDL_HAPTIC_INERTIA
+ *
+ * \brief Condition haptic effect that simulates inertia.  Effect is based on the axes
+ * acceleration.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_INERTIA    (1<<9)    /* Inertia effect supported - uses axes acceleration */
+/**
+ * \def SDL_HAPTIC_FRICTION
+ *
+ * \brief Condition haptic effect that simulates friction.  Effect is based on the axes
+ * movement.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_FRICTION   (1<<10)   /* Friction effect supported - uses axes movement */
+/**
+ * \def SDL_HAPTIC_CUSTOM
+ *
+ * \brief User defined custom haptic effect.
+ */
+#define SDL_HAPTIC_CUSTOM     (1<<11)   /* Custom effect is supported */
+/* These last two are features the device has, not effects */
+/**
+ * \def SDL_HAPTIC_GAIN
+ *
+ * \brief Device supports setting the global gain.
+ *
+ * \sa SDL_HapticSetGain
+ */
+#define SDL_HAPTIC_GAIN       (1<<12)   /* Device can set global gain */
+/**
+ * \def SDL_HAPTIC_AUTOCENTER
+ *
+ * \brief Device supports setting autocenter.
+ *
+ * \sa SDL_HapticSetAutocenter
+ */
+#define SDL_HAPTIC_AUTOCENTER (1<<13)   /* Device can set autocenter */
+/**
+ * \def SDL_HAPTIC_STATUS
+ *
+ * \brief Device can be queried for effect status.
+ *
+ * \sa SDL_HapticGetEffectStatus
+ */
+#define SDL_HAPTIC_STATUS     (1<<14)   /* Device can be queried for effect status */
+/**
+ * \def SDL_HAPTIC_PAUSE
+ *
+ * \brief Device can be paused.
+ *
+ * \sa SDL_HapticPause
+ * \sa SDL_HapticUnpause
+ */
+#define SDL_HAPTIC_PAUSE      (1<<15)   /* Device can be paused. */
+
+
+/*
+ * Direction encodings
+ */
+/**
+ * \def SDL_HAPTIC_POLAR
+ *
+ * \brief Uses polar coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_POLAR      0
+/**
+ * \def SDL_HAPTIC_CARTESIAN
+ *
+ * \brief Uses cartesian coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_CARTESIAN  1
+/**
+ * \def SDL_HAPTIC_SPHERICAL
+ *
+ * \brief Uses spherical coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_SPHERICAL  2
+
+
+/*
+ * Misc defines.
+ */
+/**
+ * \def SDL_HAPTIC_INFINITY
+ *
+ * \brief Used to play a device an infinite number of times.
+ *
+ * \sa SDL_HapticRunEffect
+ */
+#define SDL_HAPTIC_INFINITY   4294967295U
+
+
+/**
+ * \struct SDL_HapticDirection
+ *
+ * \brief Structure that represents a haptic direction.
+ *
+ * Directions can be specified by:
+ *   - SDL_HAPTIC_POLAR : Specified by polar coordinates.
+ *   - SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
+ *   - SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
+ *
+ * Cardinal directions of the haptic device are relative to the positioning
+ *  of the device.  North is considered to be away from the user.
+ *
+ * The following diagram represents the cardinal directions:
+ * \code
+ *              .--.
+ *              |__| .-------.
+ *              |=.| |.-----.|
+ *              |--| ||     ||
+ *              |  | |'-----'|
+ *              |__|~')_____('
+ *                [ COMPUTER ]
+ *
+ *
+ *                  North (0,-1)
+ *                      ^
+ *                      |
+ *                      |
+ * (1,0)  West <----[ HAPTIC ]----> East (-1,0)
+ *                      |
+ *                      |
+ *                      v
+ *                   South (0,1)
+ *
+ *
+ *                   [ USER ]
+ *                     \|||/
+ *                     (o o)
+ *               ---ooO-(_)-Ooo---
+ * \endcode
+ *
+ * If type is SDL_HAPTIC_POLAR, direction is encoded by hundredths of a 
+ *  degree starting north and turning clockwise.  SDL_HAPTIC_POLAR only uses
+ *  the first dir parameter.  The cardinal directions would be:
+ *   - North: 0 (0 degrees)
+ *   - East: 9000 (90 degrees)
+ *   - South: 18000 (180 degrees)
+ *   - West: 27000 (270 degrees)
+ *
+ * If type is SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
+ *  (X axis, Y axis and Z axis (with 3 axes)).  SDL_HAPTIC_CARTESIAN uses
+ *  the first three dir parameters.  The cardinal directions would be:
+ *   - North:  0,-1, 0
+ *   - East:  -1, 0, 0
+ *   - South:  0, 1, 0
+ *   - West:   1, 0, 0
+ *  The Z axis represents the height of the effect if supported, otherwise
+ *  it's unused.  In cartesian encoding (1,2) would be the same as (2,4), you
+ *  can use any multiple you want, only the direction matters.
+ *
+ * If type is SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
+ *  The first two  dir parameters are used.  The dir parameters are as follows
+ *  (all values are in hundredths of degrees):
+ *    1) Degrees from (1, 0) rotated towards (0, 1).
+ *    2) Degrees towards (0, 0, 1) (device needs at least 3 axes).
+ *
+ *
+ * Example of force coming from the south with all encodings (force coming
+ *  from the south means the user will have to pull the stick to counteract):
+ * \code
+ * SDL_HapticDirection direction;
+ *
+ * // Cartesian directions
+ * direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
+ * direction.dir[0] = 0; // X position
+ * direction.dir[1] = 1; // Y position
+ * // Assuming the device has 2 axes, we don't need to specify third parameter.
+ *
+ * // Polar directions
+ * direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
+ * direction.dir[0] = 18000; // Polar only uses first parameter
+ *
+ * // Spherical coordinates
+ * direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
+ * direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
+ * \endcode
+ *
+ * \sa SDL_HAPTIC_POLAR
+ * \sa SDL_HAPTIC_CARTESIAN
+ * \sa SDL_HAPTIC_SPHERICAL
+ * \sa SDL_HapticEffect
+ * \sa SDL_HapticNumAxes
+ */
+typedef struct SDL_HapticDirection
+{
+    Uint8 type;         /**< The type of encoding. */
+    Uint16 dir[3];      /**< The encoded direction. */
+} SDL_HapticDirection;
+
+
+/**
+ * \struct SDL_HapticConstant
+ *
+ * \brief A structure containing a template for a Constant effect.
+ *
+ * The struct is exclusive to the SDL_HAPTIC_CONSTANT effect.
+ *
+ * A constant effect applies a constant force in the specified direction
+ *  to the joystick.
+ *
+ * \sa SDL_HAPTIC_CONSTANT
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticConstant
+{
+    /* Header */
+    Uint16 type;            /**< SDL_HAPTIC_CONSTANT */
+    SDL_HapticDirection direction;  /**< Direction of the effect. */
+
+    /* Replay */
+    Uint32 length;          /**< Duration of the effect. */
+    Uint16 delay;           /**< Delay before starting the effect. */
+
+    /* Trigger */
+    Uint16 button;          /**< Button that triggers the effect. */
+    Uint16 interval;        /**< How soon it can be triggered again after button. */
+
+    /* Constant */
+    Sint16 level;           /**< Strength of the constant effect. */
+
+    /* Envelope */
+    Uint16 attack_length;   /**< Duration of the attack. */
+    Uint16 attack_level;    /**< Level at the start of the attack. */
+    Uint16 fade_length;     /**< Duration of the fade. */
+    Uint16 fade_level;      /**< Level at the end of the fade. */
+} SDL_HapticConstant;
+/**
+ * \struct SDL_HapticPeriodic
+ *
+ * \brief A structure containing a template for a Periodic effect.
+ *
+ * The struct handles the following effects:
+ *   - SDL_HAPTIC_SINE
+ *   - SDL_HAPTIC_SQUARE
+ *   - SDL_HAPTIC_TRIANGLE
+ *   - SDL_HAPTIC_SAWTOOTHUP
+ *   - SDL_HAPTIC_SAWTOOTHDOWN
+ *
+ * A periodic effect consists in a wave-shaped effect that repeats itself
+ *  over time.  The type determines the shape of the wave and the parameters
+ *  determine the dimensions of the wave.
+ *
+ * Phase is given by hundredth of a cyle meaning that giving the phase a value
+ *  of 9000 will displace it 25% of it's period.  Here are sample values:
+ *    -     0: No phase displacement.
+ *    -  9000: Displaced 25% of it's period.
+ *    - 18000: Displaced 50% of it's period.
+ *    - 27000: Displaced 75% of it's period.
+ *    - 36000: Displaced 100% of it's period, same as 0, but 0 is preffered.
+ *
+ * Examples:
+ * \code
+ * SDL_HAPTIC_SINE
+ *   __      __      __      __
+ *  /  \    /  \    /  \    /
+ * /    \__/    \__/    \__/
+ *
+ * SDL_HAPTIC_SQUARE
+ *  __    __    __    __    __
+ * |  |  |  |  |  |  |  |  |  |
+ * |  |__|  |__|  |__|  |__|  |
+ *
+ * SDL_HAPTIC_TRIANGLE
+ *   /\    /\    /\    /\    /\
+ *  /  \  /  \  /  \  /  \  /
+ * /    \/    \/    \/    \/
+ *
+ * SDL_HAPTIC_SAWTOOTHUP
+ *   /|  /|  /|  /|  /|  /|  /|
+ *  / | / | / | / | / | / | / |
+ * /  |/  |/  |/  |/  |/  |/  |
+ *
+ * SDL_HAPTIC_SAWTOOTHDOWN
+ * \  |\  |\  |\  |\  |\  |\  |
+ *  \ | \ | \ | \ | \ | \ | \ |
+ *   \|  \|  \|  \|  \|  \|  \|
+ * \endcode
+ *
+ * \sa SDL_HAPTIC_SINE
+ * \sa SDL_HAPTIC_SQUARE
+ * \sa SDL_HAPTIC_TRIANGLE
+ * \sa SDL_HAPTIC_SAWTOOTHUP
+ * \sa SDL_HAPTIC_SAWTOOTHDOWN
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticPeriodic
+{
+    /* Header */
+    Uint16 type;        /**< SDL_HAPTIC_SINE, SDL_HAPTIC_SQUARE,
+                             SDL_HAPTIC_TRIANGLE, SDL_HAPTIC_SAWTOOTHUP or
+                             SDL_HAPTIC_SAWTOOTHDOWN */
+    SDL_HapticDirection direction;  /**< Direction of the effect. */
+
+    /* Replay */
+    Uint32 length;      /**< Duration of the effect. */
+    Uint16 delay;       /**< Delay before starting the effect. */
+
+    /* Trigger */
+    Uint16 button;      /**< Button that triggers the effect. */
+    Uint16 interval;    /**< How soon it can be triggered again after button. */
+
+    /* Periodic */
+    Uint16 period;      /**< Period of the wave. */
+    Sint16 magnitude;   /**< Peak value. */
+    Sint16 offset;      /**< Mean value of the wave. */
+    Uint16 phase;       /**< Horizontal shift given by hundredth of a cycle. */
+
+    /* Envelope */
+    Uint16 attack_length;   /**< Duration of the attack. */
+    Uint16 attack_level;    /**< Level at the start of the attack. */
+    Uint16 fade_length; /**< Duration of the fade. */
+    Uint16 fade_level;  /**< Level at the end of the fade. */
+} SDL_HapticPeriodic;
+/**
+ * \struct SDL_HapticCondition
+ *
+ * \brief A structure containing a template for a Condition effect.
+ *
+ * The struct handles the following effects:
+ *   - SDL_HAPTIC_SPRING: Effect based on axes position.
+ *   - SDL_HAPTIC_DAMPER: Effect based on axes velocity.
+ *   - SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
+ *   - SDL_HAPTIC_FRICTION: Effect based on axes movement.
+ *
+ * Direction is handled by condition internals instead of a direction member.
+ *  The condition effect specific members have three parameters.  The first
+ *  refers to the X axis, the second refers to the Y axis and the third
+ *  refers to the Z axis.  The right terms refer to the positive side of the
+ *  axis and the left terms refer to the negative side of the axis.  Please 
+ *  refer to the SDL_HapticDirection  diagram for which side is positive and
+ *  which is negative.
+ *
+ * \sa SDL_HapticDirection
+ * \sa SDL_HAPTIC_SPRING
+ * \sa SDL_HAPTIC_DAMPER
+ * \sa SDL_HAPTIC_INERTIA
+ * \sa SDL_HAPTIC_FRICTION
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticCondition
+{
+    /* Header */
+    Uint16 type;            /**< SDL_HAPTIC_SPRING, SDL_HAPTIC_DAMPER,
+                                 SDL_HAPTIC_INERTIA or SDL_HAPTIC_FRICTION */
+    SDL_HapticDirection direction;  /**< Direction of the effect - Not used ATM. */
+
+    /* Replay */
+    Uint32 length;          /**< Duration of the effect. */
+    Uint16 delay;           /**< Delay before starting the effect. */
+
+    /* Trigger */
+    Uint16 button;          /**< Button that triggers the effect. */
+    Uint16 interval;        /**< How soon it can be triggered again after button. */
+
+    /* Condition */
+    Uint16 right_sat[3];    /**< Level when joystick is to the positive side. */
+    Uint16 left_sat[3];     /**< Level when joystick is to the negative side. */
+    Sint16 right_coeff[3];  /**< How fast to increase the force towards the positive side. */
+    Sint16 left_coeff[3];   /**< How fast to increase the force towards the negative side. */
+    Uint16 deadband[3];     /**< Size of the dead zone. */
+    Sint16 center[3];       /**< Position of the dead zone. */
+} SDL_HapticCondition;
+/**
+ * \struct SDL_HapticRamp
+ *
+ * \brief A structure containing a template for a Ramp effect.
+ *
+ * This struct is exclusively for the SDL_HAPTIC_RAMP effect.
+ *
+ * The ramp effect starts at start strength and ends at end strength.
+ *  It augments in linear fashion.  If you use attack and fade with a ramp
+ *  they effects get added to the ramp effect making the effect become
+ *  quadratic instead of linear.
+ *
+ * \sa SDL_HAPTIC_RAMP
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticRamp
+{
+    /* Header */
+    Uint16 type;            /**< SDL_HAPTIC_RAMP */
+    SDL_HapticDirection direction;  /**< Direction of the effect. */
+
+    /* Replay */
+    Uint32 length;          /**< Duration of the effect. */
+    Uint16 delay;           /**< Delay before starting the effect. */
+
+    /* Trigger */
+    Uint16 button;          /**< Button that triggers the effect. */
+    Uint16 interval;        /**< How soon it can be triggered again after button. */
+
+    /* Ramp */
+    Sint16 start;           /**< Beginning strength level. */
+    Sint16 end;             /**< Ending strength level. */
+
+    /* Envelope */
+    Uint16 attack_length;   /**< Duration of the attack. */
+    Uint16 attack_level;    /**< Level at the start of the attack. */
+    Uint16 fade_length;     /**< Duration of the fade. */
+    Uint16 fade_level;      /**< Level at the end of the fade. */
+} SDL_HapticRamp;
+/**
+ * \struct SDL_HapticCustom
+ *
+ * \brief A structure containing a template for the SDL_HAPTIC_CUSTOM effect.
+ *
+ * A custom force feedback effect is much like a periodic effect, where the
+ *  application can define it's exact shape.  You will have to allocate the
+ *  data yourself.  Data should consist of channels * samples Uint16 samples.
+ *
+ * If channels is one, the effect is rotated using the defined direction.
+ *  Otherwise it uses the samples in data for the different axes.
+ *
+ * \sa SDL_HAPTIC_CUSTOM
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticCustom
+{
+    /* Header */
+    Uint16 type;            /**< SDL_HAPTIC_CUSTOM */
+    SDL_HapticDirection direction;  /**< Direction of the effect. */
+
+    /* Replay */
+    Uint32 length;          /**< Duration of the effect. */
+    Uint16 delay;           /**< Delay before starting the effect. */
+
+    /* Trigger */
+    Uint16 button;          /**< Button that triggers the effect. */
+    Uint16 interval;        /**< How soon it can be triggered again after button. */
+
+    /* Custom */
+    Uint8 channels;         /**< Axes to use, minimum of one. */
+    Uint16 period;          /**< Sample periods. */
+    Uint16 samples;         /**< Amount of samples. */
+    Uint16 *data;           /**< Should contain channels*samples items. */
+
+    /* Envelope */
+    Uint16 attack_length;   /**< Duration of the attack. */
+    Uint16 attack_level;    /**< Level at the start of the attack. */
+    Uint16 fade_length;     /**< Duration of the fade. */
+    Uint16 fade_level;      /**< Level at the end of the fade. */
+} SDL_HapticCustom;
+/**
+ * \union SDL_HapticEffect
+ *
+ * \brief The generic template for any haptic effect.
+ *
+ * All values max at 32767 (0x7FFF).  Signed values also can be negative.
+ *  Time values unless specified otherwise are in milliseconds.
+ *
+ * You can also pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value.
+ *  Neither delay, interval, attack_length nor fade_length support 
+ *  SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
+ *
+ * Additionally, the SDL_HAPTIC_RAMP effect does not support a duration of
+ *  SDL_HAPTIC_INFINITY.
+ *
+ * Button triggers may not be supported on all devices, it is advised to not
+ *  use them if possible.  Buttons start at index 1 instead of index 0 like
+ *  they joystick.
+ *
+ * If both attack_length and fade_level are 0, the envelope is not used,
+ *  otherwise both values are used.
+ *
+ * Common parts:
+ * \code
+ * // Replay - All effects have this
+ * Uint32 length;        // Duration of effect (ms).
+ * Uint16 delay;         // Delay before starting effect.
+ *
+ * // Trigger - All effects have this
+ * Uint16 button;        // Button that triggers effect.
+ * Uint16 interval;      // How soon before effect can be triggered again.
+ *
+ * // Envelope - All effects except condition effects have this
+ * Uint16 attack_length; // Duration of the attack (ms).
+ * Uint16 attack_level;  // Level at the start of the attack.
+ * Uint16 fade_length;   // Duration of the fade out (ms).
+ * Uint16 fade_level;    // Level at the end of the fade.
+ * \endcode
+ *
+ *
+ * Here we have an example of a constant effect evolution in time:
+ *
+ * \code
+ * Strength
+ * ^
+ * |
+ * |    effect level -->  _________________
+ * |                     /                 \
+ * |                    /                   \
+ * |                   /                     \
+ * |                  /                       \ 
+ * | attack_level --> |                        \
+ * |                  |                        |  <---  fade_level
+ * |
+ * +--------------------------------------------------> Time
+ *                    [--]                 [---]
+ *                    attack_length        fade_length
+ * 
+ * [------------------][-----------------------]
+ * delay               length
+ * \endcode
+ *
+ * Note either the attack_level or the fade_level may be above the actual
+ *  effect level.
+ *
+ * \sa SDL_HapticConstant
+ * \sa SDL_HapticPeriodic
+ * \sa SDL_HapticCondition
+ * \sa SDL_HapticRamp
+ * \sa SDL_HapticCustom
+ */
+typedef union SDL_HapticEffect
+{
+    /* Common for all force feedback effects */
+    Uint16 type;                    /**< Effect type. */
+    SDL_HapticConstant constant;    /**< Constant effect. */
+    SDL_HapticPeriodic periodic;    /**< Periodic effect. */
+    SDL_HapticCondition condition;  /**< Condition effect. */
+    SDL_HapticRamp ramp;            /**< Ramp effect. */
+    SDL_HapticCustom custom;        /**< Custom effect. */
+} SDL_HapticEffect;
+
+
+/* Function prototypes */
+/**
+ * \fn int SDL_NumHaptics(void)
+ *
+ * \brief Count the number of joysticks attached to the system.
+ *
+ *    \return Number of haptic devices detected on the system.
+ */
+extern DECLSPEC int SDLCALL SDL_NumHaptics(void);
+
+/**
+ * \fn const char * SDL_HapticName(int device_index)
+ *
+ * \brief Get the implementation dependent name of a Haptic device.
+ * This can be called before any joysticks are opened.
+ * If no name can be found, this function returns NULL.
+ *
+ *    \param device_index Index of the device to get it's name.
+ *    \return Name of the device or NULL on error.
+ *
+ * \sa SDL_NumHaptics
+ */
+extern DECLSPEC const char *SDLCALL SDL_HapticName(int device_index);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpen(int device_index)
+ *
+ * \brief Opens a Haptic device for usage - the index passed as an
+ * argument refers to the N'th Haptic device on this system.
+ *
+ * When opening a haptic device, it's gain will be set to maximum and
+ *  autocenter will be disabled.  To modify these values use
+ *  SDL_HapticSetGain and SDL_HapticSetAutocenter
+ *
+ *    \param device_index Index of the device to open.
+ *    \return Device identifier or NULL on error.
+ *
+ * \sa SDL_HapticIndex
+ * \sa SDL_HapticOpenFromMouse
+ * \sa SDL_HapticOpenFromJoystick
+ * \sa SDL_HapticClose
+ * \sa SDL_HapticSetGain
+ * \sa SDL_HapticSetAutocenter
+ * \sa SDL_HapticPause
+ * \sa SDL_HapticStopAll
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpen(int device_index);
+
+/**
+ * \fn int SDL_HapticOpened(int device_index)
+ *
+ * \brief Checks if the haptic device at index has been opened.
+ *
+ *    \param device_index Index to check to see if it has been opened.
+ *    \return 1 if it has been opened or 0 if it hasn't.
+ * 
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticIndex
+ */
+extern DECLSPEC int SDLCALL SDL_HapticOpened(int device_index);
+
+/**
+ * \fn int SDL_HapticIndex(SDL_Haptic * haptic)
+ *
+ * \brief Gets the index of a haptic device.
+ *
+ *    \param haptic Haptic device to get the index of.
+ *    \return The index of the haptic device or -1 on error.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticOpened
+ */
+extern DECLSPEC int SDLCALL SDL_HapticIndex(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_MouseIsHaptic(void)
+ *
+ * \brief Gets whether or not the current mouse has haptic capabilities.
+ *
+ *    \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
+ *
+ * \sa SDL_HapticOpenFromMouse
+ */
+extern DECLSPEC int SDLCALL SDL_MouseIsHaptic(void);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpenFromMouse(void)
+ *
+ * \brief Tries to open a haptic device from the current mouse.
+ *
+ *    \return The haptic device identifier or NULL on error.
+ *
+ * \sa SDL_MouseIsHaptic
+ * \sa SDL_HapticOpen
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpenFromMouse(void);
+
+/**
+ * \fn int SDL_JoystickIsHaptic(SDL_Joystick * joystick)
+ *
+ * \brief Checks to see if a joystick has haptic features.
+ *
+ *    \param joystick Joystick to test for haptic capabilities.
+ *    \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
+ *            or -1 if an error ocurred.
+ *
+ * \sa SDL_HapticOpenFromJoystick
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickIsHaptic(SDL_Joystick * joystick);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)
+ *
+ * \brief Opens a Haptic device for usage from a Joystick device.  Still has
+ * to be closed seperately to the joystick.
+ *
+ * When opening from a joystick you should first close the haptic device before
+ *  closing the joystick device.  If not, on some implementations the haptic
+ *  device will also get unallocated and you'll be unable to use force feedback
+ *  on that device.
+ *
+ *    \param joystick Joystick to create a haptic device from.
+ *    \return A valid haptic device identifier on success or NULL on error.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticClose
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpenFromJoystick(SDL_Joystick *
+                                                               joystick);
+
+/**
+ * \fn void SDL_HapticClose(SDL_Haptic * haptic)
+ *
+ * \brief Closes a Haptic device previously opened with SDL_HapticOpen.
+ *
+ *    \param haptic Haptic device to close.
+ */
+extern DECLSPEC void SDLCALL SDL_HapticClose(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticNumEffects(SDL_Haptic * haptic)
+ *
+ * \brief Returns the number of effects a haptic device can store.
+ *
+ * On some platforms this isn't fully supported, and therefore is an
+ *  aproximation.  Always check to see if your created effect was actually
+ *  created and do not rely solely on HapticNumEffects.
+ *
+ *    \param haptic The haptic device to query effect max.
+ *    \return The number of effects the haptic device can store or
+ *            -1 on error.
+ *
+ * \sa SDL_HapticNumEffectsPlaying
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumEffects(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic)
+ *
+ * \brief Returns the number of effects a haptic device can play at the same time.
+ *
+ * This is not supported on all platforms, but will always return a value.  Added
+ *  here for the sake of completness.
+ *
+ *    \param haptic The haptic device to query maximum playing effect.s
+ *    \return The number of effects the haptic device can play at the same time
+ *            or -1 on error.
+ *
+ * \sa SDL_HapticNumEffects
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);
+
+/**
+ * \fn unsigned int SDL_HapticQuery(SDL_Haptic * haptic)
+ *
+ * \brief Gets the haptic devices supported features in bitwise matter.
+ *
+ * Example: 
+ * \code
+ * if (SDL_HapticQueryEffects(haptic) & SDL_HAPTIC_CONSTANT) {
+ *    printf("We have constant haptic effect!");
+ * }
+ * \endcode
+ *    
+ *
+ *    \param haptic The haptic device to query.
+ *    \return Haptic features in bitwise manner (OR'd).
+ *
+ * \sa SDL_HapticNumEffects
+ * \sa SDL_HapticEffectSupported
+ */
+extern DECLSPEC unsigned int SDLCALL SDL_HapticQuery(SDL_Haptic * haptic);
+
+
+/**
+ * \fn int SDL_HapticNumAxes(SDL_Haptic * haptic)
+ *
+ * \brief Gets the number of haptic axes the device has.
+ *
+ * \sa SDL_HapticDirection
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumAxes(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+ *
+ * \brief Checks to see if effect is supported by haptic.
+ *
+ *    \param haptic Haptic device to check on.
+ *    \param effect Effect to check to see if it is supported.
+ *    \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or 
+ *            -1 on error.
+ * 
+ * \sa SDL_HapticQuery
+ * \sa SDL_HapticNewEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticEffectSupported(SDL_Haptic * haptic,
+                                                      SDL_HapticEffect *
+                                                      effect);
+
+/**
+ * \fn int SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+ *
+ * \brief Creates a new haptic effect on the device.
+ *
+ *    \param haptic Haptic device to create the effect on.
+ *    \param effect Properties of the effect to create.
+ *    \return The id of the effect on success or -1 on error.
+ *
+ * \sa SDL_HapticUpdateEffect
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNewEffect(SDL_Haptic * haptic,
+                                                SDL_HapticEffect * effect);
+
+/**
+ * \fn int SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data)
+ *
+ * \brief Updates the properties of an effect.
+ *
+ * Can be used dynamically, although behaviour when dynamically changing
+ * direction may be strange.  Specifically the effect may reupload itself
+ * and start playing from the start.  You cannot change the type either when
+ * running UpdateEffect.
+ *
+ *    \param haptic Haptic device that has the effect.
+ *    \param effect Effect to update.
+ *    \param data New effect properties to use.
+ *    \return The id of the effect on success or -1 on error.
+ *
+ * \sa SDL_HapticNewEffect
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticUpdateEffect(SDL_Haptic * haptic,
+                                                   int effect,
+                                                   SDL_HapticEffect * data);
+
+/**
+ * \fn int SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations)
+ *
+ * \brief Runs the haptic effect on it's assosciated haptic device.
+ *
+ * If iterations are SDL_HAPTIC_INFINITY, it'll run the effect over and over
+ *  repeating the envelope (attack and fade) every time.  If you only want the
+ *  effect to last forever, set SDL_HAPTIC_INFINITY in the effect's length
+ *  parameter.
+ *
+ *    \param haptic Haptic device to run the effect on.
+ *    \param effect Identifier of the haptic effect to run.
+ *    \param iterations Number of iterations to run the effect. Use
+ *           SDL_HAPTIC_INFINITY for infinity.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticStopEffect
+ * \sa SDL_HapticDestroyEffect
+ * \sa SDL_HapticGetEffectStatus
+ */
+extern DECLSPEC int SDLCALL SDL_HapticRunEffect(SDL_Haptic * haptic,
+                                                int effect,
+                                                Uint32 iterations);
+
+/**
+ * \fn int SDL_HapticStopEffect(SDL_Haptic * haptic, int effect)
+ *
+ * \brief Stops the haptic effect on it's assosciated haptic device.
+ *
+ *    \param haptic Haptic device to stop the effect on.
+ *    \param effect Identifier of the effect to stop.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticStopEffect(SDL_Haptic * haptic,
+                                                 int effect);
+
+/**
+ * \fn void SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect)
+ *
+ * \brief Destroys a haptic effect on the device.  This will stop the effect
+ * if it's running.  Effects are automatically destroyed when the device is
+ * closed.
+ *
+ *    \param haptic Device to destroy the effect on.
+ *    \param effect Identifier of the effect to destroy.
+ * 
+ * \sa SDL_HapticNewEffect
+ */
+extern DECLSPEC void SDLCALL SDL_HapticDestroyEffect(SDL_Haptic * haptic,
+                                                     int effect);
+
+/**
+ * \fn int SDL_HapticGetEffectStatus(SDL_Haptic *haptic, int effect)
+ *
+ * \brief Gets the status of the current effect on the haptic device.
+ *
+ * Device must support the SDL_HAPTIC_STATUS feature.
+ *
+ *    \param haptic Haptic device to query the effect status on.
+ *    \param effect Identifier of the effect to query it's status.
+ *    \return 0 if it isn't playing, SDL_HAPTIC_PLAYING if it is playing
+ *            or -1 on error.
+ *
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticStopEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticGetEffectStatus(SDL_Haptic * haptic,
+                                                      int effect);
+
+/**
+ * \fn int SDL_HapticSetGain(SDL_Haptic * haptic, int gain)
+ *
+ * \brief Sets the global gain of the device.  Gain should be between 0 and 100.
+ *
+ * Device must support the SDL_HAPTIC_GAIN feature.
+ *
+ * The user may specify the maxmimum gain by setting the environment variable
+ *  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
+ *  SDL_HapticSetGain will scale linearly using SDL_HAPTIC_GAIN_MAX as the
+ *  maximum.
+ *
+ *    \param haptic Haptic device to set the gain on.
+ *    \param gain Value to set the gain to, should be between 0 and 100.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticSetGain(SDL_Haptic * haptic, int gain);
+
+/**
+ * \fn int SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+ *
+ * \brief Sets the global autocenter of the device.  Autocenter should be between
+ * 0 and 100.  Setting it to 0 will disable autocentering.
+ *
+ * Device must support the SDL_HAPTIC_AUTOCENTER feature.
+ *
+ *    \param haptic Haptic device to set autocentering on.
+ *    \param autocenter Value to set autocenter to, 0 disables autocentering.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticSetAutocenter(SDL_Haptic * haptic,
+                                                    int autocenter);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticPause(SDL_Haptic * haptic)
+ *
+ * \brief Pauses a haptic device.
+ *
+ * Device must support the SDL_HAPTIC_PAUSE feature.  Call SDL_HapticUnpause
+ *  to resume playback.
+ *
+ * Do not modify the effects nor add new ones while the device is paused.
+ *  That can cause all sorts of weird errors.
+ *
+ *    \param haptic Haptic device to pause.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticUnpause
+ */
+extern DECLSPEC int SDLCALL SDL_HapticPause(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticUnpause(SDL_Haptic * haptic)
+ *
+ * \brief Unpauses a haptic device.
+ *
+ * Call to unpause after SDL_HapticPause.
+ *
+ *    \param haptic Haptic device to pause.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticPause
+ */
+extern DECLSPEC int SDLCALL SDL_HapticUnpause(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECSLPEC int SDLCALL SDL_HapticStopAll(SDL_Haptic * haptic)
+ *
+ * \brief Stops all the currently playing effects on a haptic device.
+ *
+ *    \param haptic Haptic device to stop.
+ *    \return 0 on success or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_HapticStopAll(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticMinDuration(SDL_Haptic * haptic)
+ *
+ * \brief Palm Edit: Returns minimum vibration duration of device
+ *
+ *   \param haptic Haptic device to get minimum duration for
+ *   \return minimum duration on successt or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_HapticMinDuration(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticMaxDuration(SDL_Haptic * haptic)
+ *
+ * \brief Palm Edit: Returns maximum vibration duration of device
+ *
+ *   \param haptic Haptic device to get maximum duration for
+ *   \return maximum duration on successt or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_HapticMaxDuration(SDL_Haptic * haptic);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_haptic_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -pruN libsdl-1.2/include/SDL_mouse.h libsdl-1.2-palm/include/SDL_mouse.h
--- libsdl-1.2/include/SDL_mouse.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_mouse.h	2009-06-22 13:35:19.000000000 -0700
@@ -52,6 +52,9 @@ typedef struct SDL_Cursor {
  * be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  * current mouse cursor position.  You can pass NULL for either x or y.
  */
+//PALM
+extern DECLSPEC Uint8 SDLCALL SDL_GetMultiMouseState(int which, int *x, int *y);
+///PALM
 extern DECLSPEC Uint8 SDLCALL SDL_GetMouseState(int *x, int *y);
 
 /*
@@ -60,6 +63,9 @@ extern DECLSPEC Uint8 SDLCALL SDL_GetMou
  * be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  * mouse deltas since the last call to SDL_GetRelativeMouseState().
  */
+//PALM
+extern DECLSPEC Uint8 SDLCALL SDL_GetRelativeMultiMouseState(int which, int *x, int *y);
+///PALM
 extern DECLSPEC Uint8 SDLCALL SDL_GetRelativeMouseState(int *x, int *y);
 
 /*
@@ -130,6 +136,8 @@ extern DECLSPEC int SDLCALL SDL_ShowCurs
 #define SDL_BUTTON_X1MASK	SDL_BUTTON(SDL_BUTTON_X1)
 #define SDL_BUTTON_X2MASK	SDL_BUTTON(SDL_BUTTON_X2)
 
+/* PALM - Defines the maximum of number of mice */
+#define SDL_MAXMOUSE        5
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -pruN libsdl-1.2/include/SDL_opengles_ext.h libsdl-1.2-palm/include/SDL_opengles_ext.h
--- libsdl-1.2/include/SDL_opengles_ext.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_opengles_ext.h	2009-07-13 11:28:45.000000000 -0700
@@ -0,0 +1,714 @@
+#ifndef __glext_h_
+#define __glext_h_
+
+/* $Id: glext.h 1.2 2008/03/31 09:44:00 benji.bowman Exp $ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+** License Applicability. Except to the extent portions of this file are
+** made subject to an alternative license as permitted in the SGI Free
+** Software License B, Version 1.0 (the "License"), the contents of this
+** file are subject only to the provisions of the License. You may not use
+** this file except in compliance with the License. You may obtain a copy
+** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
+** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
+**
+** http://oss.sgi.com/projects/FreeB
+**
+** Note that, as provided in the License, the Software is distributed on an
+** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
+** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
+** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
+** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+**
+** Original Code. The Original Code is: OpenGL Sample Implementation,
+** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
+** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
+** Copyright in any portions created by third parties is as indicated
+** elsewhere herein. All Rights Reserved.
+**
+** Additional Notice Provisions: The application programming interfaces
+** established by SGI in conjunction with the Original Code are The
+** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
+** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
+** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
+** Window System(R) (Version 1.3), released October 19, 1998. This software
+** was created using the OpenGL(R) version 1.2.1 Sample Implementation
+** published by SGI, but has not been independently verified as being
+** compliant with the OpenGL(R) version 1.2.1 Specification.
+*/
+
+#ifndef GL_APIENTRYP
+#   define GL_APIENTRYP GL_APIENTRY*
+#endif
+
+/*------------------------------------------------------------------------*
+ * OES extension tokens
+ *------------------------------------------------------------------------*/
+
+/* GL_OES_blend_equation_separate */
+#ifndef GL_OES_blend_equation_separate
+/* BLEND_EQUATION_RGB_OES same as BLEND_EQUATION_OES */
+#define GL_BLEND_EQUATION_RGB_OES                               0x8009
+#define GL_BLEND_EQUATION_ALPHA_OES                             0x883D
+#endif
+
+/* GL_OES_blend_func_separate */
+#ifndef GL_OES_blend_func_separate
+#define GL_BLEND_DST_RGB_OES                                    0x80C8
+#define GL_BLEND_SRC_RGB_OES                                    0x80C9
+#define GL_BLEND_DST_ALPHA_OES                                  0x80CA
+#define GL_BLEND_SRC_ALPHA_OES                                  0x80CB
+#endif
+
+/* GL_OES_blend_subtract */
+#ifndef GL_OES_blend_subtract
+#define GL_BLEND_EQUATION_OES                                   0x8009
+#define GL_FUNC_ADD_OES                                         0x8006
+#define GL_FUNC_SUBTRACT_OES                                    0x800A
+#define GL_FUNC_REVERSE_SUBTRACT_OES                            0x800B
+#endif
+
+/* GL_OES_compressed_ETC1_RGB8_texture */
+#ifndef GL_OES_compressed_ETC1_RGB8_texture
+#define GL_ETC1_RGB8_OES                                        0x8D64
+#endif
+
+/* OES_draw_texture */
+#ifndef GL_OES_draw_texture
+#define GL_TEXTURE_CROP_RECT_OES                                0x8B9D
+#endif
+
+/* OES_fixed_point */
+#ifndef GL_OES_fixed_point
+#define GL_FIXED_OES                                            0x140C
+#endif
+
+/* OES_framebuffer_object */
+#ifndef GL_OES_framebuffer_object
+#define GL_FRAMEBUFFER_OES                                      0x8D40
+#define GL_RENDERBUFFER_OES                                     0x8D41
+#define GL_RGBA4_OES                                            0x8056
+#define GL_RGB5_A1_OES                                          0x8057
+#define GL_RGB565_OES                                           0x8D62
+#define GL_DEPTH_COMPONENT16_OES                                0x81A5
+#define GL_RENDERBUFFER_WIDTH_OES                               0x8D42
+#define GL_RENDERBUFFER_HEIGHT_OES                              0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT_OES                     0x8D44
+#define GL_RENDERBUFFER_RED_SIZE_OES                            0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE_OES                          0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE_OES                           0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE_OES                          0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE_OES                          0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE_OES                        0x8D55
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES               0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES               0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES             0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES     0x8CD3
+#define GL_COLOR_ATTACHMENT0_OES                                0x8CE0
+#define GL_DEPTH_ATTACHMENT_OES                                 0x8D00
+#define GL_STENCIL_ATTACHMENT_OES                               0x8D20
+#define GL_FRAMEBUFFER_COMPLETE_OES                             0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES                0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES        0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES                0x8CD9
+#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES                   0x8CDA
+#define GL_FRAMEBUFFER_UNSUPPORTED_OES                          0x8CDD
+#define GL_FRAMEBUFFER_BINDING_OES                              0x8CA6
+#define GL_RENDERBUFFER_BINDING_OES                             0x8CA7
+#define GL_MAX_RENDERBUFFER_SIZE_OES                            0x84E8
+#define GL_INVALID_FRAMEBUFFER_OPERATION_OES                    0x0506
+#endif
+
+/* OES_matrix_get */
+#ifndef GL_OES_matrix_get
+#define GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES               0x898D
+#define GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES              0x898E
+#define GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES                 0x898F
+#endif
+
+/* OES_matrix_palette */
+#ifndef GL_OES_matrix_palette
+#define GL_MAX_VERTEX_UNITS_OES                                 0x86A4
+#define GL_MAX_PALETTE_MATRICES_OES                             0x8842
+#define GL_MATRIX_PALETTE_OES                                   0x8840
+#define GL_MATRIX_INDEX_ARRAY_OES                               0x8844
+#define GL_WEIGHT_ARRAY_OES                                     0x86AD
+#define GL_CURRENT_PALETTE_MATRIX_OES                           0x8843
+#define GL_MATRIX_INDEX_ARRAY_SIZE_OES                          0x8846
+#define GL_MATRIX_INDEX_ARRAY_TYPE_OES                          0x8847
+#define GL_MATRIX_INDEX_ARRAY_STRIDE_OES                        0x8848
+#define GL_MATRIX_INDEX_ARRAY_POINTER_OES                       0x8849
+#define GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES                0x8B9E
+#define GL_WEIGHT_ARRAY_SIZE_OES                                0x86AB
+#define GL_WEIGHT_ARRAY_TYPE_OES                                0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_OES                              0x86AA
+#define GL_WEIGHT_ARRAY_POINTER_OES                             0x86AC
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING_OES                      0x889E
+#endif
+
+/* GL_OES_stencil_wrap */
+#ifndef GL_OES_stencil_wrap
+#define GL_INCR_WRAP_OES                                        0x8507
+#define GL_DECR_WRAP_OES                                        0x8508
+#endif
+
+/* GL_OES_texture_cube_map */
+#ifndef GL_OES_texture_cube_map
+#define GL_NORMAL_MAP_OES                                       0x8511
+#define GL_REFLECTION_MAP_OES                                   0x8512
+#define GL_TEXTURE_CUBE_MAP_OES                                 0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_OES                         0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES                      0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES                      0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES                      0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES                      0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES                      0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES                      0x851A
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES                        0x851C
+#define GL_TEXTURE_GEN_MODE_OES                                 0x2500
+#define GL_TEXTURE_GEN_STR_OES                                  0x8D60
+#endif
+
+/* GL_OES_texture_mirrored_repeat */
+#ifndef GL_OES_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_OES                                  0x8370
+#endif
+
+/* GL_OES_EGL_image */
+#ifndef GL_OES_EGL_image
+typedef void* GLeglImageOES;
+#endif
+
+/* GL_OES_depth24 */
+#ifndef GL_OES_depth24
+#define GL_DEPTH_COMPONENT24_OES                                0x81A6
+#endif
+
+/* GL_OES_depth32 */
+#ifndef GL_OES_depth32
+#define GL_DEPTH_COMPONENT32_OES                                0x81A7
+#endif
+
+/* GL_OES_mapbuffer */
+#ifndef GL_OES_mapbuffer
+#define GL_WRITE_ONLY_OES                                       0x88B9
+#define GL_BUFFER_ACCESS_OES                                    0x88BB
+#define GL_BUFFER_MAPPED_OES                                    0x88BC
+#define GL_BUFFER_MAP_POINTER_OES                               0x88BD
+#endif
+
+/* GL_OES_rgb8_rgba8 */
+#ifndef GL_OES_rgb8_rgba8
+#define GL_RGB8_OES                                             0x8051
+#define GL_RGBA8_OES                                            0x8058
+#endif
+
+/* GL_OES_stencil1 */
+#ifndef GL_OES_stencil1
+#define GL_STENCIL_INDEX1_OES                                   0x8D46
+#endif
+
+/* GL_OES_stencil4 */
+#ifndef GL_OES_stencil4
+#define GL_STENCIL_INDEX4_OES                                   0x8D47
+#endif
+
+/* GL_OES_stencil8 */
+#ifndef GL_OES_stencil8
+#define GL_STENCIL_INDEX8_OES                                   0x8D48
+#endif
+
+/* GL_AMD_compressed_3DC_texture */
+#ifndef GL_AMD_compressed_3DC_texture
+#define GL_3DC_X_AMD                                            0x87F9
+#define GL_3DC_XY_AMD                                           0x87FA
+#endif
+
+/* GL_AMD_compressed_ATC_texture */
+#ifndef GL_AMD_compressed_ATC_texture
+#define GL_ATC_RGB_AMD                                          0x8C92
+#define GL_ATC_RGBA_EXPLICIT_ALPHA_AMD                          0x8C93
+#define GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD                      0x87EE
+#endif
+
+/* GL_EXT_texture_filter_anisotropic */
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT                           0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT                       0x84FF
+#endif
+
+/* GL_IMG_read_format */
+#ifndef GL_IMG_read_format
+#define GL_UNSIGNED_SHORT_4_4_4_4_REV							0x8365
+#define GL_BGRA													0x80E1
+#endif
+
+/* GL_IMG_texture_format_BGRA8888 */
+#ifndef GL_IMG_texture_format_BGRA8888
+#ifndef GL_BGRA
+#define GL_BGRA													0x80E1
+#endif
+#endif
+
+/* GL_IMG_texture_stream */
+#ifndef GL_IMG_texture_stream
+#define GL_TEXTURE_STREAM_IMG 									0x8C0D 	
+#define GL_TEXTURE_NUM_STREAM_DEVICES_IMG 						0x8C0E 	
+#define GL_TEXTURE_STREAM_DEVICE_WIDTH_IMG 						0x8C0F
+#define GL_TEXTURE_STREAM_DEVICE_HEIGHT_IMG 					0x8EA0 	
+#define GL_TEXTURE_STREAM_DEVICE_FORMAT_IMG 					0x8EA1 	 
+#define GL_TEXTURE_STREAM_DEVICE_NUM_BUFFERS_IMG 				0x8EA2 	
+#endif
+
+/* GL_IMG_texture_compression_pvrtc */
+#ifndef GL_IMG_texture_compression_pvrtc
+#define GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG						0x8C00
+#define GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG						0x8C01
+#define GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG						0x8C02
+#define GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG						0x8C03
+#endif
+
+/* GL_IMG_vertex_program */
+#ifndef GL_IMG_vertex_program
+#define GL_VERTEX_PROGRAM_ARB									0x8620
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB					0x862E
+#define GL_MAX_PROGRAM_MATRICES_ARB								0x862F
+#define GL_MAX_VERTEX_ATTRIBS_ARB								0x8869
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB						0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB						0x88B5
+#define GL_PROGRAM_FORMAT_BINARY_IMG							0x8C0B
+#define GL_MATRIX0_ARB											0x88C0
+#define GL_MATRIX1_ARB											0x88C1
+#define GL_MATRIX2_ARB											0x88C2
+#define GL_MATRIX3_ARB											0x88C3
+#define GL_MATRIX4_ARB											0x88C4
+#define GL_MATRIX5_ARB											0x88C5
+#define GL_MATRIX6_ARB											0x88C6
+#define GL_MATRIX7_ARB											0x88C7
+#define GL_UNSIGNED_BYTE_NORM_IMG								0x8C0C
+#endif
+
+/*------------------------------------------------------------------------*
+ * OES extension functions
+ *------------------------------------------------------------------------*/
+
+/* GL_OES_blend_equation_separate */
+#ifndef GL_OES_blend_equation_separate
+#define GL_OES_blend_equation_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glBlendEquationSeparateOES (GLenum modeRGB, GLenum modeAlpha);
+#endif
+typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONSEPARATEOESPROC) (GLenum modeRGB, GLenum modeAlpha);
+#endif
+
+/* GL_OES_blend_func_separate */
+#ifndef GL_OES_blend_func_separate
+#define GL_OES_blend_func_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glBlendFuncSeparateOES (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+#endif
+typedef void (GL_APIENTRYP PFNGLBLENDFUNCSEPARATEOESPROC) (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+#endif
+
+/* GL_OES_blend_subtract */
+#ifndef GL_OES_blend_subtract
+#define GL_OES_blend_subtract 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glBlendEquationOES (GLenum mode);
+#endif
+typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONOESPROC) (GLenum mode);
+#endif
+
+/* GL_OES_byte_coordinates */
+#ifndef GL_OES_byte_coordinates
+#define GL_OES_byte_coordinates 1
+#endif
+
+/* GL_OES_compressed_ETC1_RGB8_texture */
+#ifndef GL_OES_compressed_ETC1_RGB8_texture
+#define GL_OES_compressed_ETC1_RGB8_texture 1
+#endif
+
+/* GL_OES_draw_texture */
+#ifndef GL_OES_draw_texture
+#define GL_OES_draw_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glDrawTexsOES (GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
+GL_API void GL_APIENTRY glDrawTexiOES (GLint x, GLint y, GLint z, GLint width, GLint height);
+GL_API void GL_APIENTRY glDrawTexxOES (GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);
+GL_API void GL_APIENTRY glDrawTexsvOES (const GLshort *coords);
+GL_API void GL_APIENTRY glDrawTexivOES (const GLint *coords);
+GL_API void GL_APIENTRY glDrawTexxvOES (const GLfixed *coords);
+GL_API void GL_APIENTRY glDrawTexfOES (GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
+GL_API void GL_APIENTRY glDrawTexfvOES (const GLfloat *coords);
+#endif
+typedef void (GL_APIENTRYP PFNGLDRAWTEXSOESPROC) (GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXIOESPROC) (GLint x, GLint y, GLint z, GLint width, GLint height);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXXOESPROC) (GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXSVOESPROC) (const GLshort *coords);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXIVOESPROC) (const GLint *coords);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXXVOESPROC) (const GLfixed *coords);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXFOESPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
+typedef void (GL_APIENTRYP PFNGLDRAWTEXFVOESPROC) (const GLfloat *coords);
+#endif
+
+/* GL_OES_extended_matrix_palette */
+#ifndef GL_OES_extended_matrix_palette
+#define GL_OES_extended_matrix_palette 1
+#endif
+
+/* GL_OES_fixed_point */
+#ifndef GL_OES_fixed_point
+#define GL_OES_fixed_point 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glAlphaFuncxOES (GLenum func, GLclampx ref);
+GL_API void GL_APIENTRY glClearColorxOES (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+GL_API void GL_APIENTRY glClearDepthxOES (GLclampx depth);
+GL_API void GL_APIENTRY glClipPlanexOES (GLenum plane, const GLfixed *equation);
+GL_API void GL_APIENTRY glColor4xOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+GL_API void GL_APIENTRY glDepthRangexOES (GLclampx zNear, GLclampx zFar);
+GL_API void GL_APIENTRY glFogxOES (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glFogxvOES (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glFrustumxOES (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+GL_API void GL_APIENTRY glGetClipPlanexOES (GLenum pname, GLfixed eqn[4]);
+GL_API void GL_APIENTRY glGetFixedvOES (GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetLightxvOES (GLenum light, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetMaterialxvOES (GLenum face, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetTexEnvxvOES (GLenum env, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetTexParameterxvOES (GLenum target, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glLightModelxOES (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glLightModelxvOES (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glLightxOES (GLenum light, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glLightxvOES (GLenum light, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glLineWidthxOES (GLfixed width);
+GL_API void GL_APIENTRY glLoadMatrixxOES (const GLfixed *m);
+GL_API void GL_APIENTRY glMaterialxOES (GLenum face, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glMaterialxvOES (GLenum face, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glMultMatrixxOES (const GLfixed *m);
+GL_API void GL_APIENTRY glMultiTexCoord4xOES (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+GL_API void GL_APIENTRY glNormal3xOES (GLfixed nx, GLfixed ny, GLfixed nz);
+GL_API void GL_APIENTRY glOrthoxOES (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+GL_API void GL_APIENTRY glPointParameterxOES (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glPointParameterxvOES (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glPointSizexOES (GLfixed size);
+GL_API void GL_APIENTRY glPolygonOffsetxOES (GLfixed factor, GLfixed units);
+GL_API void GL_APIENTRY glRotatexOES (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+GL_API void GL_APIENTRY glSampleCoveragexOES (GLclampx value, GLboolean invert);
+GL_API void GL_APIENTRY glScalexOES (GLfixed x, GLfixed y, GLfixed z);
+GL_API void GL_APIENTRY glTexEnvxOES (GLenum target, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glTexEnvxvOES (GLenum target, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glTexParameterxOES (GLenum target, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glTexParameterxvOES (GLenum target, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glTranslatexOES (GLfixed x, GLfixed y, GLfixed z);
+#endif
+typedef void (GL_APIENTRYP PFNGLALPHAFUNCXOESPROC) (GLenum func, GLclampx ref);
+typedef void (GL_APIENTRYP PFNGLCLEARCOLORXOESPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+typedef void (GL_APIENTRYP PFNGLCLEARDEPTHXOESPROC) (GLclampx depth);
+typedef void (GL_APIENTRYP PFNGLCLIPPLANEXOESPROC) (GLenum plane, const GLfixed *equation);
+typedef void (GL_APIENTRYP PFNGLCOLOR4XOESPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+typedef void (GL_APIENTRYP PFNGLDEPTHRANGEXOESPROC) (GLclampx zNear, GLclampx zFar);
+typedef void (GL_APIENTRYP PFNGLFOGXOESPROC) (GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLFOGXVOESPROC) (GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLFRUSTUMXOESPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+typedef void (GL_APIENTRYP PFNGLGETCLIPPLANEXOESPROC) (GLenum pname, GLfixed eqn[4]);
+typedef void (GL_APIENTRYP PFNGLGETFIXEDVOESPROC) (GLenum pname, GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLGETLIGHTXVOESPROC) (GLenum light, GLenum pname, GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLGETMATERIALXVOESPROC) (GLenum face, GLenum pname, GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLGETTEXENVXVOESPROC) (GLenum env, GLenum pname, GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLGETTEXPARAMETERXVOESPROC) (GLenum target, GLenum pname, GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLLIGHTMODELXOESPROC) (GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLLIGHTMODELXVOESPROC) (GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLLIGHTXOESPROC) (GLenum light, GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLLIGHTXVOESPROC) (GLenum light, GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLLINEWIDTHXOESPROC) (GLfixed width);
+typedef void (GL_APIENTRYP PFNGLLOADMATRIXXOESPROC) (const GLfixed *m);
+typedef void (GL_APIENTRYP PFNGLMATERIALXOESPROC) (GLenum face, GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLMATERIALXVOESPROC) (GLenum face, GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLMULTMATRIXXOESPROC) (const GLfixed *m);
+typedef void (GL_APIENTRYP PFNGLMULTITEXCOORD4XOESPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+typedef void (GL_APIENTRYP PFNGLNORMAL3XOESPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
+typedef void (GL_APIENTRYP PFNGLORTHOXOESPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+typedef void (GL_APIENTRYP PFNGLPOINTPARAMETERXOESPROC) (GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLPOINTPARAMETERXVOESPROC) (GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLPOINTSIZEXOESPROC) (GLfixed size);
+typedef void (GL_APIENTRYP PFNGLPOLYGONOFFSETXOESPROC) (GLfixed factor, GLfixed units);
+typedef void (GL_APIENTRYP PFNGLROTATEXOESPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+typedef void (GL_APIENTRYP PFNGLSAMPLECOVERAGEXOESPROC) (GLclampx value, GLboolean invert);
+typedef void (GL_APIENTRYP PFNGLSCALEXOESPROC) (GLfixed x, GLfixed y, GLfixed z);
+typedef void (GL_APIENTRYP PFNGLTEXENVXOESPROC) (GLenum target, GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLTEXENVXVOESPROC) (GLenum target, GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLTEXPARAMETERXOESPROC) (GLenum target, GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLTEXPARAMETERXVOESPROC) (GLenum target, GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLTRANSLATEXOESPROC) (GLfixed x, GLfixed y, GLfixed z);
+#endif
+
+/* GL_OES_framebuffer_object */
+#ifndef GL_OES_framebuffer_object
+#define GL_OES_framebuffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API GLboolean GL_APIENTRY glIsRenderbufferOES (GLuint renderbuffer);
+GL_API void GL_APIENTRY glBindRenderbufferOES (GLenum target, GLuint renderbuffer);
+GL_API void GL_APIENTRY glDeleteRenderbuffersOES (GLsizei n, const GLuint* renderbuffers);
+GL_API void GL_APIENTRY glGenRenderbuffersOES (GLsizei n, GLuint* renderbuffers);
+GL_API void GL_APIENTRY glRenderbufferStorageOES (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+GL_API void GL_APIENTRY glGetRenderbufferParameterivOES (GLenum target, GLenum pname, GLint* params);
+GL_API GLboolean GL_APIENTRY glIsFramebufferOES (GLuint framebuffer);
+GL_API void GL_APIENTRY glBindFramebufferOES (GLenum target, GLuint framebuffer);
+GL_API void GL_APIENTRY glDeleteFramebuffersOES (GLsizei n, const GLuint* framebuffers);
+GL_API void GL_APIENTRY glGenFramebuffersOES (GLsizei n, GLuint* framebuffers);
+GL_API GLenum GL_APIENTRY glCheckFramebufferStatusOES (GLenum target);
+GL_API void GL_APIENTRY glFramebufferRenderbufferOES (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+GL_API void GL_APIENTRY glFramebufferTexture2DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+GL_API void GL_APIENTRY glGetFramebufferAttachmentParameterivOES (GLenum target, GLenum attachment, GLenum pname, GLint* params);
+GL_API void GL_APIENTRY glGenerateMipmapOES (GLenum target);
+#endif
+typedef GLboolean (GL_APIENTRYP PFNGLISRENDERBUFFEROESPROC) (GLuint renderbuffer);
+typedef void (GL_APIENTRYP PFNGLBINDRENDERBUFFEROESPROC) (GLenum target, GLuint renderbuffer);
+typedef void (GL_APIENTRYP PFNGLDELETERENDERBUFFERSOESPROC) (GLsizei n, const GLuint* renderbuffers);
+typedef void (GL_APIENTRYP PFNGLGENRENDERBUFFERSOESPROC) (GLsizei n, GLuint* renderbuffers);
+typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+typedef void (GL_APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVOESPROC) (GLenum target, GLenum pname, GLint* params);
+typedef GLboolean (GL_APIENTRYP PFNGLISFRAMEBUFFEROESPROC) (GLuint framebuffer);
+typedef void (GL_APIENTRYP PFNGLBINDFRAMEBUFFEROESPROC) (GLenum target, GLuint framebuffer);
+typedef void (GL_APIENTRYP PFNGLDELETEFRAMEBUFFERSOESPROC) (GLsizei n, const GLuint* framebuffers);
+typedef void (GL_APIENTRYP PFNGLGENFRAMEBUFFERSOESPROC) (GLsizei n, GLuint* framebuffers);
+typedef GLenum (GL_APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSOESPROC) (GLenum target);
+typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFEROESPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DOESPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+typedef void (GL_APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVOESPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
+typedef void (GL_APIENTRYP PFNGLGENERATEMIPMAPOESPROC) (GLenum target);
+#endif
+
+/* GL_OES_matrix_get */
+#ifndef GL_OES_matrix_get
+#define GL_OES_matrix_get 1
+#endif
+
+/* GL_OES_matrix_palette */
+#ifndef GL_OES_matrix_palette
+#define GL_OES_matrix_palette 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glCurrentPaletteMatrixOES (GLuint matrixpaletteindex);
+GL_API void GL_APIENTRY glLoadPaletteFromModelViewMatrixOES (void);
+GL_API void GL_APIENTRY glMatrixIndexPointerOES (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glWeightPointerOES (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+typedef void (GL_APIENTRYP PFNGLCURRENTPALETTEMATRIXOESPROC) (GLuint matrixpaletteindex);
+typedef void (GL_APIENTRYP PFNGLLOADPALETTEFROMMODELVIEWMATRIXOESPROC) (void);
+typedef void (GL_APIENTRYP PFNGLMATRIXINDEXPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (GL_APIENTRYP PFNGLWEIGHTPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+/* GL_OES_query_matrix */
+#ifndef GL_OES_query_matrix
+#define GL_OES_query_matrix 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API GLbitfield GL_APIENTRY glQueryMatrixxOES (GLfixed mantissa[16], GLint exponent[16]);
+#endif
+typedef GLbitfield (GL_APIENTRYP PFNGLQUERYMATRIXXOESPROC) (GLfixed mantissa[16], GLint exponent[16]);
+#endif
+
+/* GL_OES_single_precision */
+#ifndef GL_OES_single_precision
+#define GL_OES_single_precision 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glDepthRangefOES (GLclampf zNear, GLclampf zFar);
+GL_API void GL_APIENTRY glFrustumfOES (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+GL_API void GL_APIENTRY glOrthofOES (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+GL_API void GL_APIENTRY glClipPlanefOES (GLenum plane, const GLfloat *equation);
+GL_API void GL_APIENTRY glGetClipPlanefOES (GLenum pname, GLfloat eqn[4]);
+GL_API void GL_APIENTRY glClearDepthfOES (GLclampf depth);
+#endif
+typedef void (GL_APIENTRYP PFNGLDEPTHRANGEFOESPROC) (GLclampf zNear, GLclampf zFar);
+typedef void (GL_APIENTRYP PFNGLFRUSTUMFOESPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+typedef void (GL_APIENTRYP PFNGLORTHOFOESPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+typedef void (GL_APIENTRYP PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat *equation);
+typedef void (GL_APIENTRYP PFNGLGETCLIPPLANEFOESPROC) (GLenum pname, GLfloat eqn[4]);
+typedef void (GL_APIENTRYP PFNGLCLEARDEPTHFOESPROC) (GLclampf depth);
+#endif
+
+/* GL_OES_stencil_wrap */
+#ifndef GL_OES_stencil_wrap
+#define GL_OES_stencil_wrap 1
+#endif
+
+/* GL_OES_texture_cube_map */
+#ifndef GL_OES_texture_cube_map
+#define GL_OES_texture_cube_map 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glTexGenfOES (GLenum coord, GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glTexGenfvOES (GLenum coord, GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glTexGeniOES (GLenum coord, GLenum pname, GLint param);
+GL_API void GL_APIENTRY glTexGenivOES (GLenum coord, GLenum pname, const GLint *params);
+GL_API void GL_APIENTRY glTexGenxOES (GLenum coord, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glTexGenxvOES (GLenum coord, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glGetTexGenfvOES (GLenum coord, GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glGetTexGenivOES (GLenum coord, GLenum pname, GLint *params);
+GL_API void GL_APIENTRY glGetTexGenxvOES (GLenum coord, GLenum pname, GLfixed *params);
+#endif
+typedef void (GL_APIENTRYP PFNGLTEXGENFOESPROC) (GLenum coord, GLenum pname, GLfloat param);
+typedef void (GL_APIENTRYP PFNGLTEXGENFVOESPROC) (GLenum coord, GLenum pname, const GLfloat *params);
+typedef void (GL_APIENTRYP PFNGLTEXGENIOESPROC) (GLenum coord, GLenum pname, GLint param);
+typedef void (GL_APIENTRYP PFNGLTEXGENIVOESPROC) (GLenum coord, GLenum pname, const GLint *params);
+typedef void (GL_APIENTRYP PFNGLTEXGENXOESPROC) (GLenum coord, GLenum pname, GLfixed param);
+typedef void (GL_APIENTRYP PFNGLTEXGENXVOESPROC) (GLenum coord, GLenum pname, const GLfixed *params);
+typedef void (GL_APIENTRYP PFNGLGETTEXGENFVOESPROC) (GLenum coord, GLenum pname, GLfloat *params);
+typedef void (GL_APIENTRYP PFNGLGETTEXGENIVOESPROC) (GLenum coord, GLenum pname, GLint *params);
+typedef void (GL_APIENTRYP PFNGLGETTEXGENXVOESPROC) (GLenum coord, GLenum pname, GLfixed *params);
+#endif
+
+/* GL_OES_texture_env_crossbar */
+#ifndef GL_OES_texture_env_crossbar
+#define GL_OES_texture_env_crossbar 1
+#endif
+
+/* GL_OES_texture_mirrored_repeat */
+#ifndef GL_OES_texture_mirrored_repeat
+#define GL_OES_texture_mirrored_repeat 1
+#endif
+
+/* GL_OES_EGL_image */
+#ifndef GL_OES_EGL_image
+#define GL_OES_EGL_image 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glEGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image);
+GL_API void GL_APIENTRY glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image);
+#endif
+typedef void (GL_APIENTRYP PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) (GLenum target, GLeglImageOES image);
+typedef void (GL_APIENTRYP PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLeglImageOES image);
+#endif
+
+/* GL_OES_depth24 */
+#ifndef GL_OES_depth24
+#define GL_OES_depth24 1
+#endif
+
+/* GL_OES_depth32 */
+#ifndef GL_OES_depth32
+#define GL_OES_depth32 1
+#endif
+
+/* GL_OES_element_index_uint */
+#ifndef GL_OES_element_index_uint
+#define GL_OES_element_index_uint 1
+#endif
+
+/* GL_OES_fbo_render_mipmap */
+#ifndef GL_OES_fbo_render_mipmap
+#define GL_OES_fbo_render_mipmap 1
+#endif
+
+/* GL_OES_mapbuffer */
+#ifndef GL_OES_mapbuffer
+#define GL_OES_mapbuffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void* GL_APIENTRY glMapBufferOES (GLenum target, GLenum access);
+GL_API GLboolean GL_APIENTRY glUnmapBufferOES (GLenum target);
+GL_API void GL_APIENTRY glGetBufferPointervOES (GLenum target, GLenum pname, void** params);
+#endif
+typedef void* (GL_APIENTRYP PFNGLMAPBUFFEROESPROC) (GLenum target, GLenum access);
+typedef GLboolean (GL_APIENTRYP PFNGLUNMAPBUFFEROESPROC) (GLenum target);
+typedef void (GL_APIENTRYP PFNGLGETBUFFERPOINTERVOESPROC) (GLenum target, GLenum pname, void** params);
+#endif
+
+/* GL_OES_rgb8_rgba8 */
+#ifndef GL_OES_rgb8_rgba8
+#define GL_OES_rgb8_rgba8 1
+#endif
+
+/* GL_OES_stencil1 */
+#ifndef GL_OES_stencil1
+#define GL_OES_stencil1 1
+#endif
+
+/* GL_OES_stencil4 */
+#ifndef GL_OES_stencil4
+#define GL_OES_stencil4 1
+#endif
+
+/* GL_OES_stencil8 */
+#ifndef GL_OES_stencil8
+#define GL_OES_stencil8 1
+#endif
+
+/* GL_AMD_compressed_3DC_texture */
+#ifndef GL_AMD_compressed_3DC_texture
+#define GL_AMD_compressed_3DC_texture 1
+#endif
+
+/* GL_AMD_compressed_ATC_texture */
+#ifndef GL_AMD_compressed_ATC_texture
+#define GL_AMD_compressed_ATC_texture 1
+#endif
+
+/* GL_EXT_texture_filter_anisotropic */
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_EXT_texture_filter_anisotropic 1
+#endif
+
+/* GL_IMG_read_format */
+#ifndef GL_IMG_read_format
+#define GL_IMG_read_format 1
+#endif
+
+/* GL_IMG_texture_format_BGRA8888 */
+#ifndef GL_IMG_texture_format_BGRA8888
+#define GL_IMG_texture_format_BGRA8888 1
+#endif
+
+/* GL_IMG_texture_stream */
+#ifndef GL_IMG_texture_stream
+#define GL_IMG_texture_stream 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glTexBindStreamIMG(GLint device, GLint deviceoffset);
+GL_API void GL_APIENTRY glGetTexStreamDeviceAttributeivIMG(GLint device, GLenum pname, GLint *params);
+GL_API const GLubyte * GL_APIENTRY glGetTexStreamDeviceNameIMG(GLint device);
+#endif
+
+typedef void (GL_APIENTRYP PFNGLTEXBINDSTREAMIMGPROC) (GLint device, GLint deviceoffset);
+typedef const GLubyte *(GL_APIENTRYP PFNGLGETTEXSTREAMDEVICENAMEIMGPROC) (GLenum target);
+typedef void (GL_APIENTRYP PFNGLGETTEXSTREAMDEVICEATTRIBUTEIVIMGPROC) (GLenum target, GLenum pname, GLint *params);
+
+#endif
+
+/* GL_IMG_texture_compression_pvrtc */
+#ifndef GL_IMG_texture_compression_pvrtc
+#define GL_IMG_texture_compression_pvrtc 1
+#endif
+
+#ifndef GL_IMG_vertex_program
+#define GL_IMG_vertex_program 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_API void GL_APIENTRY glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_API void GL_APIENTRY glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_API void GL_APIENTRY glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
+GL_API void GL_APIENTRY glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_API void GL_APIENTRY glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
+GL_API void GL_APIENTRY glVertexAttrib4xIMG(GLuint index, GLfixed x, GLfixed y, GLfixed z, GLfixed w);
+GL_API void GL_APIENTRY glProgramLocalParameter4xIMG(GLenum target, GLuint index, GLfixed x, GLfixed y, GLfixed z, GLfixed w);
+GL_API void GL_APIENTRY glProgramLocalParameter4xvIMG(GLenum target, GLuint index, const GLfixed *params);
+GL_API void GL_APIENTRY glProgramEnvParameter4xIMG(GLenum target, GLuint index, GLfixed x, GLfixed y, GLfixed z, GLfixed w);
+GL_API void GL_APIENTRY glProgramEnvParameter4xvIMG(GLenum target, GLuint index, const GLfixed *params);
+GL_API void GL_APIENTRY glVertexAttribPointerARB(GLuint index, GLsizei size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glEnableVertexAttribArrayARB(GLuint index);
+GL_API void GL_APIENTRY glDisableVertexAttribArrayARB(GLuint index);
+GL_API void GL_APIENTRY glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void *string);
+GL_API void GL_APIENTRY glBindProgramARB(GLenum target, GLuint program);
+GL_API void GL_APIENTRY glDeleteProgramsARB(GLsizei n, const GLuint *programs);
+GL_API void GL_APIENTRY glGenProgramsARB(GLsizei n, GLuint *programs);
+#endif
+#endif
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __glext_h_ */
+
diff -pruN libsdl-1.2/include/SDL_opengles.h libsdl-1.2-palm/include/SDL_opengles.h
--- libsdl-1.2/include/SDL_opengles.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_opengles.h	2009-07-13 11:28:45.000000000 -0700
@@ -0,0 +1,1126 @@
+#ifndef __SDLgles_h_
+#define __SDLgles_h_
+
+/* $Revision: 7172 $ on $Date:: 2009-01-09 11:17:41 -0800 #$ */
+
+//#include <GLES/glplatform.h>
+#define GL_APIENTRY
+#define GL_API 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This document is licensed under the SGI Free Software B License Version
+ * 2.0. For details, see http://oss.sgi.com/projects/FreeB/ .
+ */
+
+typedef void             GLvoid;
+typedef unsigned int     GLenum;
+typedef unsigned char    GLboolean;
+typedef unsigned int     GLbitfield;
+typedef signed char      GLbyte;
+typedef short            GLshort;
+typedef int              GLint;
+typedef int              GLsizei;
+typedef unsigned char    GLubyte;
+typedef unsigned short   GLushort;
+typedef unsigned int     GLuint;
+typedef float            GLfloat;
+typedef float            GLclampf;
+typedef int              GLfixed;
+typedef int              GLclampx;
+
+typedef int              GLintptr;
+typedef int              GLsizeiptr;
+
+
+/*************************************************************/
+
+/* OpenGL ES core versions */
+#define GL_VERSION_ES_CM_1_0          1
+#define GL_VERSION_ES_CL_1_0          1
+#define GL_VERSION_ES_CM_1_1          1
+#define GL_VERSION_ES_CL_1_1          1
+#define GL_ES_VERSION_2_0             1
+
+/* ClearBufferMask */
+#define GL_DEPTH_BUFFER_BIT               0x00000100
+#define GL_STENCIL_BUFFER_BIT             0x00000400
+#define GL_COLOR_BUFFER_BIT               0x00004000
+
+/* Boolean */
+#define GL_FALSE                          0
+#define GL_TRUE                           1
+
+/* BeginMode */
+#define GL_POINTS                         0x0000
+#define GL_LINES                          0x0001
+#define GL_LINE_LOOP                      0x0002
+#define GL_LINE_STRIP                     0x0003
+#define GL_TRIANGLES                      0x0004
+#define GL_TRIANGLE_STRIP                 0x0005
+#define GL_TRIANGLE_FAN                   0x0006
+
+/* AlphaFunction */
+#define GL_NEVER                          0x0200
+#define GL_LESS                           0x0201
+#define GL_EQUAL                          0x0202
+#define GL_LEQUAL                         0x0203
+#define GL_GREATER                        0x0204
+#define GL_NOTEQUAL                       0x0205
+#define GL_GEQUAL                         0x0206
+#define GL_ALWAYS                         0x0207
+
+/* BlendingFactorDest */
+#define GL_ZERO                           0
+#define GL_ONE                            1
+#define GL_SRC_COLOR                      0x0300
+#define GL_ONE_MINUS_SRC_COLOR            0x0301
+#define GL_SRC_ALPHA                      0x0302
+#define GL_ONE_MINUS_SRC_ALPHA            0x0303
+#define GL_DST_ALPHA                      0x0304
+#define GL_ONE_MINUS_DST_ALPHA            0x0305
+
+/* BlendingFactorSrc */
+/*      GL_ZERO */
+/*      GL_ONE */
+#define GL_DST_COLOR                      0x0306
+#define GL_ONE_MINUS_DST_COLOR            0x0307
+#define GL_SRC_ALPHA_SATURATE             0x0308
+/*      GL_SRC_ALPHA */
+/*      GL_ONE_MINUS_SRC_ALPHA */
+/*      GL_DST_ALPHA */
+/*      GL_ONE_MINUS_DST_ALPHA */
+
+/* ClipPlaneName */
+#define GL_CLIP_PLANE0                    0x3000
+#define GL_CLIP_PLANE1                    0x3001
+#define GL_CLIP_PLANE2                    0x3002
+#define GL_CLIP_PLANE3                    0x3003
+#define GL_CLIP_PLANE4                    0x3004
+#define GL_CLIP_PLANE5                    0x3005
+
+/* ColorMaterialFace */
+/*      GL_FRONT_AND_BACK */
+
+/* ColorMaterialParameter */
+/*      GL_AMBIENT_AND_DIFFUSE */
+
+/* ColorPointerType */
+/*      GL_UNSIGNED_BYTE */
+/*      GL_FLOAT */
+/*      GL_FIXED */
+
+/* CullFaceMode */
+#define GL_FRONT                          0x0404
+#define GL_BACK                           0x0405
+#define GL_FRONT_AND_BACK                 0x0408
+
+/* DepthFunction */
+/*      GL_NEVER */
+/*      GL_LESS */
+/*      GL_EQUAL */
+/*      GL_LEQUAL */
+/*      GL_GREATER */
+/*      GL_NOTEQUAL */
+/*      GL_GEQUAL */
+/*      GL_ALWAYS */
+
+/* EnableCap */
+#define GL_FOG                            0x0B60
+#define GL_LIGHTING                       0x0B50
+#define GL_TEXTURE_2D                     0x0DE1
+#define GL_CULL_FACE                      0x0B44
+#define GL_ALPHA_TEST                     0x0BC0
+#define GL_BLEND                          0x0BE2
+#define GL_COLOR_LOGIC_OP                 0x0BF2
+#define GL_DITHER                         0x0BD0
+#define GL_STENCIL_TEST                   0x0B90
+#define GL_DEPTH_TEST                     0x0B71
+/*      GL_LIGHT0 */
+/*      GL_LIGHT1 */
+/*      GL_LIGHT2 */
+/*      GL_LIGHT3 */
+/*      GL_LIGHT4 */
+/*      GL_LIGHT5 */
+/*      GL_LIGHT6 */
+/*      GL_LIGHT7 */
+#define GL_POINT_SMOOTH                   0x0B10
+#define GL_LINE_SMOOTH                    0x0B20
+#define GL_SCISSOR_TEST                   0x0C11
+#define GL_COLOR_MATERIAL                 0x0B57
+#define GL_NORMALIZE                      0x0BA1
+#define GL_RESCALE_NORMAL                 0x803A
+#define GL_POLYGON_OFFSET_FILL            0x8037
+#define GL_VERTEX_ARRAY                   0x8074
+#define GL_NORMAL_ARRAY                   0x8075
+#define GL_COLOR_ARRAY                    0x8076
+#define GL_TEXTURE_COORD_ARRAY            0x8078
+#define GL_MULTISAMPLE                    0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
+#define GL_SAMPLE_COVERAGE                0x80A0
+
+/* ErrorCode */
+#define GL_NO_ERROR                       0
+#define GL_INVALID_ENUM                   0x0500
+#define GL_INVALID_VALUE                  0x0501
+#define GL_INVALID_OPERATION              0x0502
+#define GL_STACK_OVERFLOW                 0x0503
+#define GL_STACK_UNDERFLOW                0x0504
+#define GL_OUT_OF_MEMORY                  0x0505
+
+/* FogMode */
+/*      GL_LINEAR */
+#define GL_EXP                            0x0800
+#define GL_EXP2                           0x0801
+
+/* FogParameter */
+#define GL_FOG_DENSITY                    0x0B62
+#define GL_FOG_START                      0x0B63
+#define GL_FOG_END                        0x0B64
+#define GL_FOG_MODE                       0x0B65
+#define GL_FOG_COLOR                      0x0B66
+
+/* FrontFaceDirection */
+#define GL_CW                             0x0900
+#define GL_CCW                            0x0901
+
+/* GetPName */
+#define GL_CURRENT_COLOR                  0x0B00
+#define GL_CURRENT_NORMAL                 0x0B02
+#define GL_CURRENT_TEXTURE_COORDS         0x0B03
+#define GL_POINT_SIZE                     0x0B11
+#define GL_POINT_SIZE_MIN                 0x8126
+#define GL_POINT_SIZE_MAX                 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
+#define GL_POINT_DISTANCE_ATTENUATION     0x8129
+#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
+#define GL_LINE_WIDTH                     0x0B21
+#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
+#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
+#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
+#define GL_CULL_FACE_MODE                 0x0B45
+#define GL_FRONT_FACE                     0x0B46
+#define GL_SHADE_MODEL                    0x0B54
+#define GL_DEPTH_RANGE                    0x0B70
+#define GL_DEPTH_WRITEMASK                0x0B72
+#define GL_DEPTH_CLEAR_VALUE              0x0B73
+#define GL_DEPTH_FUNC                     0x0B74
+#define GL_STENCIL_CLEAR_VALUE            0x0B91
+#define GL_STENCIL_FUNC                   0x0B92
+#define GL_STENCIL_VALUE_MASK             0x0B93
+#define GL_STENCIL_FAIL                   0x0B94
+#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
+#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
+#define GL_STENCIL_REF                    0x0B97
+#define GL_STENCIL_WRITEMASK              0x0B98
+#define GL_MATRIX_MODE                    0x0BA0
+#define GL_VIEWPORT                       0x0BA2
+#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
+#define GL_PROJECTION_STACK_DEPTH         0x0BA4
+#define GL_TEXTURE_STACK_DEPTH            0x0BA5
+#define GL_MODELVIEW_MATRIX               0x0BA6
+#define GL_PROJECTION_MATRIX              0x0BA7
+#define GL_TEXTURE_MATRIX                 0x0BA8
+#define GL_ALPHA_TEST_FUNC                0x0BC1
+#define GL_ALPHA_TEST_REF                 0x0BC2
+#define GL_BLEND_DST                      0x0BE0
+#define GL_BLEND_SRC                      0x0BE1
+#define GL_LOGIC_OP_MODE                  0x0BF0
+#define GL_SCISSOR_BOX                    0x0C10
+#define GL_SCISSOR_TEST                   0x0C11
+#define GL_COLOR_CLEAR_VALUE              0x0C22
+#define GL_COLOR_WRITEMASK                0x0C23
+#define GL_UNPACK_ALIGNMENT               0x0CF5
+#define GL_PACK_ALIGNMENT                 0x0D05
+#define GL_MAX_LIGHTS                     0x0D31
+#define GL_MAX_CLIP_PLANES                0x0D32
+#define GL_MAX_TEXTURE_SIZE               0x0D33
+#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
+#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
+#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
+#define GL_MAX_VIEWPORT_DIMS              0x0D3A
+#define GL_MAX_TEXTURE_UNITS              0x84E2
+#define GL_SUBPIXEL_BITS                  0x0D50
+#define GL_RED_BITS                       0x0D52
+#define GL_GREEN_BITS                     0x0D53
+#define GL_BLUE_BITS                      0x0D54
+#define GL_ALPHA_BITS                     0x0D55
+#define GL_DEPTH_BITS                     0x0D56
+#define GL_STENCIL_BITS                   0x0D57
+#define GL_POLYGON_OFFSET_UNITS           0x2A00
+#define GL_POLYGON_OFFSET_FILL            0x8037
+#define GL_POLYGON_OFFSET_FACTOR          0x8038
+#define GL_TEXTURE_BINDING_2D             0x8069
+#define GL_VERTEX_ARRAY_SIZE              0x807A
+#define GL_VERTEX_ARRAY_TYPE              0x807B
+#define GL_VERTEX_ARRAY_STRIDE            0x807C
+#define GL_NORMAL_ARRAY_TYPE              0x807E
+#define GL_NORMAL_ARRAY_STRIDE            0x807F
+#define GL_COLOR_ARRAY_SIZE               0x8081
+#define GL_COLOR_ARRAY_TYPE               0x8082
+#define GL_COLOR_ARRAY_STRIDE             0x8083
+#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
+#define GL_VERTEX_ARRAY_POINTER           0x808E
+#define GL_NORMAL_ARRAY_POINTER           0x808F
+#define GL_COLOR_ARRAY_POINTER            0x8090
+#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
+#define GL_SAMPLE_BUFFERS                 0x80A8
+#define GL_SAMPLES                        0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
+
+/* GetTextureParameter */
+/*      GL_TEXTURE_MAG_FILTER */
+/*      GL_TEXTURE_MIN_FILTER */
+/*      GL_TEXTURE_WRAP_S */
+/*      GL_TEXTURE_WRAP_T */
+
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
+
+/* HintMode */
+#define GL_DONT_CARE                      0x1100
+#define GL_FASTEST                        0x1101
+#define GL_NICEST                         0x1102
+
+/* HintTarget */
+#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
+#define GL_POINT_SMOOTH_HINT              0x0C51
+#define GL_LINE_SMOOTH_HINT               0x0C52
+#define GL_FOG_HINT                       0x0C54
+#define GL_GENERATE_MIPMAP_HINT           0x8192
+
+/* LightModelParameter */
+#define GL_LIGHT_MODEL_AMBIENT            0x0B53
+#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
+
+/* LightParameter */
+#define GL_AMBIENT                        0x1200
+#define GL_DIFFUSE                        0x1201
+#define GL_SPECULAR                       0x1202
+#define GL_POSITION                       0x1203
+#define GL_SPOT_DIRECTION                 0x1204
+#define GL_SPOT_EXPONENT                  0x1205
+#define GL_SPOT_CUTOFF                    0x1206
+#define GL_CONSTANT_ATTENUATION           0x1207
+#define GL_LINEAR_ATTENUATION             0x1208
+#define GL_QUADRATIC_ATTENUATION          0x1209
+
+/* DataType */
+#define GL_BYTE                           0x1400
+#define GL_UNSIGNED_BYTE                  0x1401
+#define GL_SHORT                          0x1402
+#define GL_UNSIGNED_SHORT                 0x1403
+#define GL_FLOAT                          0x1406
+#define GL_FIXED                          0x140C
+
+/* LogicOp */
+#define GL_CLEAR                          0x1500
+#define GL_AND                            0x1501
+#define GL_AND_REVERSE                    0x1502
+#define GL_COPY                           0x1503
+#define GL_AND_INVERTED                   0x1504
+#define GL_NOOP                           0x1505
+#define GL_XOR                            0x1506
+#define GL_OR                             0x1507
+#define GL_NOR                            0x1508
+#define GL_EQUIV                          0x1509
+#define GL_INVERT                         0x150A
+#define GL_OR_REVERSE                     0x150B
+#define GL_COPY_INVERTED                  0x150C
+#define GL_OR_INVERTED                    0x150D
+#define GL_NAND                           0x150E
+#define GL_SET                            0x150F
+
+/* MaterialFace */
+/*      GL_FRONT_AND_BACK */
+
+/* MaterialParameter */
+#define GL_EMISSION                       0x1600
+#define GL_SHININESS                      0x1601
+#define GL_AMBIENT_AND_DIFFUSE            0x1602
+/*      GL_AMBIENT */
+/*      GL_DIFFUSE */
+/*      GL_SPECULAR */
+
+/* MatrixMode */
+#define GL_MODELVIEW                      0x1700
+#define GL_PROJECTION                     0x1701
+#define GL_TEXTURE                        0x1702
+
+/* NormalPointerType */
+/*      GL_BYTE */
+/*      GL_SHORT */
+/*      GL_FLOAT */
+/*      GL_FIXED */
+
+/* PixelFormat */
+#define GL_ALPHA                          0x1906
+#define GL_RGB                            0x1907
+#define GL_RGBA                           0x1908
+#define GL_LUMINANCE                      0x1909
+#define GL_LUMINANCE_ALPHA                0x190A
+
+/* PixelStoreParameter */
+#define GL_UNPACK_ALIGNMENT               0x0CF5
+#define GL_PACK_ALIGNMENT                 0x0D05
+
+/* PixelType */
+/*      GL_UNSIGNED_BYTE */
+#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
+#define GL_UNSIGNED_SHORT_5_6_5           0x8363
+
+/* ShadingModel */
+#define GL_FLAT                           0x1D00
+#define GL_SMOOTH                         0x1D01
+
+/* StencilFunction */
+/*      GL_NEVER */
+/*      GL_LESS */
+/*      GL_EQUAL */
+/*      GL_LEQUAL */
+/*      GL_GREATER */
+/*      GL_NOTEQUAL */
+/*      GL_GEQUAL */
+/*      GL_ALWAYS */
+
+/* StencilOp */
+/*      GL_ZERO */
+#define GL_KEEP                           0x1E00
+#define GL_REPLACE                        0x1E01
+#define GL_INCR                           0x1E02
+#define GL_DECR                           0x1E03
+/*      GL_INVERT */
+
+/* StringName */
+#define GL_VENDOR                         0x1F00
+#define GL_RENDERER                       0x1F01
+#define GL_VERSION                        0x1F02
+#define GL_EXTENSIONS                     0x1F03
+
+/* TexCoordPointerType */
+/*      GL_SHORT */
+/*      GL_FLOAT */
+/*      GL_FIXED */
+/*      GL_BYTE */
+
+/* TextureEnvMode */
+#define GL_MODULATE                       0x2100
+#define GL_DECAL                          0x2101
+/*      GL_BLEND */
+#define GL_ADD                            0x0104
+/*      GL_REPLACE */
+
+/* TextureEnvParameter */
+#define GL_TEXTURE_ENV_MODE               0x2200
+#define GL_TEXTURE_ENV_COLOR              0x2201
+
+/* TextureEnvTarget */
+#define GL_TEXTURE_ENV                    0x2300
+
+/* TextureMagFilter */
+#define GL_NEAREST                        0x2600
+#define GL_LINEAR                         0x2601
+
+/* TextureMinFilter */
+/*      GL_NEAREST */
+/*      GL_LINEAR */
+#define GL_NEAREST_MIPMAP_NEAREST         0x2700
+#define GL_LINEAR_MIPMAP_NEAREST          0x2701
+#define GL_NEAREST_MIPMAP_LINEAR          0x2702
+#define GL_LINEAR_MIPMAP_LINEAR           0x2703
+
+/* TextureParameterName */
+#define GL_TEXTURE_MAG_FILTER             0x2800
+#define GL_TEXTURE_MIN_FILTER             0x2801
+#define GL_TEXTURE_WRAP_S                 0x2802
+#define GL_TEXTURE_WRAP_T                 0x2803
+#define GL_GENERATE_MIPMAP                0x8191
+
+/* TextureTarget */
+/*      GL_TEXTURE_2D */
+
+/* TextureUnit */
+#define GL_TEXTURE0                       0x84C0
+#define GL_TEXTURE1                       0x84C1
+#define GL_TEXTURE2                       0x84C2
+#define GL_TEXTURE3                       0x84C3
+#define GL_TEXTURE4                       0x84C4
+#define GL_TEXTURE5                       0x84C5
+#define GL_TEXTURE6                       0x84C6
+#define GL_TEXTURE7                       0x84C7
+#define GL_TEXTURE8                       0x84C8
+#define GL_TEXTURE9                       0x84C9
+#define GL_TEXTURE10                      0x84CA
+#define GL_TEXTURE11                      0x84CB
+#define GL_TEXTURE12                      0x84CC
+#define GL_TEXTURE13                      0x84CD
+#define GL_TEXTURE14                      0x84CE
+#define GL_TEXTURE15                      0x84CF
+#define GL_TEXTURE16                      0x84D0
+#define GL_TEXTURE17                      0x84D1
+#define GL_TEXTURE18                      0x84D2
+#define GL_TEXTURE19                      0x84D3
+#define GL_TEXTURE20                      0x84D4
+#define GL_TEXTURE21                      0x84D5
+#define GL_TEXTURE22                      0x84D6
+#define GL_TEXTURE23                      0x84D7
+#define GL_TEXTURE24                      0x84D8
+#define GL_TEXTURE25                      0x84D9
+#define GL_TEXTURE26                      0x84DA
+#define GL_TEXTURE27                      0x84DB
+#define GL_TEXTURE28                      0x84DC
+#define GL_TEXTURE29                      0x84DD
+#define GL_TEXTURE30                      0x84DE
+#define GL_TEXTURE31                      0x84DF
+#define GL_ACTIVE_TEXTURE                 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE          0x84E1
+
+/* TextureWrapMode */
+#define GL_REPEAT                         0x2901
+#define GL_CLAMP_TO_EDGE                  0x812F
+
+/* VertexPointerType */
+/*      GL_SHORT */
+/*      GL_FLOAT */
+/*      GL_FIXED */
+/*      GL_BYTE */
+
+/* LightName */
+#define GL_LIGHT0                         0x4000
+#define GL_LIGHT1                         0x4001
+#define GL_LIGHT2                         0x4002
+#define GL_LIGHT3                         0x4003
+#define GL_LIGHT4                         0x4004
+#define GL_LIGHT5                         0x4005
+#define GL_LIGHT6                         0x4006
+#define GL_LIGHT7                         0x4007
+
+/* Buffer Objects */
+#define GL_ARRAY_BUFFER                   0x8892
+#define GL_ELEMENT_ARRAY_BUFFER           0x8893
+
+#define GL_ARRAY_BUFFER_BINDING               0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING       0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING        0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING        0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING         0x8898
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+
+#define GL_STATIC_DRAW                    0x88E4
+#define GL_DYNAMIC_DRAW                   0x88E8
+
+#define GL_BUFFER_SIZE                    0x8764
+#define GL_BUFFER_USAGE                   0x8765
+
+/* Texture combine + dot3 */
+#define GL_SUBTRACT                       0x84E7
+#define GL_COMBINE                        0x8570
+#define GL_COMBINE_RGB                    0x8571
+#define GL_COMBINE_ALPHA                  0x8572
+#define GL_RGB_SCALE                      0x8573
+#define GL_ADD_SIGNED                     0x8574
+#define GL_INTERPOLATE                    0x8575
+#define GL_CONSTANT                       0x8576
+#define GL_PRIMARY_COLOR                  0x8577
+#define GL_PREVIOUS                       0x8578
+#define GL_OPERAND0_RGB                   0x8590
+#define GL_OPERAND1_RGB                   0x8591
+#define GL_OPERAND2_RGB                   0x8592
+#define GL_OPERAND0_ALPHA                 0x8598
+#define GL_OPERAND1_ALPHA                 0x8599
+#define GL_OPERAND2_ALPHA                 0x859A
+
+#define GL_ALPHA_SCALE                    0x0D1C
+
+#define GL_SRC0_RGB                       0x8580
+#define GL_SRC1_RGB                       0x8581
+#define GL_SRC2_RGB                       0x8582
+#define GL_SRC0_ALPHA                     0x8588
+#define GL_SRC1_ALPHA                     0x8589
+#define GL_SRC2_ALPHA                     0x858A
+
+#define GL_DOT3_RGB                       0x86AE
+#define GL_DOT3_RGBA                      0x86AF
+
+/*------------------------------------------------------------------------*
+ * required OES extension tokens
+ *------------------------------------------------------------------------*/
+
+/* OES_read_format */
+#ifndef GL_OES_read_format
+#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES                   0x8B9A
+#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES                 0x8B9B
+#endif
+
+/* GL_OES_compressed_paletted_texture */
+#ifndef GL_OES_compressed_paletted_texture
+#define GL_PALETTE4_RGB8_OES                                    0x8B90
+#define GL_PALETTE4_RGBA8_OES                                   0x8B91
+#define GL_PALETTE4_R5_G6_B5_OES                                0x8B92
+#define GL_PALETTE4_RGBA4_OES                                   0x8B93
+#define GL_PALETTE4_RGB5_A1_OES                                 0x8B94
+#define GL_PALETTE8_RGB8_OES                                    0x8B95
+#define GL_PALETTE8_RGBA8_OES                                   0x8B96
+#define GL_PALETTE8_R5_G6_B5_OES                                0x8B97
+#define GL_PALETTE8_RGBA4_OES                                   0x8B98
+#define GL_PALETTE8_RGB5_A1_OES                                 0x8B99
+#endif
+
+/* OES_point_size_array */
+#ifndef GL_OES_point_size_array
+#define GL_POINT_SIZE_ARRAY_OES                                 0x8B9C
+#define GL_POINT_SIZE_ARRAY_TYPE_OES                            0x898A
+#define GL_POINT_SIZE_ARRAY_STRIDE_OES                          0x898B
+#define GL_POINT_SIZE_ARRAY_POINTER_OES                         0x898C
+#define GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES                  0x8B9F
+#endif
+
+/* GL_OES_point_sprite */
+#ifndef GL_OES_point_sprite
+#define GL_POINT_SPRITE_OES                                     0x8861
+#define GL_COORD_REPLACE_OES                                    0x8862
+#endif
+
+
+/*************************************************************/
+
+/*  GL-ES 2.0 specific defines */
+#if GL_ES_VERSION_2_0
+/* BlendEquationSeparate */
+#define GL_FUNC_ADD                       0x8006
+#define GL_BLEND_EQUATION                 0x8009
+#define GL_BLEND_EQUATION_RGB             0x8009    /* same as BLEND_EQUATION */
+#define GL_BLEND_EQUATION_ALPHA           0x883D
+
+/* BlendSubtract */
+#define GL_FUNC_SUBTRACT                  0x800A
+#define GL_FUNC_REVERSE_SUBTRACT          0x800B
+
+/* Separate Blend Functions */
+#define GL_BLEND_DST_RGB                  0x80C8
+#define GL_BLEND_SRC_RGB                  0x80C9
+#define GL_BLEND_DST_ALPHA                0x80CA
+#define GL_BLEND_SRC_ALPHA                0x80CB
+#define GL_CONSTANT_COLOR                 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
+#define GL_CONSTANT_ALPHA                 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
+#define GL_BLEND_COLOR                    0x8005
+
+/* Buffer Objects */
+#define GL_ARRAY_BUFFER                   0x8892
+#define GL_ELEMENT_ARRAY_BUFFER           0x8893
+#define GL_ARRAY_BUFFER_BINDING           0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
+
+#define GL_STREAM_DRAW                    0x88E0
+#define GL_STATIC_DRAW                    0x88E4
+#define GL_DYNAMIC_DRAW                   0x88E8
+
+#define GL_BUFFER_SIZE                    0x8764
+#define GL_BUFFER_USAGE                   0x8765
+
+#define GL_CURRENT_VERTEX_ATTRIB          0x8626
+
+/* GetPName */
+#define GL_STENCIL_BACK_FUNC              0x8800
+#define GL_STENCIL_BACK_FAIL              0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
+#define GL_STENCIL_BACK_REF               0x8CA3
+#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
+#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
+
+/* Defines data types */
+#define GL_INT                            0x1404
+#define GL_UNSIGNED_INT                   0x1405
+
+/* Pixel Format */
+#define GL_DEPTH_COMPONENT                0x1902
+
+/* Shaders */
+#define GL_FRAGMENT_SHADER                  0x8B30
+#define GL_VERTEX_SHADER                    0x8B31
+#define GL_MAX_VERTEX_ATTRIBS               0x8869
+#define GL_MAX_VERTEX_UNIFORM_VECTORS       0x8DFB
+#define GL_MAX_VARYING_VECTORS              0x8DFC
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS   0x8B4C
+#define GL_MAX_TEXTURE_IMAGE_UNITS          0x8872
+#define GL_MAX_FRAGMENT_UNIFORM_VECTORS     0x8DFD
+#define GL_SHADER_TYPE                      0x8B4F
+#define GL_DELETE_STATUS                    0x8B80
+#define GL_LINK_STATUS                      0x8B82
+#define GL_VALIDATE_STATUS                  0x8B83
+#define GL_ATTACHED_SHADERS                 0x8B85
+#define GL_ACTIVE_UNIFORMS                  0x8B86
+#define GL_ACTIVE_UNIFORM_MAX_LENGTH        0x8B87
+#define GL_ACTIVE_ATTRIBUTES                0x8B89
+#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH      0x8B8A
+#define GL_SHADING_LANGUAGE_VERSION         0x8B8C
+#define GL_CURRENT_PROGRAM                  0x8B8D
+
+/* StencilFunction */
+#define GL_NEVER                          0x0200
+#define GL_LESS                           0x0201
+#define GL_EQUAL                          0x0202
+#define GL_LEQUAL                         0x0203
+#define GL_GREATER                        0x0204
+#define GL_NOTEQUAL                       0x0205
+#define GL_GEQUAL                         0x0206
+#define GL_ALWAYS                         0x0207
+
+/* StencilOp */
+#define GL_INVERT                         0x150A
+#define GL_INCR_WRAP                      0x8507
+#define GL_DECR_WRAP                      0x8508
+
+/* TextureTarget */
+#define GL_TEXTURE_CUBE_MAP               0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
+
+/* TextureWrapMode */
+#define GL_MIRRORED_REPEAT                0x8370
+
+/* Uniform Types */
+#define GL_FLOAT_VEC2                     0x8B50
+#define GL_FLOAT_VEC3                     0x8B51
+#define GL_FLOAT_VEC4                     0x8B52
+#define GL_INT_VEC2                       0x8B53
+#define GL_INT_VEC3                       0x8B54
+#define GL_INT_VEC4                       0x8B55
+#define GL_BOOL                           0x8B56
+#define GL_BOOL_VEC2                      0x8B57
+#define GL_BOOL_VEC3                      0x8B58
+#define GL_BOOL_VEC4                      0x8B59
+#define GL_FLOAT_MAT2                     0x8B5A
+#define GL_FLOAT_MAT3                     0x8B5B
+#define GL_FLOAT_MAT4                     0x8B5C
+#define GL_SAMPLER_2D                     0x8B5E
+#define GL_SAMPLER_CUBE                   0x8B60
+
+/* Vertex Arrays */
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED        0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE           0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE         0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE           0x8625
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     0x886A
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER        0x8645
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+
+/* Read Format */
+#define GL_IMPLEMENTATION_COLOR_READ_TYPE   0x8B9A
+#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
+
+/* Shader Source */
+#define GL_COMPILE_STATUS                 0x8B81
+#define GL_INFO_LOG_LENGTH                0x8B84
+#define GL_SHADER_SOURCE_LENGTH           0x8B88
+#define GL_SHADER_COMPILER                0x8DFA
+
+/* Shader Binary */
+#define GL_SHADER_BINARY_FORMATS          0x8DF8
+#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
+
+/* Shader Precision-Specified Types */
+#define GL_LOW_FLOAT                      0x8DF0
+#define GL_MEDIUM_FLOAT                   0x8DF1
+#define GL_HIGH_FLOAT                     0x8DF2
+#define GL_LOW_INT                        0x8DF3
+#define GL_MEDIUM_INT                     0x8DF4
+#define GL_HIGH_INT                       0x8DF5
+
+/* Framebuffer Object. */
+#define GL_FRAMEBUFFER                    0x8D40
+#define GL_RENDERBUFFER                   0x8D41
+
+#define GL_RGBA4                          0x8056
+#define GL_RGB5_A1                        0x8057
+#define GL_RGB565                         0x8D62
+#define GL_DEPTH_COMPONENT16              0x81A5
+#define GL_STENCIL_INDEX                  0x1901
+#define GL_STENCIL_INDEX8                 0x8D48
+
+#define GL_RENDERBUFFER_WIDTH             0x8D42
+#define GL_RENDERBUFFER_HEIGHT            0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
+#define GL_RENDERBUFFER_RED_SIZE          0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
+
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
+
+#define GL_COLOR_ATTACHMENT0              0x8CE0
+#define GL_DEPTH_ATTACHMENT               0x8D00
+#define GL_STENCIL_ATTACHMENT             0x8D20
+
+#define GL_NONE                           0
+
+#define GL_FRAMEBUFFER_COMPLETE                      0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT         0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS         0x8CD9
+#define GL_FRAMEBUFFER_UNSUPPORTED                   0x8CDD
+
+#define GL_FRAMEBUFFER_BINDING            0x8CA6
+#define GL_RENDERBUFFER_BINDING           0x8CA7
+#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
+
+#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
+
+#endif
+
+
+
+/*************************************************************/
+
+/* Available only in Common profile */
+GL_API void GL_APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
+GL_API void GL_APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+GL_API void GL_APIENTRY glClearDepthf (GLclampf depth);
+GL_API void GL_APIENTRY glClipPlanef (GLenum plane, const GLfloat *equation);
+GL_API void GL_APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+GL_API void GL_APIENTRY glDepthRangef (GLclampf zNear, GLclampf zFar);
+GL_API void GL_APIENTRY glFogf (GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glFogfv (GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+GL_API void GL_APIENTRY glGetClipPlanef (GLenum pname, GLfloat eqn[4]);
+GL_API void GL_APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glGetTexEnvfv (GLenum env, GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
+GL_API void GL_APIENTRY glLightModelf (GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glLineWidth (GLfloat width);
+GL_API void GL_APIENTRY glLoadMatrixf (const GLfloat *m);
+GL_API void GL_APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glMultMatrixf (const GLfloat *m);
+GL_API void GL_APIENTRY glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+GL_API void GL_APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
+GL_API void GL_APIENTRY glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+GL_API void GL_APIENTRY glPointParameterf (GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glPointParameterfv (GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glPointSize (GLfloat size);
+GL_API void GL_APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
+GL_API void GL_APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+GL_API void GL_APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
+GL_API void GL_APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
+GL_API void GL_APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
+GL_API void GL_APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
+
+/* Available in both Common and Common-Lite profiles */
+GL_API void GL_APIENTRY glActiveTexture (GLenum texture);
+GL_API void GL_APIENTRY glAlphaFuncx (GLenum func, GLclampx ref);
+GL_API void GL_APIENTRY glBindBuffer (GLenum target, GLuint buffer);
+GL_API void GL_APIENTRY glBindTexture (GLenum target, GLuint texture);
+GL_API void GL_APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
+GL_API void GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+GL_API void GL_APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+GL_API void GL_APIENTRY glClear (GLbitfield mask);
+GL_API void GL_APIENTRY glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+GL_API void GL_APIENTRY glClearDepthx (GLclampx depth);
+GL_API void GL_APIENTRY glClearStencil (GLint s);
+GL_API void GL_APIENTRY glClientActiveTexture (GLenum texture);
+GL_API void GL_APIENTRY glClipPlanex (GLenum plane, const GLfixed *equation);
+GL_API void GL_APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+GL_API void GL_APIENTRY glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+GL_API void GL_APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+GL_API void GL_APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+GL_API void GL_APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+GL_API void GL_APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+GL_API void GL_APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+GL_API void GL_APIENTRY glCullFace (GLenum mode);
+GL_API void GL_APIENTRY glDeleteBuffers (GLsizei n, const GLuint *buffers);
+GL_API void GL_APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
+GL_API void GL_APIENTRY glDepthFunc (GLenum func);
+GL_API void GL_APIENTRY glDepthMask (GLboolean flag);
+GL_API void GL_APIENTRY glDepthRangex (GLclampx zNear, GLclampx zFar);
+GL_API void GL_APIENTRY glDisable (GLenum cap);
+GL_API void GL_APIENTRY glDisableClientState (GLenum array);
+GL_API void GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
+GL_API void GL_APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+GL_API void GL_APIENTRY glEnable (GLenum cap);
+GL_API void GL_APIENTRY glEnableClientState (GLenum array);
+GL_API void GL_APIENTRY glFinish (void);
+GL_API void GL_APIENTRY glFlush (void);
+GL_API void GL_APIENTRY glFogx (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glFogxv (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glFrontFace (GLenum mode);
+GL_API void GL_APIENTRY glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+GL_API void GL_APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
+GL_API void GL_APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
+GL_API void GL_APIENTRY glGetClipPlanex (GLenum pname, GLfixed eqn[4]);
+GL_API void GL_APIENTRY glGenBuffers (GLsizei n, GLuint *buffers);
+GL_API void GL_APIENTRY glGenTextures (GLsizei n, GLuint *textures);
+GL_API GLenum GL_APIENTRY glGetError (void);
+GL_API void GL_APIENTRY glGetFixedv (GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetIntegerv (GLenum pname, GLint *params);
+GL_API void GL_APIENTRY glGetLightxv (GLenum light, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetMaterialxv (GLenum face, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetPointerv (GLenum pname, void **params);
+GL_API const GLubyte * GL_APIENTRY glGetString (GLenum name);
+GL_API void GL_APIENTRY glGetTexEnviv (GLenum env, GLenum pname, GLint *params);
+GL_API void GL_APIENTRY glGetTexEnvxv (GLenum env, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
+GL_API void GL_APIENTRY glGetTexParameterxv (GLenum target, GLenum pname, GLfixed *params);
+GL_API void GL_APIENTRY glHint (GLenum target, GLenum mode);
+GL_API GLboolean GL_APIENTRY glIsBuffer (GLuint buffer);
+GL_API GLboolean GL_APIENTRY glIsEnabled (GLenum cap);
+GL_API GLboolean GL_APIENTRY glIsTexture (GLuint texture);
+GL_API void GL_APIENTRY glLightModelx (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glLightModelxv (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glLightx (GLenum light, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glLightxv (GLenum light, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glLineWidthx (GLfixed width);
+GL_API void GL_APIENTRY glLoadIdentity (void);
+GL_API void GL_APIENTRY glLoadMatrixx (const GLfixed *m);
+GL_API void GL_APIENTRY glLogicOp (GLenum opcode);
+GL_API void GL_APIENTRY glMaterialx (GLenum face, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glMatrixMode (GLenum mode);
+GL_API void GL_APIENTRY glMultMatrixx (const GLfixed *m);
+GL_API void GL_APIENTRY glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+GL_API void GL_APIENTRY glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
+GL_API void GL_APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+GL_API void GL_APIENTRY glPixelStorei (GLenum pname, GLint param);
+GL_API void GL_APIENTRY glPointParameterx (GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glPointParameterxv (GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glPointSizex (GLfixed size);
+GL_API void GL_APIENTRY glPolygonOffsetx (GLfixed factor, GLfixed units);
+GL_API void GL_APIENTRY glPopMatrix (void);
+GL_API void GL_APIENTRY glPushMatrix (void);
+GL_API void GL_APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+GL_API void GL_APIENTRY glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+GL_API void GL_APIENTRY glSampleCoverage (GLclampf value, GLboolean invert);
+GL_API void GL_APIENTRY glSampleCoveragex (GLclampx value, GLboolean invert);
+GL_API void GL_APIENTRY glScalex (GLfixed x, GLfixed y, GLfixed z);
+GL_API void GL_APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
+GL_API void GL_APIENTRY glShadeModel (GLenum mode);
+GL_API void GL_APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
+GL_API void GL_APIENTRY glStencilMask (GLuint mask);
+GL_API void GL_APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
+GL_API void GL_APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param);
+GL_API void GL_APIENTRY glTexEnvx (GLenum target, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params);
+GL_API void GL_APIENTRY glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+GL_API void GL_APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
+GL_API void GL_APIENTRY glTexParameterx (GLenum target, GLenum pname, GLfixed param);
+GL_API void GL_APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
+GL_API void GL_APIENTRY glTexParameterxv (GLenum target, GLenum pname, const GLfixed *params);
+GL_API void GL_APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+GL_API void GL_APIENTRY glTranslatex (GLfixed x, GLfixed y, GLfixed z);
+GL_API void GL_APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GL_API void GL_APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
+
+/*------------------------------------------------------------------------*
+ * Required OES extension functions
+ *------------------------------------------------------------------------*/
+
+/* GL_OES_read_format */
+#ifndef GL_OES_read_format
+#define GL_OES_read_format 1
+#endif
+
+/* GL_OES_compressed_paletted_texture */
+#ifndef GL_OES_compressed_paletted_texture
+#define GL_OES_compressed_paletted_texture 1
+#endif
+
+/* GL_OES_point_size_array */
+#ifndef GL_OES_point_size_array
+#define GL_OES_point_size_array 1
+GL_API void GL_APIENTRY glPointSizePointerOES (GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+/* GL_OES_point_sprite */
+#ifndef GL_OES_point_sprite
+#define GL_OES_point_sprite 1
+#endif
+
+#include "SDL_opengles_ext.h"
+
+/*************************************************************/
+
+/* Available only in GL-ES 2.0 only*/
+#if GL_ES_VERSION_2_0
+GL_API void         GL_APIENTRY glAttachShader (GLuint program, GLuint shader);
+GL_API void         GL_APIENTRY glBindAttribLocation (GLuint program, GLuint index, const char* name);
+GL_API void         GL_APIENTRY glBindBuffer (GLenum target, GLuint buffer);
+GL_API void         GL_APIENTRY glBindFramebuffer (GLenum target, GLuint framebuffer);
+GL_API void         GL_APIENTRY glBindRenderbuffer (GLenum target, GLuint renderbuffer);
+GL_API void         GL_APIENTRY glBindTexture (GLenum target, GLuint texture);
+GL_API void         GL_APIENTRY glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+GL_API void         GL_APIENTRY glBlendEquation ( GLenum mode );
+GL_API void         GL_APIENTRY glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
+GL_API void         GL_APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
+GL_API void         GL_APIENTRY glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+GL_API void         GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
+GL_API void         GL_APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
+GL_API GLenum       GL_APIENTRY glCheckFramebufferStatus (GLenum target);
+GL_API void         GL_APIENTRY glClear (GLbitfield mask);
+GL_API void         GL_APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+GL_API void         GL_APIENTRY glClearDepthf (GLclampf depth);
+GL_API void         GL_APIENTRY glClearStencil (GLint s);
+GL_API void         GL_APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+GL_API void         GL_APIENTRY glCompileShader (GLuint shader);
+GL_API void         GL_APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
+GL_API void         GL_APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
+GL_API void         GL_APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+GL_API void         GL_APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+GL_API GLuint       GL_APIENTRY glCreateProgram (void);
+GL_API GLuint       GL_APIENTRY glCreateShader (GLenum type);
+GL_API void         GL_APIENTRY glCullFace (GLenum mode);
+GL_API void         GL_APIENTRY glDeleteBuffers (GLsizei n, const GLuint* buffers);
+GL_API void         GL_APIENTRY glDeleteFramebuffers (GLsizei n, const GLuint* framebuffers);
+GL_API void         GL_APIENTRY glDeleteProgram (GLuint program);
+GL_API void         GL_APIENTRY glDeleteRenderbuffers (GLsizei n, const GLuint* renderbuffers);
+GL_API void         GL_APIENTRY glDeleteShader (GLuint shader);
+GL_API void         GL_APIENTRY glDeleteTextures (GLsizei n, const GLuint* textures);
+GL_API void         GL_APIENTRY glDepthFunc (GLenum func);
+GL_API void         GL_APIENTRY glDepthMask (GLboolean flag);
+GL_API void         GL_APIENTRY glDepthRangef (GLclampf zNear, GLclampf zFar);
+GL_API void         GL_APIENTRY glDetachShader (GLuint program, GLuint shader);
+GL_API void         GL_APIENTRY glDisable (GLenum cap);
+GL_API void         GL_APIENTRY glDisableVertexAttribArray (GLuint index);
+GL_API void         GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
+GL_API void         GL_APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const void* indices);
+GL_API void         GL_APIENTRY glEnable (GLenum cap);
+GL_API void         GL_APIENTRY glEnableVertexAttribArray (GLuint index);
+GL_API void         GL_APIENTRY glFinish (void);
+GL_API void         GL_APIENTRY glFlush (void);
+GL_API void         GL_APIENTRY glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+GL_API void         GL_APIENTRY glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+GL_API void         GL_APIENTRY glFrontFace (GLenum mode);
+GL_API void         GL_APIENTRY glGenBuffers (GLsizei n, GLuint* buffers);
+GL_API void         GL_APIENTRY glGenerateMipmap (GLenum target);
+GL_API void         GL_APIENTRY glGenFramebuffers (GLsizei n, GLuint* framebuffers);
+GL_API void         GL_APIENTRY glGenRenderbuffers (GLsizei n, GLuint* renderbuffers);
+GL_API void         GL_APIENTRY glGenTextures (GLsizei n, GLuint* textures);
+GL_API void         GL_APIENTRY glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
+GL_API void         GL_APIENTRY glGetActiveUniform (GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
+GL_API void         GL_APIENTRY glGetAttachedShaders (GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
+GL_API int          GL_APIENTRY glGetAttribLocation (GLuint program, const char* name);
+GL_API void         GL_APIENTRY glGetBooleanv (GLenum pname, GLboolean* params);
+GL_API void         GL_APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint* params);
+GL_API GLenum       GL_APIENTRY glGetError (void);
+GL_API void         GL_APIENTRY glGetFloatv (GLenum pname, GLfloat* params);
+GL_API void         GL_APIENTRY glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetIntegerv (GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetProgramiv (GLuint program, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetProgramInfoLog (GLuint program, GLsizei bufsize, GLsizei* length, char* infolog);
+GL_API void         GL_APIENTRY glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetShaderiv (GLuint shader, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetShaderInfoLog (GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog);
+GL_API void         GL_APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
+GL_API void         GL_APIENTRY glGetShaderSource (GLuint shader, GLsizei bufsize, GLsizei* length, char* source);
+GL_API const GLubyte* GL_APIENTRY glGetString (GLenum name);
+GL_API void         GL_APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat* params);
+GL_API void         GL_APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetUniformfv (GLuint program, GLint location, GLfloat* params);
+GL_API void         GL_APIENTRY glGetUniformiv (GLuint program, GLint location, GLint* params);
+GL_API int          GL_APIENTRY glGetUniformLocation (GLuint program, const char* name);
+GL_API void         GL_APIENTRY glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat* params);
+GL_API void         GL_APIENTRY glGetVertexAttribiv (GLuint index, GLenum pname, GLint* params);
+GL_API void         GL_APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, void** pointer);
+GL_API void         GL_APIENTRY glHint (GLenum target, GLenum mode);
+GL_API GLboolean    GL_APIENTRY glIsBuffer (GLuint buffer);
+GL_API GLboolean    GL_APIENTRY glIsEnabled (GLenum cap);
+GL_API GLboolean    GL_APIENTRY glIsFramebuffer (GLuint framebuffer);
+GL_API GLboolean    GL_APIENTRY glIsProgram (GLuint program);
+GL_API GLboolean    GL_APIENTRY glIsRenderbuffer (GLuint renderbuffer);
+GL_API GLboolean    GL_APIENTRY glIsShader (GLuint shader);
+GL_API GLboolean    GL_APIENTRY glIsTexture (GLuint texture);
+GL_API void         GL_APIENTRY glLineWidth (GLfloat width);
+GL_API void         GL_APIENTRY glLinkProgram (GLuint program);
+GL_API void         GL_APIENTRY glPixelStorei (GLenum pname, GLint param);
+GL_API void         GL_APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
+GL_API void         GL_APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
+GL_API void         GL_APIENTRY glReleaseShaderCompiler (void);
+GL_API void         GL_APIENTRY glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+GL_API void         GL_APIENTRY glSampleCoverage (GLclampf value, GLboolean invert);
+GL_API void         GL_APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
+GL_API void         GL_APIENTRY glShaderBinary (GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length);
+GL_API void         GL_APIENTRY glShaderSource (GLuint shader, GLsizei count, const char** string, const GLint* length);
+GL_API void         GL_APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
+GL_API void         GL_APIENTRY glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
+GL_API void         GL_APIENTRY glStencilMask (GLuint mask);
+GL_API void         GL_APIENTRY glStencilMaskSeparate (GLenum face, GLuint mask);
+GL_API void         GL_APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
+GL_API void         GL_APIENTRY glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
+GL_API void         GL_APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+GL_API void         GL_APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
+GL_API void         GL_APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat* params);
+GL_API void         GL_APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
+GL_API void         GL_APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint* params);
+GL_API void         GL_APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
+GL_API void         GL_APIENTRY glUniform1f (GLint location, GLfloat x);
+GL_API void         GL_APIENTRY glUniform1fv (GLint location, GLsizei count, const GLfloat* v);
+GL_API void         GL_APIENTRY glUniform1i (GLint location, GLint x);
+GL_API void         GL_APIENTRY glUniform1iv (GLint location, GLsizei count, const GLint* v);
+GL_API void         GL_APIENTRY glUniform2f (GLint location, GLfloat x, GLfloat y);
+GL_API void         GL_APIENTRY glUniform2fv (GLint location, GLsizei count, const GLfloat* v);
+GL_API void         GL_APIENTRY glUniform2i (GLint location, GLint x, GLint y);
+GL_API void         GL_APIENTRY glUniform2iv (GLint location, GLsizei count, const GLint* v);
+GL_API void         GL_APIENTRY glUniform3f (GLint location, GLfloat x, GLfloat y, GLfloat z);
+GL_API void         GL_APIENTRY glUniform3fv (GLint location, GLsizei count, const GLfloat* v);
+GL_API void         GL_APIENTRY glUniform3i (GLint location, GLint x, GLint y, GLint z);
+GL_API void         GL_APIENTRY glUniform3iv (GLint location, GLsizei count, const GLint* v);
+GL_API void         GL_APIENTRY glUniform4f (GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_API void         GL_APIENTRY glUniform4fv (GLint location, GLsizei count, const GLfloat* v);
+GL_API void         GL_APIENTRY glUniform4i (GLint location, GLint x, GLint y, GLint z, GLint w);
+GL_API void         GL_APIENTRY glUniform4iv (GLint location, GLsizei count, const GLint* v);
+GL_API void         GL_APIENTRY glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+GL_API void         GL_APIENTRY glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+GL_API void         GL_APIENTRY glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+GL_API void         GL_APIENTRY glUseProgram (GLuint program);
+GL_API void         GL_APIENTRY glValidateProgram (GLuint program);
+GL_API void         GL_APIENTRY glVertexAttrib1f (GLuint indx, GLfloat x);
+GL_API void         GL_APIENTRY glVertexAttrib1fv (GLuint indx, const GLfloat* values);
+GL_API void         GL_APIENTRY glVertexAttrib2f (GLuint indx, GLfloat x, GLfloat y);
+GL_API void         GL_APIENTRY glVertexAttrib2fv (GLuint indx, const GLfloat* values);
+GL_API void         GL_APIENTRY glVertexAttrib3f (GLuint indx, GLfloat x, GLfloat y, GLfloat z);
+GL_API void         GL_APIENTRY glVertexAttrib3fv (GLuint indx, const GLfloat* values);
+GL_API void         GL_APIENTRY glVertexAttrib4f (GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_API void         GL_APIENTRY glVertexAttrib4fv (GLuint indx, const GLfloat* values);
+GL_API void         GL_APIENTRY glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr);
+GL_API void         GL_APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gl_h_ */
+
diff -pruN libsdl-1.2/include/SDL_video.h libsdl-1.2-palm/include/SDL_video.h
--- libsdl-1.2/include/SDL_video.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/include/SDL_video.h	2009-07-13 11:28:45.000000000 -0700
@@ -123,8 +123,10 @@ typedef struct SDL_Surface {
 #define SDL_HWPALETTE	0x20000000	/* Surface has exclusive palette */
 #define SDL_DOUBLEBUF	0x40000000	/* Set up double-buffered video mode */
 #define SDL_FULLSCREEN	0x80000000	/* Surface is a full screen display */
-#define SDL_OPENGL      0x00000002      /* Create an OpenGL rendering context */
+#define SDL_OPENGL      0x00000002  /* Create an OpenGL rendering context */
 #define SDL_OPENGLBLIT	0x0000000A	/* Create an OpenGL rendering context and use it for blitting */
+#define SDL_OPENGLES    0x00000040  /* Create an OpenGL-ES rendering context */
+#define SDL_OPENGLESBLIT 0x00000048 /* Create an OpenGL-ES rendering context and use it for blitting  */
 #define SDL_RESIZABLE	0x00000010	/* This video mode may be resized */
 #define SDL_NOFRAME	0x00000020	/* No window caption or edge frame */
 /* Used internally (read-only) */
@@ -215,7 +217,10 @@ typedef enum {
     SDL_GL_MULTISAMPLEBUFFERS,
     SDL_GL_MULTISAMPLESAMPLES,
     SDL_GL_ACCELERATED_VISUAL,
-    SDL_GL_SWAP_CONTROL
+    SDL_GL_RETAINED_BACKING,
+    SDL_GL_CONTEXT_MAJOR_VERSION,
+    SDL_GL_CONTEXT_MINOR_VERSION,
+    SDL_GL_SWAP_CONTROL,
 } SDL_GLattr;
 
 /* flags for SDL_SetPalette() */
@@ -786,11 +791,28 @@ extern DECLSPEC void SDLCALL SDL_FreeYUV
 extern DECLSPEC int SDLCALL SDL_GL_LoadLibrary(const char *path);
 
 /*
+ * Dynamically load an OpenGL ES driver, if SDL is built with dynamic GL.
+ *
+ * SDL links normally with the OpenGL ES library on your system by default,
+ * but you can compile it to dynamically load the GL driver at runtime.
+ * If you do this, you need to retrieve all of the OpenGL ES functions used in
+ * your program from the dynamic library using SDL_GLES_GetProcAddress().
+ *
+ * This is disabled in default builds of SDL.
+*/
+extern DECLSPEC int SDLCALL SDL_GLES_LoadLibrary(const char *path);
+
+/*
  * Get the address of a GL function
  */
 extern DECLSPEC void * SDLCALL SDL_GL_GetProcAddress(const char* proc);
 
 /*
+ * Get the address of an OpenGL ES function (for extension functions)
+*/
+extern DECLSPEC void * SDLCALL SDL_GLES_GetProcAddress(const char* proc);
+
+/*
  * Set an attribute of the OpenGL subsystem before intialization.
  */
 extern DECLSPEC int SDLCALL SDL_GL_SetAttribute(SDL_GLattr attr, int value);
diff -pruN libsdl-1.2/Makefile.in libsdl-1.2-palm/Makefile.in
--- libsdl-1.2/Makefile.in	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/Makefile.in	2009-10-09 16:20:03.000000000 -0700
@@ -42,7 +42,7 @@ SDLMAIN_OBJECTS = @SDLMAIN_OBJECTS@
 
 DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
 
-HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_opengles.h SDL_opengles_ext.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
 
 LT_AGE      = @LT_AGE@
 LT_CURRENT  = @LT_CURRENT@
diff -pruN libsdl-1.2/src/audio/alsa/SDL_alsa_audio.c libsdl-1.2-palm/src/audio/alsa/SDL_alsa_audio.c
--- libsdl-1.2/src/audio/alsa/SDL_alsa_audio.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/audio/alsa/SDL_alsa_audio.c	2009-11-13 13:27:28.000000000 -0800
@@ -173,6 +173,12 @@ static const char *get_audio_device(int 
 {
 	const char *device;
 	
+#ifdef PALM
+	// on palm, you must open the "media" device
+	// to be heard on all headsets, speakers, etc.
+	return "media";
+#endif
+	
 	device = SDL_getenv("AUDIODEV");	/* Is there a standard variable name? */
 	if ( device == NULL ) {
 		if (channels == 6) device = "surround51";
diff -pruN libsdl-1.2/src/audio/SDL_audio.c libsdl-1.2-palm/src/audio/SDL_audio.c
--- libsdl-1.2/src/audio/SDL_audio.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/audio/SDL_audio.c	2009-12-02 23:36:35.000000000 -0800
@@ -117,6 +117,12 @@ static AudioBootStrap *bootstrap[] = {
 };
 SDL_AudioDevice *current_audio = NULL;
 
+#ifdef PALM
+SDL_bool desiredAudioSuppression = SDL_FALSE;
+SDL_bool suppress_audio = SDL_FALSE; 
+void SDL_DoSuppressAudio();
+#endif
+
 /* Various local functions */
 int SDL_AudioInit(const char *driver_name);
 void SDL_AudioQuit(void);
@@ -190,29 +196,41 @@ int SDLCALL SDL_RunAudio(void *audiop)
 				stream = audio->fake_stream;
 			}
 		}
-
-		SDL_memset(stream, silence, stream_len);
-
-		if ( ! audio->paused ) {
-			SDL_mutexP(audio->mixer_lock);
-			(*fill)(udata, stream, stream_len);
-			SDL_mutexV(audio->mixer_lock);
+		
+#ifdef PALM
+		// if audio is suppressed, we don't do any of the streaming
+		if ( suppress_audio ) 
+		{	
+			stream = audio->fake_stream;
 		}
+		else
+#else
+		if ( 1 ) // some compilers have problems with unqualified scopes
+#endif
+		{
+			SDL_memset(stream, silence, stream_len);
 
-		/* Convert the audio if necessary */
-		if ( audio->convert.needed ) {
-			SDL_ConvertAudio(&audio->convert);
-			stream = audio->GetAudioBuf(audio);
-			if ( stream == NULL ) {
-				stream = audio->fake_stream;
+			if ( ! audio->paused ) {
+				SDL_mutexP(audio->mixer_lock);
+				(*fill)(udata, stream, stream_len);
+				SDL_mutexV(audio->mixer_lock);
+			}
+	
+			/* Convert the audio if necessary */
+			if ( audio->convert.needed ) {
+				SDL_ConvertAudio(&audio->convert);
+				stream = audio->GetAudioBuf(audio);
+				if ( stream == NULL ) {
+					stream = audio->fake_stream;
+				}
+				SDL_memcpy(stream, audio->convert.buf,
+				               audio->convert.len_cvt);
+			}
+	
+			/* Ready current buffer for play and change current buffer */
+			if ( stream != audio->fake_stream ) {
+				audio->PlayAudio(audio);
 			}
-			SDL_memcpy(stream, audio->convert.buf,
-			               audio->convert.len_cvt);
-		}
-
-		/* Ready current buffer for play and change current buffer */
-		if ( stream != audio->fake_stream ) {
-			audio->PlayAudio(audio);
 		}
 
 		/* Wait for an audio buffer to become available */
@@ -221,6 +239,17 @@ int SDLCALL SDL_RunAudio(void *audiop)
 		} else {
 			audio->WaitAudio(audio);
 		}
+		
+#ifdef PALM
+		// has a call been made to suppress audio?
+		if ( suppress_audio != desiredAudioSuppression )
+		{
+			// suppress the audio. We hold off until now to do it to ensure it's all done
+			// in the sound thread (instead of whatever thread the caller was in). This 
+			// prevents race conditions.
+			SDL_DoSuppressAudio();
+		}
+#endif
 	}
 
 	/* Wait for the audio to drain.. */
@@ -422,7 +451,12 @@ int SDL_OpenAudio(SDL_AudioSpec *desired
 	}
 	if ( desired->freq == 0 ) {
 		/* Pick some default audio frequency */
+#ifdef PALM
+		/* 44k is optimal; avoids conversion in pulseaudio */
+		desired->freq = 44100;
+#else		
 		desired->freq = 22050;
+#endif		
 	}
 	if ( desired->format == 0 ) {
 		env = SDL_getenv("SDL_AUDIO_FORMAT");
@@ -693,3 +727,63 @@ void SDL_CalculateAudioSpec(SDL_AudioSpe
 	spec->size *= spec->channels;
 	spec->size *= spec->samples;
 }
+
+#ifdef PALM
+
+/* This function is called only from SDL_RunAudio, in a thread-safe way.
+ * Other parts of SDL will call SDL_SuppressAudio instead, which
+ * merely notes the desired state and lets the sound thread deal with 
+ * the change */
+void SDL_DoSuppressAudio()
+{
+	SDL_AudioDevice *audio = current_audio;
+	
+	// do nothing if we're already in the desired state
+	if ( suppress_audio == desiredAudioSuppression ) return;
+	
+	//printf("SDL_DoSuppressAudio past check\n");
+	suppress_audio = desiredAudioSuppression;
+	
+	// defensive coding
+	if ( audio == NULL ) return;
+	
+	if ( suppress_audio )
+	{
+		// if the audio is connected, disconnect from it.
+		if ( audio->opened )
+		{
+			// disconnect from the audio handler
+			audio->CloseAudio(audio);
+			audio->opened = 0;
+		}
+	}
+	else
+	{
+		// if the audio isn't connected, connect to it.
+		if ( !audio->opened )
+		{
+			// re-connect to the audio handler
+			int res;
+			res = audio->OpenAudio(audio, &audio->spec);
+			if ( res == 0 )
+			{
+				audio->opened = 1;
+			}
+			else
+			{
+				// we could not reconnect to the audio handler
+				printf("could not reconnect to audio\n");
+				SDL_CloseAudio();
+			}
+		}
+	}
+}
+
+void SDL_SuppressAudio(SDL_bool Suppress)
+{
+	//printf("SDL_SuppressAudio: %s\n", Suppress?"TRUE":"FALSE");
+	desiredAudioSuppression = Suppress;
+}
+#endif
+
+
diff -pruN libsdl-1.2/src/audio/SDL_audio_c.h libsdl-1.2-palm/src/audio/SDL_audio_c.h
--- libsdl-1.2/src/audio/SDL_audio_c.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/audio/SDL_audio_c.h	2009-11-12 15:26:47.000000000 -0800
@@ -32,3 +32,13 @@ extern void SDL_CalculateAudioSpec(SDL_A
 
 /* The actual mixing thread function */
 extern int SDLCALL SDL_RunAudio(void *audiop);
+
+
+#ifdef PALM
+// internal function for use by Palm only. This will suppress
+// buffer fills and processing (if Suppress is SDL_TRUE). The suppression
+// stops when this is called with SDL_FALSE;
+extern void SDLCALL SDL_SuppressAudio(SDL_bool Suppress);
+#endif
+
+
diff -pruN libsdl-1.2/src/audio/SDL_mixer_arm.c libsdl-1.2-palm/src/audio/SDL_mixer_arm.c
--- libsdl-1.2/src/audio/SDL_mixer_arm.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/audio/SDL_mixer_arm.c	2009-12-02 23:36:35.000000000 -0800
@@ -0,0 +1,184 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+#include "SDL_stdinc.h"
+#include "SDL_audio.h"
+
+/*
+	ARM assembly mix routines
+	palm, inc.
+*/
+
+/* The volume ranges from 0 - 128 */
+#define ADJUST_VOLUME(s, v) (s = (s*v)/SDL_MIX_MAXVOLUME)
+#define ADJUST_VOLUME_U8(s, v)  (s = (((s-128)*v)/SDL_MIX_MAXVOLUME)+128)
+
+#if defined(__ARM_NEON__) && defined(__GNUC__)
+void SDL_MixAudio_ARM_NEON_S16LSB(Uint8 *dst, const Uint8 *src, Uint32 len, int volume)
+{
+    Sint16 src1, src2;
+    int dst_sample;
+    const int max_audioval = ((1<<(16-1))-1);
+    const int min_audioval = -(1<<(16-1));
+
+    len /= 2;
+
+    if (((int)src & 1) == 0 && ((int)dst & 1) == 0) {
+
+        // Align dst pointer
+        for (; ((int)dst & 0xF) && len; --len) {
+            src1 = ((src[1])<<8|src[0]);
+            ADJUST_VOLUME(src1, volume);
+            src2 = ((dst[1])<<8|dst[0]);
+            src += 2;
+            dst_sample = src1+src2;
+            if ( dst_sample > max_audioval ) {
+                dst_sample = max_audioval;
+            } else
+            if ( dst_sample < min_audioval ) {
+                dst_sample = min_audioval;
+            }
+            dst[0] = dst_sample&0xFF;
+            dst_sample >>= 8;
+            dst[1] = dst_sample&0xFF;
+            dst += 2;
+        }
+
+        //printf( "Entering neon dst %p src %p len %d\n", dst, src, len);
+
+        int Chunks = len >> 3;
+        len &= 0x7;
+
+        if (Chunks) {
+            asm volatile (
+                "vmov.i16   d0[0], %[Vol]                   \n\t"
+
+                "L_%=:                                      \n\t" // generates a unique label
+
+                "vldm       %[SrcP]!, { d2, d3 }            \n\t"
+                "pld        [%[SrcP], #64]                  \n\t"
+
+                "vldm       %[DstP],  { d10, d11 }          \n\t"
+                "pld        [%[DstP], #64]                  \n\t"
+
+                "vmull.s16  q2, d2, d0[0]                   \n\t" // multiply by volume and expand to 32 bits
+                "vmull.s16  q3, d3, d0[0]                   \n\t" // multiply by volume and expand to 32 bits
+
+                "vshrn.s32  d2, q2, #7                      \n\t"
+                "vshrn.s32  d3, q3, #7                      \n\t"
+
+                "vqadd.s16  q1, q1, q5                      \n\t"
+
+                "subs       %[len], #1                      \n\t"
+                "vstm       %[DstP]!, { d2, d3 }            \n\t"
+
+                "bne        L_%=                            \n\t"
+
+                : [DstP] "+r" (dst), [SrcP] "+r" (src), [len] "+r" (Chunks)
+                : [Vol] "r" (volume)
+                : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d10", "d11", "cc", "memory"
+                 );
+        }
+    }
+
+    while ( len-- ) {
+        src1 = ((src[1])<<8|src[0]);
+        ADJUST_VOLUME(src1, volume);
+        src2 = ((dst[1])<<8|dst[0]);
+        src += 2;
+        dst_sample = src1+src2;
+        if ( dst_sample > max_audioval ) {
+            dst_sample = max_audioval;
+        } else
+        if ( dst_sample < min_audioval ) {
+            dst_sample = min_audioval;
+        }
+        dst[0] = dst_sample&0xFF;
+        dst_sample >>= 8;
+        dst[1] = dst_sample&0xFF;
+        dst += 2;
+    }
+}
+#endif
+
+#if 0
+void SDL_MixAudio_ARMv6_S16LSB(Uint8 *dst, const Uint8 *src, Uint32 len, int volume)
+{
+    Sint16 src1, src2;
+    int dst_sample;
+    const int max_audioval = ((1<<(16-1))-1);
+    const int min_audioval = -(1<<(16-1));
+
+    len /= 2;
+
+    // Does not appear to be any faster... needs further investigation.
+    if (len && ((int)src & 1) == 0 && ((int)dst & 1) == 0) {
+        asm volatile (
+            "ldrsh      r6, [%[SrcP]], #2               \n\t"
+            "ldrsh      r7, [%[DstP]]                   \n\t"
+
+            "L_%=:                                      \n\t" // generates a unique label
+
+            "mov        r4, r6                          \n\t"
+                "pld        [%[SrcP], #64]                  \n\t"
+
+            "mul        r4, r4, %[Vol]                  \n\t"
+                "subs       %[len], #1                      \n\t"
+
+            "mov        r5, r7                          \n\t"
+                "pld        [%[DstP], #64]                  \n\t"
+
+            "asr        r4, #7                          \n\t"
+                "ldrnesh    r6, [%[SrcP]], #2               \n\t"
+
+            "qadd16     r4, r4, r5                          \n\t"
+                "ldrnesh    r7, [%[DstP], #2]               \n\t"
+
+            "strh       r4, [%[DstP]], #2               \n\t"
+            "bne        L_%=                            \n\t"
+
+            : [DstP] "+r" (dst), [SrcP] "+r" (src), [len] "+r" (len)
+            : [Vol] "r" (volume)
+            : "r4", "r5", "r6", "r7", "cc", "memory"
+             );
+    }
+
+    while ( len-- ) {
+        src1 = ((src[1])<<8|src[0]);
+        ADJUST_VOLUME(src1, volume);
+        src2 = ((dst[1])<<8|dst[0]);
+        src += 2;
+        dst_sample = src1+src2;
+        if ( dst_sample > max_audioval ) {
+            dst_sample = max_audioval;
+        } else
+        if ( dst_sample < min_audioval ) {
+            dst_sample = min_audioval;
+        }
+        dst[0] = dst_sample&0xFF;
+        dst_sample >>= 8;
+        dst[1] = dst_sample&0xFF;
+        dst += 2;
+    }
+}
+#endif
+
diff -pruN libsdl-1.2/src/audio/SDL_mixer_arm.h libsdl-1.2-palm/src/audio/SDL_mixer_arm.h
--- libsdl-1.2/src/audio/SDL_mixer_arm.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/audio/SDL_mixer_arm.h	2009-12-02 23:36:35.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/*
+	ARM assembly mix routines
+	palm, inc.
+*/
+
+#if defined(__ARM_NEON__) && defined(__GNUC__)
+void SDL_MixAudio_ARM_NEON_S16LSB(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);
+void SDL_MixAudio_ARMv6_S16LSB(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);
+#endif
diff -pruN libsdl-1.2/src/audio/SDL_mixer.c libsdl-1.2-palm/src/audio/SDL_mixer.c
--- libsdl-1.2/src/audio/SDL_mixer.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/audio/SDL_mixer.c	2009-12-02 23:36:35.000000000 -0800
@@ -30,6 +30,8 @@
 #include "SDL_mixer_MMX.h"
 #include "SDL_mixer_MMX_VC.h"
 #include "SDL_mixer_m68k.h"
+// PALM
+#include "SDL_mixer_arm.h"
 
 /* This table is used to add two sound values together and pin
  * the value to avoid overflow.  (used with permission from ARDI)
@@ -189,6 +191,9 @@ void SDL_MixAudio (Uint8 *dst, const Uin
 #endif
 #if defined(__GNUC__) && defined(__M68000__) && defined(SDL_ASSEMBLY_ROUTINES)
 			SDL_MixAudio_m68k_S16LSB((short*)dst,(short*)src,(unsigned long)len,(long)volume);
+//PALM			
+#elif defined(__GNUC__) && defined(__ARM_NEON__) && defined(SDL_ASSEMBLY_ROUTINES)
+			SDL_MixAudio_ARM_NEON_S16LSB(dst, src, len, volume);
 #else
 			{
 			Sint16 src1, src2;
diff -pruN libsdl-1.2/src/events/SDL_events.c libsdl-1.2-palm/src/events/SDL_events.c
--- libsdl-1.2/src/events/SDL_events.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/events/SDL_events.c	2009-11-19 12:53:51.000000000 -0800
@@ -32,6 +32,10 @@
 #include "../joystick/SDL_joystick_c.h"
 #endif
 
+#ifdef PALM
+#include "webos/SDL_WebOsEvent.h"
+#endif
+
 /* Public data -- the event filter */
 SDL_EventFilter SDL_EventOK = NULL;
 Uint8 SDL_ProcessEvents[SDL_NUMEVENTS];
@@ -41,6 +45,9 @@ static Uint32 SDL_eventstate = 0;
 #define MAXEVENTS	128
 static struct {
 	SDL_mutex *lock;
+	/* PALM */
+	SDL_sem   *sem;
+	/*/PALM */
 	int active;
 	int head;
 	int tail;
@@ -98,10 +105,27 @@ static int SDLCALL SDL_GobbleEvents(void
 #endif
 #endif
 
+#ifdef PALM
+    if ( SDL_EventQ.active ) {
+#else
 	while ( SDL_EventQ.active ) {
+#endif
 		SDL_VideoDevice *video = current_video;
 		SDL_VideoDevice *this  = current_video;
 
+	    /* PALM: moved event locking from loop bottom to top */
+        /* Check for event locking.
+           On the P of the lock mutex, if the lock is held, this thread
+           will wait until the lock is released before continuing.  The
+           safe flag will be set, meaning that the other thread can go
+           about it's business.  The safe flag is reset before the V,
+           so as soon as the mutex is free, other threads can see that
+           it's not safe to interfere with the event thread.
+         */
+        SDL_mutexP(SDL_EventLock.lock);
+        SDL_EventLock.safe = 0;
+        SDL_mutexV(SDL_EventLock.lock);
+
 		/* Get events from the video subsystem */
 		if ( video ) {
 			video->PumpEvents(this);
@@ -119,28 +143,50 @@ static int SDLCALL SDL_GobbleEvents(void
 
 		/* Give up the CPU for the rest of our timeslice */
 		SDL_EventLock.safe = 1;
+
+#ifndef PALM
 		if ( SDL_timer_running ) {
 			SDL_ThreadedTimerCheck();
 		}
-		SDL_Delay(1);
+#endif
 
-		/* Check for event locking.
-		   On the P of the lock mutex, if the lock is held, this thread
-		   will wait until the lock is released before continuing.  The
-		   safe flag will be set, meaning that the other thread can go
-		   about it's business.  The safe flag is reset before the V,
-		   so as soon as the mutex is free, other threads can see that
-		   it's not safe to interfere with the event thread.
-		 */
-		SDL_mutexP(SDL_EventLock.lock);
-		SDL_EventLock.safe = 0;
-		SDL_mutexV(SDL_EventLock.lock);
+		SDL_Delay(1);
+	}
+#ifdef PALM
+	else
+#endif
+	{
+	    SDL_SetTimerThreaded(0);
+	    event_thread = 0;
 	}
-	SDL_SetTimerThreaded(0);
-	event_thread = 0;
 	return(0);
 }
 
+#ifdef PALM
+static int SDL_WebOsEventCallback(void)
+{
+    /* We are called whenever there is an input event. */
+    return SDL_GobbleEvents(NULL);
+}
+
+static int SDLCALL SDL_WebOsEventThread(void *unused)
+{
+    // TODO: increase priority?
+
+    /* Call once to initialize stuff */
+    SDL_GobbleEvents(NULL);
+
+    /* Call into the event loop */
+    SDL_WebOsEventLoop(SDL_WebOsEventCallback);
+
+    /* Our thread is exiting */
+    SDL_SetTimerThreaded(0);
+    event_thread = 0;
+
+    return(0);
+}
+#endif
+
 static int SDL_StartEventThread(Uint32 flags)
 {
 	/* Reset everything to zero */
@@ -157,6 +203,9 @@ static int SDL_StartEventThread(Uint32 f
 		return(-1);
 #endif
 	}
+	/* PALM */
+	SDL_EventQ.sem  = SDL_CreateSemaphore(0);
+	/*/PALM */
 #endif /* !SDL_THREADS_DISABLED */
 	SDL_EventQ.active = 1;
 
@@ -172,6 +221,10 @@ static int SDL_StartEventThread(Uint32 f
 #if (defined(__WIN32__) && !defined(_WIN32_WCE)) && !defined(HAVE_LIBC) && !defined(__SYMBIAN32__)
 #undef SDL_CreateThread
 		SDL_EventThread = SDL_CreateThread(SDL_GobbleEvents, NULL, NULL, NULL);
+#elif defined(PALM)
+		SDL_EventThread = SDL_CreateThread(SDL_WebOsEventThread, NULL);
+		/* The webos event thread doesn't handle timers */
+		SDL_SetTimerThreaded(0);
 #else
 		SDL_EventThread = SDL_CreateThread(SDL_GobbleEvents, NULL);
 #endif
@@ -188,12 +241,18 @@ static void SDL_StopEventThread(void)
 {
 	SDL_EventQ.active = 0;
 	if ( SDL_EventThread ) {
+#ifdef PALM
+	    SDL_WebOsEventLoopQuit();
+#endif
 		SDL_WaitThread(SDL_EventThread, NULL);
 		SDL_EventThread = NULL;
 		SDL_DestroyMutex(SDL_EventLock.lock);
 	}
 #ifndef IPOD
 	SDL_DestroyMutex(SDL_EventQ.lock);
+	/* PALM */
+	SDL_DestroySemaphore(SDL_EventQ.sem);
+	/* /PALM */
 #endif
 }
 
@@ -229,6 +288,9 @@ int SDL_StartEventLoop(Uint32 flags)
 	/* Clean out the event queue */
 	SDL_EventThread = NULL;
 	SDL_EventQ.lock = NULL;
+	/* PALM */
+	SDL_EventQ.sem  = NULL;
+	/*/PALM */
 	SDL_StopEventLoop();
 
 	/* No filter to start with, process most event types */
@@ -280,6 +342,9 @@ static int SDL_AddEvent(SDL_Event *event
 		}
 		SDL_EventQ.tail = tail;
 		added = 1;
+		/* PALM */
+		SDL_SemPost(SDL_EventQ.sem);
+		/*/PALM */
 	}
 	return(added);
 }
@@ -359,12 +424,33 @@ int SDL_PeepEvents(SDL_Event *events, in
 		SDL_SetError("Couldn't lock event queue");
 		used = -1;
 	}
+
+	/* PALM */
+	if (action == SDL_GETEVENT) {
+	    for (i = 0; i < used; i++) {
+	        SDL_SemWait(SDL_EventQ.sem);
+	    }
+	}
+	/* PALM */
+
 	return(used);
 }
 
 /* Run the system dependent event loops */
 void SDL_PumpEvents(void)
 {
+#ifdef PALM
+    /* Handle webos system interactions.
+     * This is called from PollEvent, and from WaitEvent when an event is available.
+     * This may cause a switch in render target, if the game has been asked to switch into/out of card mode.
+     * Doing so here is safe as long as the game does not poll (or wait) for events in the middle of drawing a frame.
+     * We considered putting this hook into SwapBuffers, which would guarantee we're not in the middle of a frame;
+     * however games that are playing back a video don't call SwapBuffers but should still provide a quick response
+     * to the activation.
+     */
+    SDL_WebOsEventMainThreadHook();
+#endif
+
 	if ( !SDL_EventThread ) {
 		SDL_VideoDevice *video = current_video;
 		SDL_VideoDevice *this  = current_video;
@@ -395,11 +481,17 @@ int SDL_PollEvent (SDL_Event *event)
 	/* We can't return -1, just return 0 (no event) on error */
 	if ( SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_ALLEVENTS) <= 0 )
 		return 0;
+
 	return 1;
 }
 
 int SDL_WaitEvent (SDL_Event *event)
 {
+    /* PALM */
+    SDL_SemWait(SDL_EventQ.sem);
+    /* Put the sem count back because PeepEvents will decrement it */
+    SDL_SemPost(SDL_EventQ.sem);
+
 	while ( 1 ) {
 		SDL_PumpEvents();
 		switch(SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_ALLEVENTS)) {
@@ -498,3 +590,16 @@ int SDL_PrivateSysWMEvent(SDL_SysWMmsg *
 	/* Update internal event state */
 	return(posted);
 }
+
+/* PALM */
+int SDL_DelayWithEventInterrupt(Uint32 ms)
+{
+    int Rc = SDL_SemWaitTimeout(SDL_EventQ.sem, ms);
+    if (Rc == 0) {
+        /* An event was returned before the timeout.  Replace it. */
+        SDL_SemPost(SDL_EventQ.sem);
+    }
+
+    return Rc;
+}
+/*/PALM */
diff -pruN libsdl-1.2/src/events/SDL_events_c.h libsdl-1.2-palm/src/events/SDL_events_c.h
--- libsdl-1.2/src/events/SDL_events_c.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/events/SDL_events_c.h	2009-11-23 00:46:27.000000000 -0800
@@ -58,10 +58,18 @@ extern int SDL_PrivateAppActive(Uint8 ga
 extern int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative,
 						Sint16 x, Sint16 y);
 extern int SDL_PrivateMouseButton(Uint8 state, Uint8 button,Sint16 x,Sint16 y);
+//PALM
+extern int SDL_PrivateMultiMouseMotion(Uint8 which, Uint8 buttonstate, int relative,
+                        Sint16 x, Sint16 y);
+extern int SDL_PrivateMultiMouseButton(Uint8 which, Uint8 state, Uint8 button,Sint16 x,Sint16 y);
+///PALM
 extern int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *key);
 extern int SDL_PrivateResize(int w, int h);
 extern int SDL_PrivateExpose(void);
 extern int SDL_PrivateQuit(void);
+#ifdef PALM
+extern int SDL_HighPriorityQuit(void);
+#endif
 extern int SDL_PrivateSysWMEvent(SDL_SysWMmsg *message);
 
 /* Used by the activity event handler to remove mouse focus */
@@ -78,3 +86,7 @@ extern void SDL_CheckKeyRepeat(void);
 #define DEFAULT_UNICODE_TRANSLATION 0	/* Default off because of overhead */
 #endif
 extern int SDL_TranslateUNICODE;
+
+/* PALM */
+extern int SDL_DelayWithEventInterrupt(Uint32 ms);
+/*/PALM */
diff -pruN libsdl-1.2/src/events/SDL_mouse.c libsdl-1.2-palm/src/events/SDL_mouse.c
--- libsdl-1.2/src/events/SDL_mouse.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/events/SDL_mouse.c	2009-06-22 13:35:19.000000000 -0700
@@ -30,23 +30,26 @@
 
 
 /* These are static for our mouse handling code */
-static Sint16 SDL_MouseX = 0;
-static Sint16 SDL_MouseY = 0;
-static Sint16 SDL_DeltaX = 0;
-static Sint16 SDL_DeltaY = 0;
-static Uint8  SDL_ButtonState = 0;
+static Sint16 SDL_MouseX[SDL_MAXMOUSE];
+static Sint16 SDL_MouseY[SDL_MAXMOUSE];
+static Sint16 SDL_DeltaX[SDL_MAXMOUSE];
+static Sint16 SDL_DeltaY[SDL_MAXMOUSE];
+static Uint8  SDL_ButtonState[SDL_MAXMOUSE];
 
 
 /* Public functions */
 int SDL_MouseInit(void)
 {
 	/* The mouse is at (0,0) */
-	SDL_MouseX = 0;
-	SDL_MouseY = 0;
-	SDL_DeltaX = 0;
-	SDL_DeltaY = 0;
-	SDL_ButtonState = 0;
-
+    int i;
+    for (i = 0; i < SDL_MAXMOUSE; i++) {
+    	SDL_MouseX[i] = 0;
+    	SDL_MouseY[i] = 0;
+    	SDL_DeltaX[i] = 0;
+    	SDL_DeltaY[i] = 0;
+    	SDL_ButtonState[i] = 0;
+    }
+    
 	/* That's it! */
 	return(0);
 }
@@ -55,36 +58,51 @@ void SDL_MouseQuit(void)
 }
 
 /* We lost the mouse, so post button up messages for all pressed buttons */
-void SDL_ResetMouse(void)
+void SDL_ResetMultiMouse(int which)
 {
 	Uint8 i;
-	for ( i = 0; i < sizeof(SDL_ButtonState)*8; ++i ) {
-		if ( SDL_ButtonState & SDL_BUTTON(i) ) {
-			SDL_PrivateMouseButton(SDL_RELEASED, i, 0, 0);
+	for ( i = 0; i < sizeof(SDL_ButtonState[which])*8; ++i ) {
+		if ( SDL_ButtonState[which] & SDL_BUTTON(i) ) {
+			SDL_PrivateMultiMouseButton(which, SDL_RELEASED, i, 0, 0);
 		}
 	}
 }
 
-Uint8 SDL_GetMouseState (int *x, int *y)
+void SDL_ResetMouse(void)
+{
+    SDL_ResetMultiMouse(0);
+}
+
+Uint8 SDL_GetMultiMouseState (int which, int *x, int *y)
 {
 	if ( x ) {
-		*x = SDL_MouseX;
+		*x = SDL_MouseX[which];
 	}
 	if ( y ) {
-		*y = SDL_MouseY;
+		*y = SDL_MouseY[which];
 	}
-	return(SDL_ButtonState);
+	return(SDL_ButtonState[which]);
 }
 
-Uint8 SDL_GetRelativeMouseState (int *x, int *y)
+Uint8 SDL_GetMouseState (int *x, int *y)
+{
+    return SDL_GetMultiMouseState(0, x, y);
+}
+
+Uint8 SDL_GetRelativeMultiMouseState (int which, int *x, int *y)
 {
 	if ( x )
-		*x = SDL_DeltaX;
+		*x = SDL_DeltaX[which];
 	if ( y )
-		*y = SDL_DeltaY;
-	SDL_DeltaX = 0;
-	SDL_DeltaY = 0;
-	return(SDL_ButtonState);
+		*y = SDL_DeltaY[which];
+	SDL_DeltaX[which] = 0;
+	SDL_DeltaY[which] = 0;
+	return(SDL_ButtonState[which]);
+}
+
+Uint8 SDL_GetRelativeMouseState (int *x, int *y)
+{
+    return SDL_GetRelativeMultiMouseState(0, x, y);
 }
 
 static void ClipOffset(Sint16 *x, Sint16 *y)
@@ -100,7 +118,7 @@ static void ClipOffset(Sint16 *x, Sint16
 }
 
 /* These are global for SDL_eventloop.c */
-int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
+int SDL_PrivateMultiMouseMotion(Uint8 which, Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
 {
 	int posted;
 	Uint16 X, Y;
@@ -114,15 +132,15 @@ int SDL_PrivateMouseMotion(Uint8 buttons
 
 	/* Default buttonstate is the current one */
 	if ( ! buttonstate ) {
-		buttonstate = SDL_ButtonState;
+		buttonstate = SDL_ButtonState[which];
 	}
 
 	Xrel = x;
 	Yrel = y;
 	if ( relative ) {
 		/* Push the cursor around */
-		x = (SDL_MouseX+x);
-		y = (SDL_MouseY+y);
+		x = (SDL_MouseX[which] + x);
+		y = (SDL_MouseY[which] + y);
 	} else {
 		/* Do we need to clip {x,y} ? */
 		ClipOffset(&x, &y);
@@ -150,8 +168,8 @@ int SDL_PrivateMouseMotion(Uint8 buttons
 	   the screen is windowed mode and the mouse is outside the window.
 	*/
 	if ( ! relative ) {
-		Xrel = X-SDL_MouseX;
-		Yrel = Y-SDL_MouseY;
+		Xrel = X-SDL_MouseX[which];
+		Yrel = Y-SDL_MouseY[which];
 	}
 
 	/* Drop events that don't change state */
@@ -163,12 +181,13 @@ printf("Mouse event didn't change state 
 	}
 
 	/* Update internal mouse state */
-	SDL_ButtonState = buttonstate;
-	SDL_MouseX = X;
-	SDL_MouseY = Y;
-	SDL_DeltaX += Xrel;
-	SDL_DeltaY += Yrel;
-        SDL_MoveCursor(SDL_MouseX, SDL_MouseY);
+	SDL_ButtonState[which] = buttonstate;
+	SDL_MouseX[which] = X;
+	SDL_MouseY[which] = Y;
+	SDL_DeltaX[which] += Xrel;
+	SDL_DeltaY[which] += Yrel;
+	if (which == 0)
+        SDL_MoveCursor(X, Y);
 
 	/* Post the event, if desired */
 	posted = 0;
@@ -176,6 +195,7 @@ printf("Mouse event didn't change state 
 		SDL_Event event;
 		SDL_memset(&event, 0, sizeof(event));
 		event.type = SDL_MOUSEMOTION;
+		event.motion.which = which;
 		event.motion.state = buttonstate;
 		event.motion.x = X;
 		event.motion.y = Y;
@@ -189,7 +209,13 @@ printf("Mouse event didn't change state 
 	return(posted);
 }
 
-int SDL_PrivateMouseButton(Uint8 state, Uint8 button, Sint16 x, Sint16 y)
+int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
+{
+    return SDL_PrivateMultiMouseMotion(0, buttonstate, relative, x, y);
+}
+
+//PALM
+int SDL_PrivateMultiMouseButton(Uint8 which, Uint8 state, Uint8 button, Sint16 x, Sint16 y)
 {
 	SDL_Event event;
 	int posted;
@@ -218,12 +244,12 @@ int SDL_PrivateMouseButton(Uint8 state, 
 		move_mouse = 0;
 	}
 	if ( ! x )
-		x = SDL_MouseX;
+		x = SDL_MouseX[which];
 	if ( ! y )
-		y = SDL_MouseY;
+		y = SDL_MouseY[which];
 
 	/* Figure out which event to perform */
-	buttonstate = SDL_ButtonState;
+	buttonstate = SDL_ButtonState[which];
 	switch ( state ) {
 		case SDL_PRESSED:
 			event.type = SDL_MOUSEBUTTONDOWN;
@@ -239,16 +265,19 @@ int SDL_PrivateMouseButton(Uint8 state, 
 	}
 
 	/* Update internal mouse state */
-	SDL_ButtonState = buttonstate;
+	SDL_ButtonState[which] = buttonstate;
 	if ( move_mouse ) {
-		SDL_MouseX = x;
-		SDL_MouseY = y;
-		SDL_MoveCursor(SDL_MouseX, SDL_MouseY);
+		SDL_MouseX[which] = x;
+		SDL_MouseY[which] = y;
+		if (which == 0) {
+		    SDL_MoveCursor(x, y);
+		}
 	}
 
 	/* Post the event, if desired */
 	posted = 0;
 	if ( SDL_ProcessEvents[event.type] == SDL_ENABLE ) {
+	    event.button.which = which;
 		event.button.state = state;
 		event.button.button = button;
 		event.button.x = x;
@@ -261,3 +290,7 @@ int SDL_PrivateMouseButton(Uint8 state, 
 	return(posted);
 }
 
+int SDL_PrivateMouseButton(Uint8 state, Uint8 button, Sint16 x, Sint16 y)
+{
+    return SDL_PrivateMultiMouseButton(0, state, button, x, y);
+}
diff -pruN libsdl-1.2/src/events/webos/integrated/SDL_WebOsEvent.c libsdl-1.2-palm/src/events/webos/integrated/SDL_WebOsEvent.c
--- libsdl-1.2/src/events/webos/integrated/SDL_WebOsEvent.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/integrated/SDL_WebOsEvent.c	2009-11-25 16:04:16.000000000 -0800
@@ -0,0 +1,410 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <unistd.h>
+#include "napp/NApp_c.h"
+#include "SDL_mutex.h"
+#include "SDL_timer.h" /* for SDL_GetTicks */
+#include "../../SDL_events_c.h"
+#include "../SDL_WebOsEvent.h"
+#include "../SDL_WebOsHook.h"
+#include "../../../joystick/SDL_sysjoystick.h"
+
+#if 0
+#define DEBUGTRACE(format, ...) do {                            \
+            printf("[%s:%4d] ", __FILE__, __LINE__ );           \
+            printf(format, ## __VA_ARGS__);                     \
+        } while(0)
+#else
+#define DEBUGTRACE(format, ...) do {} while(0)
+#endif
+
+#define COMPILE_TIME_ASSERT(name, x)               \
+       typedef int _compile_time_assert_ ## name[(x) * 2 - 1]
+
+COMPILE_TIME_ASSERT(Keypad,         SDL_WEBOS_KEYPAD         == NKeypad);
+COMPILE_TIME_ASSERT(Accelerometer,  SDL_WEBOS_ACCELEROMETER  == NAccelerometer);
+COMPILE_TIME_ASSERT(Touchpanel,     SDL_WEBOS_TOUCHPANEL     == NTouchpanel);
+
+static int      ControlFd = -1;
+static int      ReadyFd[NNumDevices][2];
+
+static int                  ActivatePending;
+static int                  ActivateStatus;
+static SDL_sem*             ActivateSem;
+
+#define MAX_ACTIVATE_CALLBACK   3
+#define MAX_PAUSED_CALLBACK     3
+
+static SDL_WebOsActivateCb  ActivateCallback[MAX_ACTIVATE_CALLBACK];
+static void*                ActivateCallbackData[MAX_ACTIVATE_CALLBACK];
+
+static SDL_WebOsPausedCb    PausedCallback[MAX_PAUSED_CALLBACK];
+static void*                PausedCallbackData[MAX_PAUSED_CALLBACK];
+
+static SDL_WebOsFocusedCb       FocusedCallback;
+static void*                    FocusedCallbackData;
+
+static SDL_WebOsInputEventCb    InputEventCallback;
+
+static SDL_bool     EventLoopEnabled;
+
+SDL_bool SDL_WebOsEventUseThread(void)
+{
+    return SDL_TRUE;
+}
+
+static void IQuitCallback(void)
+{
+    SDL_PrivateQuit();
+}
+
+int SDL_WebOsEventInit(void)
+{
+    ActivateSem = SDL_CreateSemaphore(0);
+    if (!ActivateSem) {
+        return -1;
+    }
+
+    if (ControlFd < 0) {
+        ControlFd = NApp_Init(IQuitCallback);
+    }
+
+    return ControlFd;
+}
+
+void SDL_WebOsEventQuit(void)
+{
+    if (ControlFd > 0) {
+
+        NApp_Quit();
+        ControlFd = -1;
+
+        NInputDevice Device;
+        for (Device = 0; Device < NNumDevices; Device++) {
+            if (ReadyFd[Device][0]) {
+                close(ReadyFd[Device][0]);
+            }
+            if (ReadyFd[Device][1]) {
+                close(ReadyFd[Device][1]);
+            }
+        }
+    }
+}
+
+inline SDL_WebOsHandle GetHandle(SDL_WebOsDevice Device)
+{
+    return (SDL_WebOsHandle)(Device + 10);
+}
+
+inline NInputDevice GetDevice(SDL_WebOsHandle Handle)
+{
+    return (NInputDevice)(Handle - 10);
+}
+
+SDL_WebOsHandle SDL_WebOsEventOpen(SDL_WebOsDevice Device)
+{
+    if (ControlFd < 0) {
+        if (SDL_WebOsEventInit() < 0) {
+            NTRACE( "SDL_WebOsEventInit failed\n");
+            return (SDL_WebOsHandle)-1;
+        }
+    }
+    
+    DEBUGTRACE( "SDL_WebOsEventOpen %d\n", Device);
+
+    switch(Device) {
+    case SDL_WEBOS_KEYPAD:
+    case SDL_WEBOS_ACCELEROMETER:
+    case SDL_WEBOS_TOUCHPANEL:
+	    // Guaranteed to match by compile time assert
+    	NApp_EnableEvent((NInputDevice)Device, 1);
+    	return GetHandle(Device);
+
+    default:
+        DEBUGTRACE( "Bad device: %d\n", Device);
+        return 0;
+    }
+}  
+
+void SDL_WebOsEventClose(SDL_WebOsHandle Handle)
+{
+    // Empty.
+}
+
+int SDL_WebOsEventGetFd(SDL_WebOsHandle Handle)
+{
+    NInputDevice Index = GetDevice(Handle);
+
+    /* Return a file descriptor that is always "ready" for select */
+    if (ReadyFd[Index][0] == 0) {
+        pipe(ReadyFd[Index]);
+
+        /* Write a byte to the pipe */
+        write(ReadyFd[Index][1], &Index, 1);
+    }
+
+    /* Read pipe should be ready for select */
+    return ReadyFd[Index][0];
+}
+
+int SDL_WebOsEventRead(SDL_WebOsHandle Handle, struct input_event* Events, int MaxEvents)
+{
+    return NApp_ReadEvents(GetDevice(Handle), Events, MaxEvents);
+}
+
+/* Internal activate callback is invoked in the event thread.
+ * Signal the main thread and wait for it to complete processing.
+ */
+static void IActivateCallback(void* Data, int Status)
+{
+    if (!EventLoopEnabled) {
+        DEBUGTRACE( "IActivateCallback: event loop disabled\n");
+        return;
+    }
+
+    if (Status != ActivateStatus) {
+        ActivateStatus  = Status;
+        ActivatePending = 1;
+
+        /* Send event here; app may be blocked waiting for an event */
+        SDL_PrivateExpose();
+
+        /* Wait for activate complete */
+        DEBUGTRACE( "IActivateCallback: waiting for semaphore\n");
+        SDL_SemWait(ActivateSem);
+    }
+}
+
+SDL_bool SDL_WebOsEventRegisterActivateCallback(SDL_WebOsActivateCb Callback, void* Data)
+{
+    int i;
+    for (i = 0; i < MAX_ACTIVATE_CALLBACK; i++) {
+        if (!ActivateCallback[i]) {
+            ActivateCallback[i]     = Callback;
+            ActivateCallbackData[i] = Data;
+
+            /* Ok to call this multiple times */
+            NApp_RegisterActivateCb(IActivateCallback, 0);
+
+            return SDL_TRUE;
+        }
+    }
+
+    return SDL_FALSE;
+}
+
+
+static void IFocusedCb(int Focused)
+{
+    DEBUGTRACE( "IFocusedCb %d\n", Focused);
+
+    if (FocusedCallback) {
+        FocusedCallback(FocusedCallbackData, Focused ? SDL_TRUE : SDL_FALSE);
+    }
+}
+
+SDL_bool SDL_WebOsEventRegisterFocusedCallback(SDL_WebOsFocusedCb Callback, void* Data)
+{
+    FocusedCallback = Callback;
+    FocusedCallbackData = Data;
+
+    NApp_RegisterFocusedCb(IFocusedCb);
+
+    return SDL_TRUE;
+}
+
+static void IPausedCb(int Paused)
+{
+    DEBUGTRACE( "IPaused %d\n", Paused);
+
+    int i;
+    for (i = 0; i < MAX_ACTIVATE_CALLBACK; i++) {
+        if (PausedCallback[i]) {
+            PausedCallback[i](PausedCallbackData[i], Paused ? SDL_TRUE : SDL_FALSE);
+        }
+    }
+}
+
+SDL_bool SDL_WebOsEventRegisterPausedCallback(SDL_WebOsPausedCb Callback, void* Data)
+{
+    int i;
+    for (i = 0; i < MAX_PAUSED_CALLBACK; i++) {
+        if (!PausedCallback[i]) {
+            PausedCallback[i]     = Callback;
+            PausedCallbackData[i] = Data;
+
+            /* Ok to call this multiple times */
+            NApp_RegisterPausedCb(IPausedCb);
+
+            return SDL_TRUE;
+        }
+    }
+
+    return SDL_FALSE;
+}
+
+void SDL_WebOsEventMainThreadHook(void)
+{
+    /* Enable this to profile app event poll rate */
+    if (0) {
+        static Uint32 LastCall = 0;
+        Uint32 Time = SDL_GetTicks();
+        if (LastCall) {
+            printf( "MainThreadHook delta: %d ms\n", Time - LastCall);
+        }
+        LastCall = Time;
+    }
+
+    if (ActivatePending) {
+
+        int i;
+        for (i = 0; i < MAX_ACTIVATE_CALLBACK; i++) {
+            if (ActivateCallback[i]) {
+                ActivateCallback[i](ActivateCallbackData[i], ActivateStatus);
+            }
+        }
+
+        ActivatePending = 0;
+
+        DEBUGTRACE( "SDL_WebOsEventHandleControl: posting to semaphore\n");
+
+        /* Signal completion */
+        SDL_SemPost(ActivateSem);
+    }
+}
+
+void SDL_WebOsEventOffscreenLock(void** Buffer, int* SizeInBytes)
+{
+    NApp_OffscreenLock(Buffer, SizeInBytes);
+}
+
+void SDL_WebOsEventOffscreenUnlock(SDL_bool Updated)
+{
+    NApp_OffscreenUnlock(Updated == SDL_TRUE);
+}
+
+static void IInputEventCallback()
+{
+    /* Always update joystick state. */
+    SDL_SYS_JoystickEvent();
+
+    if (InputEventCallback) {
+        InputEventCallback();
+    }
+}
+
+void SDL_WebOsEventLoop(SDL_WebOsInputEventCb Callback)
+{
+    NTRACE( "SDL_WebOsEventLoop\n");
+    InputEventCallback = Callback;
+
+    EventLoopEnabled = SDL_TRUE;
+
+    NApp_EnterEventLoop(IInputEventCallback);
+
+    NTRACE( "NApp event loop returned, cleaning up\n");
+
+    if (ActivateSem) {
+        SDL_DestroySemaphore(ActivateSem);
+        ActivateSem = NULL;
+    }
+}
+
+void SDL_WebOsEventLoopQuit()
+{
+    EventLoopEnabled = SDL_FALSE;
+
+    /* Release the thread if it's blocked */
+    if (ActivatePending) {
+        ActivatePending = 0;
+
+        SDL_SemPost(ActivateSem);
+    }
+
+    NApp_QuitEventLoop();
+}
+
+SDL_bool SDL_WebOsEventTranslateKey(SDL_keysym *keysym)
+{
+	// Scancode is the webos key definition, which is similar to the SDL key defines
+    int Key = keysym->scancode;
+
+    keysym->scancode = 0;
+    keysym->unicode = 0;
+
+    /* Map to SDL keys */
+    switch (Key) {
+    case NAPP_KEY_SHIFT:    keysym->sym = SDLK_LSHIFT;   break;
+    case NAPP_KEY_ALT:      keysym->sym = SDLK_RALT;     break;
+    case NAPP_KEY_CTRL:     keysym->sym = SDLK_RCTRL;    break;
+    case NAPP_KEY_OPTION:   keysym->sym = SDLK_RSHIFT;   break;
+
+    default:
+        if (SDL_TranslateUNICODE) {
+            // FIXME: may not make sense for *all* keys
+            keysym->unicode = Key;
+        }
+        if (Key >= 'A' && Key <= 'Z') {
+            // Unmap capitalized letters
+            Key += ('a' - 'A');
+        }
+        keysym->sym = Key;
+    }
+
+    return SDL_TRUE;
+}
+
+SDL_bool SDL_WebOsEventScreenTimeoutEnable(SDL_bool Enable)
+{
+    return NApp_ScreenTimeoutEnable(Enable);
+}
+
+SDL_bool SDL_WebOsEventSetOrientation(const char *Orientation)
+{
+    return NApp_SetOrientation(Orientation);
+}
+
+SDL_bool SDL_WebOsEventBannerMessagesEnable(SDL_bool Enable)
+{
+    return NApp_BannerMessagesEnable(Enable);
+}
+
+SDL_bool SDL_WebOsEventCustomPauseUiEnable(SDL_bool Enable)
+{
+    return NApp_CustomPauseUiEnable(Enable);
+}
+
+SDL_bool SDL_WebOsEventLSCall(const char *destinationUri, const char *payload)
+{
+	printf( "SDL_WebOsEventLSCall not implemented\n");
+	return SDL_FALSE;
+}
+
+void SDL_WebOsEventLayerEnable(SDL_bool Enable, int Fd)
+{
+    NApp_LayerEnable(Enable ? 1 : 0, Fd);
+}
+
+/* Deprecated */
+SDL_bool SDL_WebOsEventOverlayActive(void)
+{
+    DEBUGTRACE( "SDL_WebOsEventOverlayActive deprecated\n");
+    return SDL_FALSE;
+}
+
+SDL_bool SDL_WebOsEventOverlayChanged(void)
+{
+    DEBUGTRACE( "SDL_WebOsEventOverlayChanged deprecated\n");
+    return SDL_FALSE;
+}
+
+void SDL_WebOsEventOverlayLock(void** Buffer, int* Width, int* Height)
+{
+    DEBUGTRACE( "SDL_WebOsEventOverlayLock deprecated\n");
+}
+
+void SDL_WebOsEventOverlayUnlock(void)
+{
+    DEBUGTRACE( "SDL_WebOsEventOverlayunlock deprecated\n");
+}
diff -pruN libsdl-1.2/src/events/webos/integrated/SDL_WebOsTslib.c libsdl-1.2-palm/src/events/webos/integrated/SDL_WebOsTslib.c
--- libsdl-1.2/src/events/webos/integrated/SDL_WebOsTslib.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/integrated/SDL_WebOsTslib.c	2009-10-07 16:12:22.000000000 -0700
@@ -0,0 +1,98 @@
+#include <stdio.h>
+#include "SDL_mouse.h"
+#include "../tslib.h"
+#include "../SDL_WebOsEvent.h"
+
+#if 0
+#define DEBUGTRACE(format, ...) do {                            \
+            printf("[%s:%4d] ", __FILE__, __LINE__ );           \
+            printf(format, ## __VA_ARGS__);                     \
+        } while(0)
+#else
+#define DEBUGTRACE(format, ...) do {} while(0)
+#endif
+
+struct tsdev *ts_open(const char *dev_name, int nonblock)
+{
+    SDL_WebOsHandle Handle = SDL_WebOsEventOpen(SDL_WEBOS_TOUCHPANEL);
+    if (Handle) {
+        return (struct tsdev*)Handle;
+    }
+    return NULL;
+}
+
+int ts_config(struct tsdev * Handle)
+{
+    return 1;
+}
+
+int ts_close(struct tsdev * Handle)
+{
+    SDL_WebOsEventClose( (SDL_WebOsHandle)Handle );
+}
+
+int ts_fd(struct tsdev * Handle)
+{
+    return SDL_WebOsEventGetFd( (SDL_WebOsHandle)Handle ); 
+}
+
+static int IdMap[SDL_MAXMOUSE];
+
+static int Map(int Id, SDL_bool Allocate)
+{
+    int FirstFree = -1;
+    int i;
+
+    for (i = 0; i < SDL_MAXMOUSE; i++) {
+        if (IdMap[i] == Id) {
+            return i;
+        }
+        if (IdMap[i] == 0 && FirstFree == -1) {
+            FirstFree = i;
+        }
+    }
+
+    /* Didn't find a match */
+    if (Allocate) {
+        IdMap[FirstFree] = Id;
+        return FirstFree;
+    }
+    return -1;
+}
+
+int ts_read(struct tsdev * TsDev, struct ts_sample * TsSample, int MaxSample)
+{
+    SDL_WebOsHandle Handle = (SDL_WebOsHandle)TsDev;
+    struct input_event Events[1];
+
+    if (SDL_WebOsEventRead(Handle, Events, 1)) {
+
+        int Index;
+
+        TsSample->id        = Events[0].value;
+        TsSample->x         = Events[0].time.tv_sec;
+        TsSample->y         = Events[0].time.tv_usec;
+        TsSample->pressure  = Events[0].code;
+
+        /* Finger ids are arbitrary ints so we convert here to an index [0..MAX_MOUSE). */
+        Index = Map(TsSample->id, TsSample->pressure == 1);
+
+        if (Index >= 0) {
+            if (TsSample->pressure == 0) {
+                /* Up event, so remove this finger from the map */
+                IdMap[Index] = 0;
+            }
+
+            TsSample->id = Index;
+
+            DEBUGTRACE( "ts_read id %d x %d y %d pressure %d\n",
+                    TsSample->id, TsSample->x, TsSample->y, TsSample->pressure);
+
+            return 1;
+        }
+        else {
+            DEBUGTRACE( "ts_read: couldn't map finger id %d\n", TsSample->id);
+        }
+    }
+    return 0;
+}
diff -pruN libsdl-1.2/src/events/webos/napp/SDL_WebOsEvent.c libsdl-1.2-palm/src/events/webos/napp/SDL_WebOsEvent.c
--- libsdl-1.2/src/events/webos/napp/SDL_WebOsEvent.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/napp/SDL_WebOsEvent.c	2009-10-16 14:56:35.000000000 -0700
@@ -0,0 +1,89 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include "napp/NApp_c.h"
+#include "../SDL_WebOsEvent.h"
+
+static int      ControlFd = -1;
+static void*    Buffer;
+
+
+int SDL_WebOsEventInit(void)
+{
+    if (ControlFd < 0) {
+        ControlFd = NApp_Init(&Buffer);
+    }
+    return ControlFd;
+}
+
+void SDL_WebOsEventDeinit(void)
+{
+    Buffer = NULL;
+}
+
+void SDL_WebOsEventRegisterActivateCb(SDL_WebOsActivateCb Callback, void* UserData)
+{
+    NApp_RegisterActivateCb(Callback, UserData);
+}
+
+SDL_WebOsHandle SDL_WebOsEventOpen(SDL_WebOsDevice Device)
+{
+    if (ControlFd < 0) {
+        if (SDL_WebOsEventInit() < 0) {
+            return;
+        }
+    }
+    
+    printf( "SDL_WebOsEventOpen %d\n", Device);
+
+    NInputDevice NDevice; 
+    switch(Device) {
+    case SDL_WEBOS_KEYPAD:
+        NDevice = NKeypad;
+        break;
+    case SDL_WEBOS_ACCELEROMETER:
+        NDevice = NAccelerometer;
+        break;
+    case SDL_WEBOS_TOUCHPANEL:
+        NDevice = NTouchpanel;
+        break;
+    default:
+        return (SDL_WebOsHandle) 0;
+    }
+        
+    NApp_EnableEvent(NDevice, 1);
+    return (SDL_WebOsHandle) NApp_GetInputEventFd(NDevice);
+}  
+
+void SDL_WebOsEventClose(SDL_WebOsHandle Handle)
+{
+    // Empty.
+}
+
+int SDL_WebOsEventGetFd(SDL_WebOsHandle Handle)
+{
+    return (int)Handle;
+}
+
+int SDL_WebOsEventRead(SDL_WebOsHandle Handle, struct input_event Events[], int MaxEvents)
+{
+    return NApp_ReadEvents((int)Handle, Events, MaxEvents);
+}
+
+void SDL_WebOsEventMainThreadHook(void)
+{
+    NApp_HandleCommands();
+}
+
+void SDL_WebOsEventUpdateBuffer(void)
+{
+    NApp_UpdateBuffer();
+}
+
+/**
+ *  \return The shared buffer for rendering while playing nice
+**/
+void* SDL_WebOsEventGetBuffer(void)
+{
+    return Buffer;
+}
diff -pruN libsdl-1.2/src/events/webos/SDL_WebOsEvent.h libsdl-1.2-palm/src/events/webos/SDL_WebOsEvent.h
--- libsdl-1.2/src/events/webos/SDL_WebOsEvent.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/SDL_WebOsEvent.h	2009-11-24 00:14:18.000000000 -0800
@@ -0,0 +1,58 @@
+#ifndef SDL_WEBOSEVENT_H
+#define SDL_WEBOSEVENT_H
+
+/*
+ * This header defines the interface between SDL and webOS.
+ * Where possible, all webOS modifications to SDL should be implemented by functionality available here.
+ */
+
+#include "SDL_WebOsTypes.h"
+#include "SDL_keyboard.h"
+
+#define SDL_WEBOS_DEACTIVATED_FPS_CAP     1
+
+int     SDL_WebOsEventInit(void);
+void    SDL_WebOsEventQuit(void);
+
+/* Return SDL_TRUE if an event thread should be used */
+SDL_bool    SDL_WebOsEventUseThread(void);
+
+void    SDL_WebOsEventLoop(SDL_WebOsInputEventCb Callback);
+void    SDL_WebOsEventLoopQuit(void);
+
+/* Callback executes in the main thread */
+SDL_bool    SDL_WebOsEventRegisterActivateCallback(SDL_WebOsActivateCb Callback, void* Data);
+
+/* Callback executes in the event thread */
+SDL_bool    SDL_WebOsEventRegisterFocusedCallback(SDL_WebOsFocusedCb Callback, void* Data);
+SDL_bool    SDL_WebOsEventRegisterPausedCallback(SDL_WebOsPausedCb Callback, void* Data);
+
+void    SDL_WebOsEventMainThreadHook(void);
+
+void    SDL_WebOsEventOffscreenLock(void** Buffer, int* SizeInBytes);
+void    SDL_WebOsEventOffscreenUnlock(SDL_bool Updated);
+
+int     SDL_WebOsEventGetFd(SDL_WebOsHandle Handle);
+int     SDL_WebOsEventRead(SDL_WebOsHandle Handle, struct input_event* Events, int MaxEvents);
+
+SDL_WebOsHandle SDL_WebOsEventOpen(SDL_WebOsDevice Device);
+void            SDL_WebOsEventClose(SDL_WebOsHandle Handle);
+
+SDL_bool    SDL_WebOsEventTranslateKey(SDL_keysym *keysym);
+
+SDL_bool    SDL_WebOsEventScreenTimeoutEnable(SDL_bool Enable);
+SDL_bool    SDL_WebOsEventSetOrientation(const char *Orientation);
+SDL_bool 	SDL_WebOsEventBannerMessagesEnable(SDL_bool Enable);
+SDL_bool    SDL_WebOsEventCustomPauseUiEnable(SDL_bool Enable);
+SDL_bool    SDL_WebOsEventLSCall(const char *destinationUri, const char *payload);
+
+void        SDL_WebOsEventLayerEnable(SDL_bool Enable, int Fd);
+
+/* Deprecated */
+SDL_bool    SDL_WebOsEventOverlayActive(void);
+SDL_bool    SDL_WebOsEventOverlayChanged(void);
+void        SDL_WebOsEventOverlayLock(void** Buffer, int* Width, int* Height);
+void        SDL_WebOsEventOverlayUnlock(void);
+
+
+#endif
diff -pruN libsdl-1.2/src/events/webos/SDL_WebOsHook.c libsdl-1.2-palm/src/events/webos/SDL_WebOsHook.c
--- libsdl-1.2/src/events/webos/SDL_WebOsHook.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/SDL_WebOsHook.c	2009-11-20 18:32:09.000000000 -0800
@@ -0,0 +1,44 @@
+/*
+ * SDL_WebOsHook.cpp
+ *
+ *  Created on: Oct 22, 2009
+ *      Author: cstout
+ */
+
+#include "SDL_WebOsHook.h"
+#include "SDL_WebOsEvent.h"
+
+SDL_bool SDL_WebOsHookScreenTimeoutEnable(SDL_bool Enable)
+{
+    return SDL_WebOsEventScreenTimeoutEnable(Enable);
+}
+
+SDL_bool SDL_WebOsHookRegisterActivateCallback(SDL_WebOsActivateCb Callback, void* Data)
+{
+    return SDL_WebOsEventRegisterActivateCallback(Callback, Data);
+}
+
+SDL_bool SDL_WebOsHookRegisterPausedCallback(SDL_WebOsPausedCb Callback, void* Data)
+{
+    return SDL_WebOsEventRegisterPausedCallback(Callback, Data);
+}
+
+SDL_bool SDL_WebOsHookSetOrientation(const char *Orientation)
+{
+	return SDL_WebOsEventSetOrientation(Orientation);
+}
+
+SDL_bool SDL_WebOsHookBannerMessagesEnable(SDL_bool Enable)
+{
+    return SDL_WebOsEventBannerMessagesEnable(Enable);
+}
+
+SDL_bool SDL_WebOsHookCustomPauseUiEnable(SDL_bool Enable)
+{
+    return SDL_WebOsEventCustomPauseUiEnable(Enable);
+}
+
+SDL_bool SDL_WebOsHookLSCall(const char *destinationUri, const char *payload)
+{
+	return SDL_WebOsEventLSCall(destinationUri, payload);
+}
diff -pruN libsdl-1.2/src/events/webos/SDL_WebOsHook.h libsdl-1.2-palm/src/events/webos/SDL_WebOsHook.h
--- libsdl-1.2/src/events/webos/SDL_WebOsHook.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/SDL_WebOsHook.h	2009-11-20 18:32:09.000000000 -0800
@@ -0,0 +1,34 @@
+/*
+ * SDL_WebOsHook.h
+ *
+ *  Created on: Oct 22, 2009
+ *      Author: cstout
+ */
+
+#ifndef SDL_WEBOSHOOK_H_
+#define SDL_WEBOSHOOK_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This header defines the "hook" interface between SDL and other webOS components.
+ */
+
+#include "SDL_stdinc.h"
+#include "SDL_WebOsTypes.h"
+
+DECLSPEC SDL_bool 	SDL_WebOsHookScreenTimeoutEnable(SDL_bool Enable);
+DECLSPEC SDL_bool   SDL_WebOsHookRegisterActivateCallback(SDL_WebOsActivateCb Callback, void* Data);
+DECLSPEC SDL_bool   SDL_WebOsHookRegisterPausedCallback(SDL_WebOsPausedCb Callback, void* Data);
+DECLSPEC SDL_bool   SDL_WebOsHookSetOrientation(const char *Orientation);
+DECLSPEC SDL_bool 	SDL_WebOsHookBannerMessagesEnable(SDL_bool Enable);
+DECLSPEC SDL_bool   SDL_WebOsHookCustomPauseUiEnable(SDL_bool Enable);
+DECLSPEC SDL_bool   SDL_WebOsHookLSCall(const char *destinationUri, const char *payload);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SDL_WEBOSHOOK_H_ */
diff -pruN libsdl-1.2/src/events/webos/SDL_WebOsTypes.h libsdl-1.2-palm/src/events/webos/SDL_WebOsTypes.h
--- libsdl-1.2/src/events/webos/SDL_WebOsTypes.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/SDL_WebOsTypes.h	2009-11-11 14:51:30.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * SDL_WebOsTypes.h
+ *
+ *  Created on: Oct 27, 2009
+ *      Author: cstout
+ */
+
+#ifndef SDL_WEBOSTYPES_H_
+#define SDL_WEBOSTYPES_H_
+
+#ifdef __linux__
+#include <linux/input.h>
+#else
+struct input_event;
+#endif
+
+typedef void* SDL_WebOsHandle;
+
+typedef void (*SDL_WebOsActivateCb)(void* UserData, int Active);
+typedef void (*SDL_WebOsInputEventCb)(void);
+typedef void (*SDL_WebOsFocusedCb)(void* UserData, SDL_bool Focused);
+typedef void (*SDL_WebOsPausedCb)(void* UserData, SDL_bool Paused);
+
+typedef enum
+{
+    SDL_WEBOS_KEYPAD,
+    SDL_WEBOS_ACCELEROMETER,
+    SDL_WEBOS_TOUCHPANEL,
+
+} SDL_WebOsDevice;
+
+#endif /* SDL_WEBOSTYPES_H_ */
diff -pruN libsdl-1.2/src/events/webos/standalone/SDL_WebOsEvent.c libsdl-1.2-palm/src/events/webos/standalone/SDL_WebOsEvent.c
--- libsdl-1.2/src/events/webos/standalone/SDL_WebOsEvent.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/standalone/SDL_WebOsEvent.c	2009-11-16 22:21:35.000000000 -0800
@@ -0,0 +1,136 @@
+#include "hid/IncsPublic/HidLib.h"
+#include "../SDL_WebOsEvent.h"
+#include "../../../joystick/SDL_sysjoystick.h"
+
+#define XML_FILE     "/etc/hidd/HidPlugins.xml"
+
+
+static HidPluginSettings_t* pSettings = NULL;
+static int numPlugins = 0;
+
+
+SDL_bool SDL_WebOsEventUseThread(void)
+{
+    return SDL_FALSE;
+}
+
+int SDL_WebOsEventInit(void)
+{
+    PmErr retVal = kPmErrorUnknown;
+    
+    if (pSettings == NULL) {
+        retVal = HidAllocPluginSettings(XML_FILE, &pSettings, &numPlugins);
+
+        if (kPmErrorNone != retVal)
+        {
+            HidDbgMsg(DBG_ERR, "Error calling HidAllocPluginSettings\n");
+            pSettings = NULL;
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+void SDL_WebOsEventDeinit(void)
+{
+    if (NULL != pSettings)
+    {
+        HidFreePluginSettings(&pSettings, numPlugins);
+        pSettings = NULL;
+    }
+}
+
+void SDL_WebOsEventRegisterActivateCb(SDL_WebOsActivateCb Callback, void* UserData)
+{
+    // Always active
+    if (Callback) { 
+        SDL_PrivateAppActive(1, (SDL_APPACTIVE|SDL_APPINPUTFOCUS|SDL_APPMOUSEFOCUS));
+
+        Callback(UserData, 1);
+    }
+}
+
+void SDL_WebOsEventMainThreadHook(void)
+{
+    SDL_SYS_JoystickEvent();
+}
+
+SDL_WebOsHandle SDL_WebOsEventOpen(SDL_WebOsDevice Device)
+{
+    PmErr retVal = kPmErrorUnknown;
+    HidHandle_t* pHandle = NULL;    
+    
+    if (pSettings == NULL) {
+        // Ensure plugin settings are initialized.
+        if (SDL_WebOsEventInit() != 0) {
+            return NULL;
+        }
+    }
+
+    static const char* PluginName[] = { 
+            HID_KEYPAD,
+            HID_ACCELEROMETER,
+            HID_TOUCHPANEL
+    };
+    retVal = HidInitPluginTransport(PluginName[Device], pSettings, numPlugins, &pHandle);
+
+    if (kPmErrorNone != retVal)
+    {
+        HidDbgMsg(DBG_ERR, "Error calling HidInitPluginTransport\n");
+        HidFreePluginSettings(&pSettings, numPlugins);
+        pSettings = NULL;
+        return NULL;
+    }
+
+    return (SDL_WebOsHandle)pHandle;
+}  
+
+void SDL_WebOsEventClose(SDL_WebOsHandle Handle)
+{
+    if (NULL != Handle)
+    {
+        HidDestroyPluginTransport((HidHandle_t**)&Handle);
+    } 
+}
+
+int SDL_WebOsEventGetFd(SDL_WebOsHandle Handle)
+{
+    return HidHandleGetFd((HidHandle_t*)Handle);
+}
+
+int SDL_WebOsEventRead(SDL_WebOsHandle Handle, struct input_event* Events, int MaxEvents)
+{
+    return HidHandleReadInputEvent((HidHandle_t*)Handle, (InputEvent_t*)Events, MaxEvents);
+}
+
+SDL_bool SDL_WebOsEventTranslateKey(SDL_keysym *keysym)
+{
+    // Use default SDL key mapping stuff
+    return SDL_FALSE;
+}
+
+void SDL_WebOsEventOffscreenLock(void** Buffer, int* SizeInBytes)
+{
+    *Buffer = NULL;
+}
+
+void SDL_WebOsEventOffscreenUnlock(SDL_bool Updated)
+{
+    // Empty
+}
+
+void SDL_WebOsEventLoop(SDL_WebOsInputEventCb Callback)
+{
+    // Empty
+}
+
+void SDL_WebOsEventLoopQuit(void)
+{
+    // Empty
+}
+
+SDL_bool SDL_WebOsEventScreenTimeoutEnable(SDL_bool Enable)
+{
+    // TODO: implement this?
+}
diff -pruN libsdl-1.2/src/events/webos/standalone/SDL_WebOsTslib.c libsdl-1.2-palm/src/events/webos/standalone/SDL_WebOsTslib.c
--- libsdl-1.2/src/events/webos/standalone/SDL_WebOsTslib.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/standalone/SDL_WebOsTslib.c	2009-09-29 22:39:16.000000000 -0700
@@ -0,0 +1,240 @@
+#include <stdio.h>
+#include "hid/IncsPublic/HidLib.h"
+#include "SDL_mouse.h"
+#include "../tslib.h"
+#include "../SDL_WebOsEvent.h"
+
+#if 0
+#define DEBUGTRACE(format, ...) do {                            \
+            printf("[%s:%4d] ", __FILE__, __LINE__ );           \
+            printf(format, ## __VA_ARGS__);                     \
+        } while(0)
+#else
+#define DEBUGTRACE(format, ...) do {} while(0)
+#endif
+
+struct tsdev *ts_open(const char *dev_name, int nonblock)
+{
+    SDL_WebOsHandle Handle = SDL_WebOsEventOpen(SDL_WEBOS_TOUCHPANEL);
+    if (Handle) {
+        return (struct tsdev*)Handle;
+    }
+    return NULL;
+}
+
+int ts_config(struct tsdev * Handle)
+{
+    return 1;
+}
+
+int ts_close(struct tsdev * Handle)
+{
+    SDL_WebOsEventClose( (SDL_WebOsHandle)Handle );
+}
+
+int ts_fd(struct tsdev * Handle)
+{
+    return SDL_WebOsEventGetFd( (SDL_WebOsHandle)Handle ); 
+}
+
+
+#define MAX_EVENTS              32
+#define UNINIT_PRESSURE         (~0)
+
+#ifdef TSLIB_MULTITOUCH
+#define SAMPLE_WHICH(CurSample)    (CurSample->id)
+#else
+#define SAMPLE_WHICH(CurSample)    (0)
+#endif
+
+static struct ts_sample Samples[MAX_EVENTS];
+static int              SampleIndex = 0;
+static int              PendingSamples = 0;
+struct ts_sample*       CurSample = NULL;
+static int              Ignore = 0;
+static int              Finger[SDL_MAXMOUSE]; // tracks finger ids (0 if finger is not down)
+static int              Pressure[SDL_MAXMOUSE]; // tracks finger ids (0 if finger is not down)
+
+
+static void SampleEnd(void)
+{
+    if (CurSample != NULL && SAMPLE_WHICH(CurSample) != -1 && CurSample->pressure != UNINIT_PRESSURE) {
+        // We have a valid sample - ship it
+        PendingSamples++;
+    }
+    CurSample = NULL;
+}
+
+static void SampleStart(void)
+{
+    SampleEnd();
+    CurSample = &Samples[PendingSamples];
+    CurSample->pressure = UNINIT_PRESSURE;
+    CurSample->x = 0;
+    CurSample->y = 0;
+}
+
+int ts_read(struct tsdev * TsDev, struct ts_sample * TsSample, int MaxSample)
+{
+    SDL_WebOsHandle Handle = (SDL_WebOsHandle)TsDev;
+
+    if (PendingSamples == 0) {
+
+        // If we were in the middle of producing a sample, make sure we pick up where we left off!
+        if (CurSample != NULL) {
+            memcpy(&Samples[0], CurSample, sizeof(struct ts_sample));
+            CurSample = &Samples[0];
+        }
+        
+        fd_set fdset;
+        struct timeval TvZero = {0,0};
+        
+        FD_ZERO(&fdset);
+        FD_SET(ts_fd(TsDev), &fdset);
+        
+        // Assume we are non-blocking and check for socket data
+        if (select(ts_fd(TsDev) + 1, &fdset, NULL, NULL, &TvZero) > 0) {
+
+            struct input_event HidEvents[MAX_EVENTS];
+
+            int MaxEvent = sizeof(HidEvents)/sizeof(HidEvents[0]);            
+            int NumEvent = SDL_WebOsEventRead(Handle, HidEvents, MaxEvent);
+            
+            DEBUGTRACE( "WebOsTslib read %d events\n", NumEvent);
+
+            int i;
+            for (i = 0; i < NumEvent; i++) {
+                switch (HidEvents[i].type) {
+                    case EV_KEY:
+                        if (!Ignore) {
+                            //printf( "got EV_KEY\n");
+                            switch (HidEvents[i].code) {
+                            case BTN_TOUCH:
+                                DEBUGTRACE( "BTN_TOUCH %d\n", HidEvents[i].value);
+                                if (Pressure[SAMPLE_WHICH(CurSample)] == UNINIT_PRESSURE && HidEvents[i].value == 0) {
+                                    // This can occur when we max out on fingers 
+                                    DEBUGTRACE( "Ignoring release without previous press\n");
+                                }
+                                else {
+                                    Pressure[SAMPLE_WHICH(CurSample)] = CurSample->pressure = HidEvents[i].value;
+                                }
+                                
+                                if (HidEvents[i].value == 0) {
+                                    // Finger is complete
+                                    Finger[SAMPLE_WHICH(CurSample)] = 0;
+                                }
+                                break;
+                                
+                            default:
+                                DEBUGTRACE( "ts_read: unknown EV_KEY code %d\n", HidEvents[i].code);
+                                break;
+                            }
+                        }
+                        break;
+
+                    case EV_ABS:
+                        if (!Ignore) {
+                            DEBUGTRACE( "got EV_ABS  %s %d\n",
+                                    HidEvents[i].code == ABS_X ? "ABS_X" : (HidEvents[i].code == ABS_Y ? "ABS_Y" : "ABS_PRESSURE"),
+                                    HidEvents[i].value);
+                            
+                            switch (HidEvents[i].code) {
+                            case ABS_X:
+                                CurSample->x = HidEvents[i].value;
+                                break;
+                            case ABS_Y:
+                                CurSample->y = HidEvents[i].value;
+                                break;    
+                            case ABS_PRESSURE:
+                                //DEBUGTRACE( "ABS_PRESSURE\n");
+                                break;
+                            default:
+                                DEBUGTRACE( "ts_read: unknown EV_ABS code %d\n", HidEvents[i].code);
+                                break;
+                            }
+                        }
+                        break;
+
+                    case EV_FINGERID:
+                        DEBUGTRACE( "got EV_FINGERID %d %d\n", HidEvents[i].value, HidEvents[i].code);
+                        int Id = HidEvents[i].value * 1000 + HidEvents[i].code;
+                        
+                        // Assume we can handle this finger
+                        Ignore = 0;
+                        SampleStart();
+                        
+#ifndef TSLIB_MULTITOUCH
+                        // Ignore this finger if we're already tracking one
+                        if (Finger[0] == 0) {
+                            Finger[0] = Id;
+                        }
+                        else if (Finger[0] == Id) {
+                            CurSample->pressure = Pressure[0];
+                        }
+                        else {
+                            DEBUGTRACE( "ignoring multitouch finger\n");
+                            Ignore = 1;
+                            break;
+                        }                        
+#else
+                        CurSample->id = -1;
+                        
+                        // Is this a finger we're already tracking or a new one?
+                        int Free = -1;
+                        int i;
+                        for (i = 0; i < sizeof(Finger)/sizeof(Finger[0]); i++) {
+                            if (Finger[i] == Id) {
+                                // Found it; retrieve the pressure state
+                                CurSample->id = i;
+                                CurSample->pressure = Pressure[i];
+                                break;
+                            }
+                            else if (Free == -1 && Finger[i] == 0) {
+                                Free = i;
+                            }
+                        }
+                        
+                        if (CurSample->id == -1) {
+                            if (Free == -1) {
+                                DEBUGTRACE("*** Couldn't find a free finger %d %d %d %d %d\n",
+                                        Finger[0], Finger[1], Finger[2], Finger[3], Finger[4]);
+                                Ignore = 1;
+                                break;
+                            }
+                            Finger[Free] = Id;
+                            Pressure[Free] = CurSample->pressure = UNINIT_PRESSURE;
+                            CurSample->id = Free;                            
+                        }
+                        DEBUGTRACE( "using id %d\n", CurSample->id);
+#endif                        
+                        break;
+                        
+                    case EV_SYN:
+                        DEBUGTRACE( "got EV_SYN\n");
+                        SampleEnd();
+                        break;
+
+                    default:
+                        DEBUGTRACE( "got type %d\n", HidEvents[i].type);
+                        break;
+                }
+                        
+            }
+        }
+        
+        SampleIndex = 0;
+    }
+    
+    if (PendingSamples) {
+        *TsSample = Samples[SampleIndex++];
+#ifdef TSLIB_MULTITOUCH
+        DEBUGTRACE( "Returning sample id %d x %d y %d pressure %d\n", TsSample->id, TsSample->x, TsSample->y, TsSample->pressure);
+#else        
+        DEBUGTRACE( "Returning sample x %d y %d pressure %d\n", TsSample->x, TsSample->y, TsSample->pressure);
+#endif        
+        PendingSamples--;
+        return 1;
+    }       
+
+    return 0;
+}
diff -pruN libsdl-1.2/src/events/webos/tslib.h libsdl-1.2-palm/src/events/webos/tslib.h
--- libsdl-1.2/src/events/webos/tslib.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/events/webos/tslib.h	2009-06-24 08:31:04.000000000 -0700
@@ -0,0 +1,99 @@
+#ifndef _TSLIB_H_
+#define _TSLIB_H_
+/*
+ *  tslib/src/tslib.h
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the LGPL.
+ *
+ * $Id: tslib.h,v 1.4 2005/02/26 01:47:23 kergoth Exp $
+ *
+ * Touch screen library interface definitions.
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#include <stdarg.h>
+#include <sys/time.h>
+
+#ifdef WIN32
+  #define TSIMPORT __declspec(dllimport)
+  #define TSEXPORT __declspec(dllexport)
+  #define TSLOCAL
+#else
+  #define TSIMPORT
+  #ifdef GCC_HASCLASSVISIBILITY
+    #define TSEXPORT __attribute__ ((visibility("default")))
+    #define TSLOCAL __attribute__ ((visibility("hidden")))
+  #else
+    #define TSEXPORT
+    #define TSLOCAL
+  #endif
+#endif
+
+#ifdef TSLIB_INTERNAL
+  #define TSAPI TSEXPORT
+#else
+  #define TSAPI TSIMPORT
+#endif // TSLIB_INTERNAL
+
+struct tsdev;
+
+//PALM
+#define TSLIB_MULTITOUCH
+
+struct ts_sample {
+#ifdef TSLIB_MULTITOUCH
+    int     id;
+#endif    
+	int		x;
+	int		y;
+	unsigned int	pressure;
+	struct timeval	tv;
+};
+
+/*
+ * Close the touchscreen device, free all resources.
+ */
+TSAPI int ts_close(struct tsdev *);
+
+/*
+ * Configure the touchscreen device.
+ */
+TSAPI int ts_config(struct tsdev *);
+
+/*
+ * Change this hook to point to your custom error handling function.
+ */
+extern TSAPI int (*ts_error_fn)(const char *fmt, va_list ap);
+
+/*
+ * Returns the file descriptor in use for the touchscreen device.
+ */
+TSAPI int ts_fd(struct tsdev *);
+
+/*
+ * Load a filter/scaling module
+ */
+TSAPI int ts_load_module(struct tsdev *, const char *mod, const char *params);
+
+/*
+ * Open the touchscreen device.
+ */
+TSAPI struct tsdev *ts_open(const char *dev_name, int nonblock);
+
+/*
+ * Return a scaled touchscreen sample.
+ */
+TSAPI int ts_read(struct tsdev *, struct ts_sample *, int);
+
+/*
+ * Returns a raw, unscaled sample from the touchscreen.
+ */
+TSAPI int ts_read_raw(struct tsdev *, struct ts_sample *, int);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _TSLIB_H_ */
diff -pruN libsdl-1.2/src/haptic/linux/SDL_syshaptic.c libsdl-1.2-palm/src/haptic/linux/SDL_syshaptic.c
--- libsdl-1.2/src/haptic/linux/SDL_syshaptic.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/haptic/linux/SDL_syshaptic.c	2009-10-21 21:40:11.000000000 -0700
@@ -0,0 +1,1032 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_LINUX
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h"     /* For the real SDL_Joystick */
+//#include "../../joystick/linux/SDL_sysjoystick_c.h"     /* For joystick hwdata */
+
+#include <unistd.h>             /* close */
+#include <linux/input.h>        /* Force feedback linux stuff. */
+#include <fcntl.h>              /* O_RDWR */
+#include <limits.h>             /* INT_MAX */
+#include <errno.h>              /* errno, strerror */
+#include <math.h>               /* atan2 */
+
+
+/*Begin Palm Vibrate*/
+#include "PalmVibe.h"
+/*End Palm Vibrate*/
+
+
+/* Just in case. */
+#ifndef M_PI
+#  define M_PI     3.14159265358979323846
+#endif
+
+
+#define MAX_HAPTICS  32         /* It's doubtful someone has more then 32 evdev */
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+    char *fname;                /* Dev path name (like /dev/input/event1) */
+    SDL_Haptic *haptic;         /* Assosciated haptic. */
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+    int fd;                     /* File descriptor of the device. */
+    char *fname;                /* Points to the name in SDL_hapticlist. */
+};
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+    struct ff_effect effect;    /* The linux kernel effect structure. */
+};
+
+
+
+#define test_bit(nr, addr) \
+   (((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+#define EV_TEST(ev,f) \
+   if (test_bit((ev), features)) ret |= (f);
+/*
+ * Test whether a device has haptic properties.
+ * Returns available properties or 0 if there are none.
+ */
+static int
+EV_IsHaptic(int fd)
+{
+    unsigned int ret;
+    unsigned long features[1 + FF_MAX / sizeof(unsigned long)];
+
+    /* Ask device for what it has. */
+    ret = 0;
+    if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(features)), features) < 0) {
+        SDL_SetError("Haptic: Unable to get device's features: %s",
+                     strerror(errno));
+        return -1;
+    }
+
+    /* Convert supported features to SDL_HAPTIC platform-neutral features. */
+    EV_TEST(FF_CONSTANT, SDL_HAPTIC_CONSTANT);
+    EV_TEST(FF_SINE, SDL_HAPTIC_SINE);
+    EV_TEST(FF_SQUARE, SDL_HAPTIC_SQUARE);
+    EV_TEST(FF_TRIANGLE, SDL_HAPTIC_TRIANGLE);
+    EV_TEST(FF_SAW_UP, SDL_HAPTIC_SAWTOOTHUP);
+    EV_TEST(FF_SAW_DOWN, SDL_HAPTIC_SAWTOOTHDOWN);
+    EV_TEST(FF_RAMP, SDL_HAPTIC_RAMP);
+    EV_TEST(FF_SPRING, SDL_HAPTIC_SPRING);
+    EV_TEST(FF_FRICTION, SDL_HAPTIC_FRICTION);
+    EV_TEST(FF_DAMPER, SDL_HAPTIC_DAMPER);
+    EV_TEST(FF_INERTIA, SDL_HAPTIC_INERTIA);
+    EV_TEST(FF_CUSTOM, SDL_HAPTIC_CUSTOM);
+    EV_TEST(FF_GAIN, SDL_HAPTIC_GAIN);
+    EV_TEST(FF_AUTOCENTER, SDL_HAPTIC_AUTOCENTER);
+
+    /* Return what it supports. */
+    return ret;
+}
+
+
+/*
+ * Tests whether a device is a mouse or not.
+ */
+static int
+EV_IsMouse(int fd)
+{
+    unsigned long argp[40];
+
+    /* Ask for supported features. */
+    if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(argp)), argp) < 0) {
+        return -1;
+    }
+
+    /* Currently we only test for BTN_MOUSE which can give fake positives. */
+    if (test_bit(BTN_MOUSE, argp) != 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+/*
+ * Initializes the haptic subsystem by finding available devices.
+ * (Reimplemented with VibeTonz API)
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+//    const char joydev_pattern[] = "/dev/input/event%d";
+//    dev_t dev_nums[MAX_HAPTICS];
+//    char path[PATH_MAX];
+//    struct stat sb;
+//    int fd;
+//    int i, j, k;
+//    int duplicate;
+//    /* 
+//     * Limit amount of checks to MAX_HAPTICS since we may or may not have
+//     * permission to some or all devices.
+//     */
+//    i = 0;
+//    for (j = 0; j < MAX_HAPTICS; ++j) {
+//
+//        snprintf(path, PATH_MAX, joydev_pattern, i++);
+//
+//        /* check to see if file exists */
+//        if (stat(path, &sb) != 0)
+//            break;
+//
+//        /* check for duplicates */
+//        duplicate = 0;
+//        for (k = 0; (k < numhaptics) && !duplicate; ++k) {
+//            if (sb.st_rdev == dev_nums[k]) {
+//                duplicate = 1;
+//            }
+//        }
+//        if (duplicate) {
+//            continue;
+//        }
+//
+//        /* try to open */
+//        fd = open(path, O_RDWR, 0);
+//        if (fd < 0)
+//            continue;
+//
+//#ifdef DEBUG_INPUT_EVENTS
+//        printf("Checking %s\n", path);
+//#endif
+//
+//        /* see if it works */
+//        if (EV_IsHaptic(fd) > 0) {
+//            SDL_hapticlist[numhaptics].fname = SDL_strdup(path);
+//            SDL_hapticlist[numhaptics].haptic = NULL;
+//            dev_nums[numhaptics] = sb.st_rdev;
+//            ++numhaptics;
+//        }
+//        close(fd);
+//    }
+    return InitVibeSystem();
+}
+
+
+/*
+ * Gets the name from a file descriptor.
+ */
+static const char *
+SDL_SYS_HapticNameFromFD(int fd)
+{
+    static char namebuf[128];
+
+    /* We use the evdev name ioctl. */
+    if (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) {
+        return NULL;
+    }
+
+    return namebuf;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+    int fd;
+    const char *name;
+
+    /* Open the haptic device. */
+    name = NULL;
+    fd = open(SDL_hapticlist[index].fname, O_RDONLY, 0);
+
+    if (fd >= 0) {
+
+        name = SDL_SYS_HapticNameFromFD(fd);
+        if (name == NULL) {
+            /* No name found, return device character device */
+            name = SDL_hapticlist[index].fname;
+        }
+    }
+    close(fd);
+
+    return name;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromFD(SDL_Haptic * haptic, int fd)
+{
+    const char *name;
+
+    /* Allocate the hwdata */
+    haptic->hwdata = (struct haptic_hwdata *)
+        SDL_malloc(sizeof(*haptic->hwdata));
+    if (haptic->hwdata == NULL) {
+        SDL_OutOfMemory();
+        goto open_err;
+    }
+    SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+    /* Set the data. */
+    haptic->hwdata->fd = fd;
+//   haptic->supported = EV_IsHaptic(fd);
+    haptic->supported |= SDL_HAPTIC_CONSTANT; /*Palm Edit: Hardcoded to only support a constant effect for now*/
+    haptic->naxes = 2;          /* Hardcoded for now, not sure if it's possible to find out. */
+
+    /* Set the effects */
+//    if (ioctl(fd, EVIOCGEFFECTS, &haptic->neffects) < 0) {
+//        SDL_SetError("Haptic: Unable to query device memory: %s",
+//                     strerror(errno));
+//        goto open_err;
+//    }
+    
+    haptic->neffects = GetNumMaxEffects(); /*Palm Edit: Get maximum number of effects from VibeTonz.*/
+    haptic->nplaying = haptic->neffects;        /* Linux makes no distinction. */
+    haptic->effects = (struct haptic_effect *)
+        SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+    if (haptic->effects == NULL) {
+        SDL_OutOfMemory();
+        goto open_err;
+    }
+    /* Clear the memory */
+    SDL_memset(haptic->effects, 0,
+               sizeof(struct haptic_effect) * haptic->neffects);
+
+    return 0;
+
+    /* Error handling */
+  open_err:
+    close(fd);
+    if (haptic->hwdata != NULL) {
+        free(haptic->hwdata);
+        haptic->hwdata = NULL;
+    }
+    return -1;
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+    int devHandle;
+    int ret;
+
+    /* Open the character device */
+//    fd = open(SDL_hapticlist[haptic->index].fname, O_RDWR, 0);
+//    if (fd < 0) {
+//        SDL_SetError("Haptic: Unable to open %s: %s",
+//                     SDL_hapticlist[haptic->index], strerror(errno));
+//        return -1;
+//    }
+
+    ret = OpenDevice(&devHandle);
+    if (ret < 0){
+	return -1;
+    }
+
+    /* Try to create the haptic. */
+    ret = SDL_SYS_HapticOpenFromFD(haptic, devHandle); /* Already closes on error. */
+    if (ret < 0) {
+        return -1;
+    }
+
+    /* Set the fname. */
+    haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+    return 0;
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+    int fd;
+    int i;
+
+    for (i = 0; i < SDL_numhaptics; i++) {
+
+        /* Open the device. */
+        fd = open(SDL_hapticlist[i].fname, O_RDWR, 0);
+        if (fd < 0) {
+            SDL_SetError("Haptic: Unable to open %s: %s",
+                         SDL_hapticlist[i], strerror(errno));
+            return -1;
+        }
+
+        /* Is it a mouse? */
+        if (EV_IsMouse(fd)) {
+            close(fd);
+            return i;
+        }
+
+        close(fd);
+    }
+
+    return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+//int
+//SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+//{
+//    return EV_IsHaptic(joystick->hwdata->fd);
+//}
+//
+//
+///*
+// * Checks to see if the haptic device and joystick and in reality the same.
+// */
+//int
+//SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+//{
+//    /* We are assuming linux is using evdev which should trump the old
+//     * joystick methods. */
+//    if (SDL_strcmp(joystick->hwdata->fname, haptic->hwdata->fname) == 0) {
+//        return 1;
+//    }
+//    return 0;
+//}
+//
+//
+///*
+// * Opens a SDL_Haptic from a SDL_Joystick.
+// */
+//int
+//SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+//{
+//    int i;
+//    int fd;
+//    int ret;
+//
+//
+//    /* Find the joystick in the haptic list. */
+//    for (i = 0; i < MAX_HAPTICS; i++) {
+//        if (SDL_hapticlist[i].fname != NULL) {
+//            if (SDL_strcmp(SDL_hapticlist[i].fname, joystick->hwdata->fname)
+//                == 0) {
+//                haptic->index = i;
+//                break;
+//            }
+//        }
+//    }
+//    if (i >= MAX_HAPTICS) {
+//        SDL_SetError("Haptic: Joystick doesn't have Haptic capabilities");
+//        return -1;
+//    }
+//
+//    fd = open(joystick->hwdata->fname, O_RDWR, 0);
+//    if (fd < 0) {
+//        SDL_SetError("Haptic: Unable to open %s: %s",
+//                     joystick->hwdata->fname, strerror(errno));
+//        return -1;
+//    }
+//    ret = SDL_SYS_HapticOpenFromFD(haptic, fd); /* Already closes on error. */
+//    if (ret < 0) {
+//        return -1;
+//    }
+//
+//    haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+//    return 0;
+//}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+    if (haptic->hwdata) {
+
+        /* Free effects. */
+        SDL_free(haptic->effects);
+        haptic->effects = NULL;
+        haptic->neffects = 0;
+
+        /* Clean up */
+//        close(haptic->hwdata->fd);
+        CloseDevice(haptic->hwdata->fd);
+
+        /* Free */
+        SDL_free(haptic->hwdata);
+        haptic->hwdata = NULL;
+    }
+
+    /* Clear the rest. */
+    SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+    int i;
+    Quit();
+    for (i = 0; SDL_hapticlist[i].fname != NULL; i++) {
+        /* Opened and not closed haptics are leaked, this is on purpose.
+         * Close your haptic devices after usage. */
+        SDL_free(SDL_hapticlist[i].fname);
+    }
+    SDL_hapticlist[0].fname = NULL;
+}
+
+
+/*
+ * Converts an SDL button to a ff_trigger button.
+ */
+static Uint16
+SDL_SYS_ToButton(Uint16 button)
+{
+    Uint16 ff_button;
+
+    ff_button = 0;
+
+    /*
+     * Not sure what the proper syntax is because this actually isn't implemented
+     * in the current kernel from what I've seen (2.6.26).
+     */
+    if (button != 0) {
+        ff_button = BTN_GAMEPAD + button - 1;
+    }
+
+    return ff_button;
+}
+
+
+/*
+ * Returns the ff_effect usable direction from a SDL_HapticDirection.
+ */
+static Uint16
+SDL_SYS_ToDirection(SDL_HapticDirection * dir)
+{
+    Uint32 tmp;
+    float f;                    /* Ideally we'd use fixed point math instead of floats... */
+
+    switch (dir->type) {
+    case SDL_HAPTIC_POLAR:
+        /* Linux directions are inverted. */
+        tmp = (((18000 + dir->dir[0]) % 36000) * 0xFFFF) / 36000;
+        return (Uint16) tmp;
+
+    case SDL_HAPTIC_CARTESIAN:
+        /* We must invert "x" and "y" to go clockwise. */
+        f = atan2(dir->dir[0], dir->dir[1]);
+        tmp = (int) (f * 18000. / M_PI) % 36000;
+        tmp = (tmp * 0xFFFF) / 36000;
+        return (Uint16) tmp;
+
+    case SDL_HAPTIC_SPHERICAL:
+        tmp = (36000 - dir->dir[0]) + 27000;    /* Convert to polars */
+        tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000;
+        return (Uint16) tmp;
+
+    default:
+        SDL_SetError("Haptic: Unsupported direction type.");
+        return (Uint16) - 1;
+    }
+
+    return 0;
+}
+
+
+#define  CLAMP(x)    (((x) > 32767) ? 32767 : x)
+/*
+ * Initializes the linux effect struct from a haptic_effect.
+ * Values above 32767 (for unsigned) are unspecified so we must clamp.
+ */
+static int
+SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
+{
+    Uint32 tmp;
+    SDL_HapticConstant *constant;
+    SDL_HapticPeriodic *periodic;
+    SDL_HapticCondition *condition;
+    SDL_HapticRamp *ramp;
+
+    /* Clear up */
+    SDL_memset(dest, 0, sizeof(struct ff_effect));
+
+    switch (src->type) {
+    case SDL_HAPTIC_CONSTANT:
+        constant = &src->constant;
+
+        /* Header */
+        dest->type = FF_CONSTANT;
+        dest->direction = SDL_SYS_ToDirection(&constant->direction);
+        if (dest->direction == (Uint16) - 1)
+            return -1;
+
+        /* Replay */
+        dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
+            0 : CLAMP(constant->length);
+        dest->replay.delay = CLAMP(constant->delay);
+
+        /* Trigger */
+        dest->trigger.button = SDL_SYS_ToButton(constant->button);
+        dest->trigger.interval = CLAMP(constant->interval);
+
+        /* Constant */
+        dest->u.constant.level = constant->level;
+
+        /* Envelope */
+        dest->u.constant.envelope.attack_length =
+            CLAMP(constant->attack_length);
+        dest->u.constant.envelope.attack_level =
+            CLAMP(constant->attack_level);
+        dest->u.constant.envelope.fade_length = CLAMP(constant->fade_length);
+        dest->u.constant.envelope.fade_level = CLAMP(constant->fade_level);
+
+        break;
+
+    case SDL_HAPTIC_SINE:
+    case SDL_HAPTIC_SQUARE:
+    case SDL_HAPTIC_TRIANGLE:
+    case SDL_HAPTIC_SAWTOOTHUP:
+    case SDL_HAPTIC_SAWTOOTHDOWN:
+        periodic = &src->periodic;
+
+        /* Header */
+        dest->type = FF_PERIODIC;
+        dest->direction = SDL_SYS_ToDirection(&periodic->direction);
+        if (dest->direction == (Uint16) - 1)
+            return -1;
+
+        /* Replay */
+        dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ?
+            0 : CLAMP(periodic->length);
+        dest->replay.delay = CLAMP(periodic->delay);
+
+        /* Trigger */
+        dest->trigger.button = SDL_SYS_ToButton(periodic->button);
+        dest->trigger.interval = CLAMP(periodic->interval);
+
+        /* Periodic */
+        if (periodic->type == SDL_HAPTIC_SINE)
+            dest->u.periodic.waveform = FF_SINE;
+        else if (periodic->type == SDL_HAPTIC_SQUARE)
+            dest->u.periodic.waveform = FF_SQUARE;
+        else if (periodic->type == SDL_HAPTIC_TRIANGLE)
+            dest->u.periodic.waveform = FF_TRIANGLE;
+        else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)
+            dest->u.periodic.waveform = FF_SAW_UP;
+        else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)
+            dest->u.periodic.waveform = FF_SAW_DOWN;
+        dest->u.periodic.period = CLAMP(periodic->period);
+        dest->u.periodic.magnitude = periodic->magnitude;
+        dest->u.periodic.offset = periodic->offset;
+        /* Phase is calculated based of offset from period and then clamped. */
+        tmp = ((periodic->phase % 36000) * dest->u.periodic.period) / 36000;
+        dest->u.periodic.phase = CLAMP(tmp);
+
+        /* Envelope */
+        dest->u.periodic.envelope.attack_length =
+            CLAMP(periodic->attack_length);
+        dest->u.periodic.envelope.attack_level =
+            CLAMP(periodic->attack_level);
+        dest->u.periodic.envelope.fade_length = CLAMP(periodic->fade_length);
+        dest->u.periodic.envelope.fade_level = CLAMP(periodic->fade_level);
+
+        break;
+
+    case SDL_HAPTIC_SPRING:
+    case SDL_HAPTIC_DAMPER:
+    case SDL_HAPTIC_INERTIA:
+    case SDL_HAPTIC_FRICTION:
+        condition = &src->condition;
+
+        /* Header */
+        if (condition->type == SDL_HAPTIC_SPRING)
+            dest->type = FF_SPRING;
+        else if (condition->type == SDL_HAPTIC_DAMPER)
+            dest->type = FF_DAMPER;
+        else if (condition->type == SDL_HAPTIC_INERTIA)
+            dest->type = FF_INERTIA;
+        else if (condition->type == SDL_HAPTIC_FRICTION)
+            dest->type = FF_FRICTION;
+        dest->direction = 0;    /* Handled by the condition-specifics. */
+
+        /* Replay */
+        dest->replay.length = (condition->length == SDL_HAPTIC_INFINITY) ?
+            0 : CLAMP(condition->length);
+        dest->replay.delay = CLAMP(condition->delay);
+
+        /* Trigger */
+        dest->trigger.button = SDL_SYS_ToButton(condition->button);
+        dest->trigger.interval = CLAMP(condition->interval);
+
+        /* Condition */
+        /* X axis */
+        dest->u.condition[0].right_saturation =
+            CLAMP(condition->right_sat[0]);
+        dest->u.condition[0].left_saturation = CLAMP(condition->left_sat[0]);
+        dest->u.condition[0].right_coeff = condition->right_coeff[0];
+        dest->u.condition[0].left_coeff = condition->left_coeff[0];
+        dest->u.condition[0].deadband = CLAMP(condition->deadband[0]);
+        dest->u.condition[0].center = condition->center[0];
+        /* Y axis */
+        dest->u.condition[1].right_saturation =
+            CLAMP(condition->right_sat[1]);
+        dest->u.condition[1].left_saturation = CLAMP(condition->left_sat[1]);
+        dest->u.condition[1].right_coeff = condition->right_coeff[1];
+        dest->u.condition[1].left_coeff = condition->left_coeff[1];
+        dest->u.condition[1].deadband = CLAMP(condition->deadband[1]);
+        dest->u.condition[1].center = condition->center[1];
+
+        /*
+         * There is no envelope in the linux force feedback api for conditions.
+         */
+
+        break;
+
+    case SDL_HAPTIC_RAMP:
+        ramp = &src->ramp;
+
+        /* Header */
+        dest->type = FF_RAMP;
+        dest->direction = SDL_SYS_ToDirection(&ramp->direction);
+        if (dest->direction == (Uint16) - 1)
+            return -1;
+
+        /* Replay */
+        dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ?
+            0 : CLAMP(ramp->length);
+        dest->replay.delay = CLAMP(ramp->delay);
+
+        /* Trigger */
+        dest->trigger.button = SDL_SYS_ToButton(ramp->button);
+        dest->trigger.interval = CLAMP(ramp->interval);
+
+        /* Ramp */
+        dest->u.ramp.start_level = ramp->start;
+        dest->u.ramp.end_level = ramp->end;
+
+        /* Envelope */
+        dest->u.ramp.envelope.attack_length = CLAMP(ramp->attack_length);
+        dest->u.ramp.envelope.attack_level = CLAMP(ramp->attack_level);
+        dest->u.ramp.envelope.fade_length = CLAMP(ramp->fade_length);
+        dest->u.ramp.envelope.fade_level = CLAMP(ramp->fade_level);
+
+        break;
+
+
+    default:
+        SDL_SetError("Haptic: Unknown effect type.");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect *effect,
+                        SDL_HapticEffect * base)
+{
+    //struct ff_effect *linux_effect;
+
+    /* Allocate the hardware effect */
+    effect->hweffect = (struct haptic_hweffect *)
+        SDL_malloc(sizeof(struct haptic_hweffect));
+    if (effect->hweffect == NULL) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+
+    /* Prepare the ff_effect */
+    //linux_effect = &effect->hweffect->effect;
+    //if (SDL_SYS_ToFFEffect(linux_effect, base) != 0) {
+    //    goto new_effect_err;
+    //}
+    //linux_effect->id = -1;      /* Have the kernel give it an id */
+
+    /* Upload the effect */ 
+    /* Palm edit: Does not fit design of Palm vibrate driver.*/
+    //if (ioctl(haptic->hwdata->fd, EVIOCSFF, linux_effect) < 0) {
+    //    SDL_SetError("Haptic: Error uploading effect to the device: %s",
+    //                 strerror(errno));
+    //    goto new_effect_err;
+    //}
+
+    return 0;
+
+  //new_effect_err:
+  //  free(effect->hweffect);
+  //  effect->hweffect = NULL;
+  //  return -1;
+}
+
+
+/*
+ * Updates an effect.
+ *
+ * Note: Dynamically updating the direction can in some cases force
+ * the effect to restart and run once.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect *effect,
+                           SDL_HapticEffect * data)
+{
+    struct ff_effect linux_effect;
+
+    /* Create the new effect */
+    if (SDL_SYS_ToFFEffect(&linux_effect, data) != 0) {
+        return -1;
+    }
+    linux_effect.id = effect->hweffect->effect.id;
+
+    /* See if it can be uploaded. */
+    if (ioctl(haptic->hwdata->fd, EVIOCSFF, &linux_effect) < 0) {
+        SDL_SetError("Haptic: Error updating the effect: %s",
+                     strerror(errno));
+        return -1;
+    }
+
+    /* Copy the new effect into memory. */
+    SDL_memcpy(&effect->hweffect->effect, &linux_effect,
+               sizeof(struct ff_effect));
+
+    return effect->hweffect->effect.id;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect *effect,
+                        Uint32 iterations)
+{
+//    struct input_event run;
+//
+//    /* Prepare to run the effect */
+//    run.type = EV_FF;
+//    run.code = effect->hweffect->effect.id;
+//    /* We don't actually have infinity here, so we just do INT_MAX which is pretty damn close. */
+//    run.value = (iterations > INT_MAX) ? INT_MAX : iterations;
+//
+//    if (write(haptic->hwdata->fd, (const void *) &run, sizeof(run)) < 0) {
+//        SDL_SetError("Haptic: Unable to run the effect: %s", strerror(errno));
+//        return -1;
+//    }
+	/*Palm Edit: Implement RunEffect using VibeTonz*/
+	/*Local VibeTonz variables used by RunEffect*/
+	int32_t rc;
+	int32_t effectHandle;
+	
+	if(SDL_SYS_HapticGetEffectStatus(haptic,effect) == 1){
+		return 0;
+	}
+
+	rc = PlayConstantEffect(
+			haptic->hwdata->fd,
+			effect->effect.constant.length,
+			effect->effect.constant.level,
+			effect->effect.constant.attack_length,
+			effect->effect.constant.attack_level,
+			effect->effect.constant.fade_length,
+			effect->effect.constant.fade_level,
+			&effectHandle
+			);
+
+	/*Palm edit: Added new field to effect structure to store effect handle from VibeTonz*/
+	effect->vibeEffectHandle = effectHandle;
+
+    return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect *effect)
+{
+//    struct input_event stop;
+//
+//    stop.type = EV_FF;
+//    stop.code = effect->hweffect->effect.id;
+//    stop.value = 0;
+//
+//    if (write(haptic->hwdata->fd, (const void *) &stop, sizeof(stop)) < 0) {
+//        SDL_SetError("Haptic: Unable to stop the effect: %s",
+//                     strerror(errno));
+//        return -1;
+//    }
+
+    /*Palm edit: Implement using VibeTonz*/
+    int rc;
+    rc = StopEffect(haptic->hwdata->fd,effect->vibeEffectHandle);
+    /*End Palm edit*/
+
+    return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect *effect)
+{
+    /*Palm Edit: This is not necessary for VibeTonz API*/
+    /*if (ioctl(haptic->hwdata->fd, EVIOCRMFF, effect->hweffect->effect.id) < 0) {
+        SDL_SetError("Haptic: Error removing the effect from the device: %s",
+                     strerror(errno));
+    }*/
+    SDL_free(effect->hweffect);
+    effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic,
+                              struct haptic_effect *effect)
+{
+#if 0                           /* Not supported atm. */
+    struct input_event ie;
+
+    ie.type = EV_FF;
+    ie.type = EV_FF_STATUS;
+    ie.code = effect->hweffect->effect.id;
+
+    if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+        SDL_SetError("Haptic: Error getting device status.");
+        return -1;
+    }
+
+    return 0;
+#endif
+    //return -1;
+
+    /*Palm Edit: Implemented EffectStatus using VibeTonz.*/
+    if(effect->vibeEffectHandle <= 0){
+	return -1;
+    }
+    
+    return GetEffectStatus(haptic->hwdata->fd, effect->vibeEffectHandle);
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+    /*Palm Edit: Not Supported*/ 
+    /*
+    struct input_event ie;
+
+    ie.type = EV_FF;
+    ie.code = FF_GAIN;
+    ie.value = (0xFFFFUL * gain) / 100;
+
+    if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+        SDL_SetError("Haptic: Error setting gain: %s", strerror(errno));
+        return -1;
+    }
+    */
+    return -1;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+    /*Palm Edit: Not Supported*/
+    /*
+    struct input_event ie;
+
+    ie.type = EV_FF;
+    ie.code = FF_AUTOCENTER;
+    ie.value = (0xFFFFUL * autocenter) / 100;
+
+    if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+        SDL_SetError("Haptic: Error setting autocenter: %s", strerror(errno));
+        return -1;
+    }
+    */
+    return -1;
+    
+}
+
+
+/*
+ * Pausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+    return -1;
+}
+
+
+/*
+ * Unpausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+    return -1;
+}
+
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+    int i, ret;
+
+    /* Linux does not support this natively so we have to loop. */
+    for (i = 0; i < haptic->neffects; i++) {
+        if (haptic->effects[i].hweffect != NULL) {
+            ret = SDL_SYS_HapticStopEffect(haptic, &haptic->effects[i]);
+            if (ret < 0) {
+                SDL_SetError
+                    ("Haptic: Error while trying to stop all playing effects.");
+                return -1;
+            }
+        }
+    }
+    return 0;
+}
+
+/*
+ * Palm Edit: Returns minimum duration of effect to be played
+ */
+int
+SDL_SYS_HapticMinDuration(SDL_Haptic * haptic){
+    return GetMinDuration(haptic->hwdata->fd);
+}
+
+/*
+ * Palm Edit: Returns maximum duration of effect to be played
+ */
+int
+SDL_SYS_HapticMaxDuration(SDL_Haptic * haptic){
+    return GetMaxDuration(haptic->hwdata->fd);
+}
+
+
+#endif /* SDL_HAPTIC_LINUX */
diff -pruN libsdl-1.2/src/haptic/SDL_haptic.c libsdl-1.2-palm/src/haptic/SDL_haptic.c
--- libsdl-1.2/src/haptic/SDL_haptic.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/haptic/SDL_haptic.c	2009-09-30 12:36:12.000000000 -0700
@@ -0,0 +1,724 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_syshaptic.h"
+/*Palm Edit: Excluded as it is not necessary for our purposes*/
+//#include "../joystick/SDL_joystick_c.h" /* For SDL_PrivateJoystickValid */
+
+
+Uint8 SDL_numhaptics = 0;
+SDL_Haptic **SDL_haptics = NULL;
+
+
+/*
+ * Initializes the Haptic devices.
+ */
+int
+SDL_HapticInit(void)
+{
+    int arraylen;
+    int status;
+
+    SDL_numhaptics = 0;
+    status = SDL_SYS_HapticInit();
+    if (status >= 0) {
+        arraylen = (status + 1) * sizeof(*SDL_haptics);
+        SDL_haptics = (SDL_Haptic **) SDL_malloc(arraylen);
+        if (SDL_haptics == NULL) {      /* Out of memory. */
+            SDL_numhaptics = 0;
+        } else {
+            SDL_memset(SDL_haptics, 0, arraylen);
+            SDL_numhaptics = status;
+        }
+        status = 0;
+    }
+
+    return status;
+}
+
+
+/*
+ * Checks to see if the haptic device is valid
+ */
+static int
+ValidHaptic(SDL_Haptic * haptic)
+{
+    int i;
+    int valid;
+
+    valid = 0;
+    if (haptic != NULL) {
+        for (i = 0; i < SDL_numhaptics; i++) {
+            if (SDL_haptics[i] == haptic) {
+                valid = 1;
+                break;
+            }
+        }
+    }
+
+    /* Create the error here. */
+    if (valid == 0) {
+        SDL_SetError("Haptic: Invalid haptic device identifier");
+    }
+
+    return valid;
+}
+
+
+/*
+ * Returns the number of available devices.
+ */
+int
+SDL_NumHaptics(void)
+{
+    return SDL_numhaptics;
+}
+
+
+/*
+ * Gets the name of a Haptic device by index.
+ */
+const char *
+SDL_HapticName(int device_index)
+{
+    if ((device_index < 0) || (device_index >= SDL_numhaptics)) {
+        SDL_SetError("Haptic: There are %d haptic devices available",
+                     SDL_numhaptics);
+        return NULL;
+    }
+    return SDL_SYS_HapticName(device_index);
+}
+
+
+/*
+ * Opens a Haptic device.
+ */
+SDL_Haptic *
+SDL_HapticOpen(int device_index)
+{
+    int i;
+    SDL_Haptic *haptic;
+
+    if ((device_index < 0) || (device_index >= SDL_numhaptics)) {
+        SDL_SetError("Haptic: There are %d haptic devices available",
+                     SDL_numhaptics);
+        return NULL;
+    }
+
+    /* If the haptic is already open, return it */
+    for (i = 0; SDL_haptics[i]; i++) {
+        if (device_index == SDL_haptics[i]->index) {
+            haptic = SDL_haptics[i];
+            ++haptic->ref_count;
+            return haptic;
+        }
+    }
+
+    /* Create the haptic device */
+    haptic = (SDL_Haptic *) SDL_malloc((sizeof *haptic));
+    if (haptic == NULL) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    /* Initialize the haptic device */
+    SDL_memset(haptic, 0, (sizeof *haptic));
+    haptic->index = device_index;
+    if (SDL_SYS_HapticOpen(haptic) < 0) {
+        SDL_free(haptic);
+        return NULL;
+    }
+
+    /* Disable autocenter and set gain to max. */
+    if (haptic->supported & SDL_HAPTIC_GAIN)
+        SDL_HapticSetGain(haptic, 100);
+    if (haptic->supported & SDL_HAPTIC_AUTOCENTER)
+        SDL_HapticSetAutocenter(haptic, 0);
+
+    /* Add haptic to list */
+    ++haptic->ref_count;
+    for (i = 0; SDL_haptics[i]; i++)
+        /* Skip to next haptic */ ;
+    SDL_haptics[i] = haptic;
+
+    return haptic;
+}
+
+
+/*
+ * Returns 1 if the device has been opened.
+ */
+int
+SDL_HapticOpened(int device_index)
+{
+    int i, opened;
+
+    opened = 0;
+    for (i = 0; SDL_haptics[i]; i++) {
+        if (SDL_haptics[i]->index == (Uint8) device_index) {
+            opened = 1;
+            break;
+        }
+    }
+    return opened;
+}
+
+
+/*
+ * Returns the index to a haptic device.
+ */
+int
+SDL_HapticIndex(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return haptic->index;
+}
+
+
+/*
+ * Returns SDL_TRUE if mouse is haptic, SDL_FALSE if it isn't.
+ */
+int
+SDL_MouseIsHaptic(void)
+{
+    if (SDL_SYS_HapticMouse() < 0)
+        return SDL_FALSE;
+    return SDL_TRUE;
+}
+
+
+/*
+ * Returns the haptic device if mouse is haptic or NULL elsewise.
+ */
+SDL_Haptic *
+SDL_HapticOpenFromMouse(void)
+{
+    int device_index;
+
+    device_index = SDL_SYS_HapticMouse();
+
+    if (device_index < 0) {
+        SDL_SetError("Haptic: Mouse isn't a haptic device.");
+        return NULL;
+    }
+
+    return SDL_HapticOpen(device_index);
+}
+
+
+/*Palm Edit: Joystick functions not necessary for our purposes*/
+/*
+ * Returns SDL_TRUE if joystick has haptic features.
+ */
+//int
+//SDL_JoystickIsHaptic(SDL_Joystick * joystick)
+//{
+//    int ret;
+//
+//    /* Must be a valid joystick */
+//    if (!SDL_PrivateJoystickValid(&joystick)) {
+//        return -1;
+//    }
+//
+//    ret = SDL_SYS_JoystickIsHaptic(joystick);
+//
+//    if (ret > 0)
+//        return SDL_TRUE;
+//    else if (ret == 0)
+//        return SDL_FALSE;
+//    else
+//        return -1;
+//}
+//
+//
+///*
+// * Opens a haptic device from a joystick.
+// */
+//SDL_Haptic *
+//SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)
+//{
+//    int i;
+//    SDL_Haptic *haptic;
+//
+//    /* Must be a valid joystick */
+//    if (!SDL_PrivateJoystickValid(&joystick)) {
+//        return NULL;
+//    }
+//
+//    /* Joystick must be haptic */
+//    if (SDL_SYS_JoystickIsHaptic(joystick) <= 0) {
+//        return NULL;
+//    }
+//
+//    /* Check to see if joystick's haptic is already open */
+//    for (i = 0; SDL_haptics[i]; i++) {
+//        if (SDL_SYS_JoystickSameHaptic(SDL_haptics[i], joystick)) {
+//            haptic = SDL_haptics[i];
+//            ++haptic->ref_count;
+//            return haptic;
+//        }
+//    }
+//
+//    /* Create the haptic device */
+//    haptic = (SDL_Haptic *) SDL_malloc((sizeof *haptic));
+//    if (haptic == NULL) {
+//        SDL_OutOfMemory();
+//        return NULL;
+//    }
+//
+//    /* Initialize the haptic device */
+//    SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+//    if (SDL_SYS_HapticOpenFromJoystick(haptic, joystick) < 0) {
+//        SDL_free(haptic);
+//        return NULL;
+//    }
+//
+//    /* Add haptic to list */
+//    ++haptic->ref_count;
+//    for (i = 0; SDL_haptics[i]; i++)
+//        /* Skip to next haptic */ ;
+//    SDL_haptics[i] = haptic;
+//
+//    return haptic;
+//}
+
+
+/*
+ * Closes a SDL_Haptic device.
+ */
+void
+SDL_HapticClose(SDL_Haptic * haptic)
+{
+    int i;
+
+    /* Must be valid */
+    if (!ValidHaptic(haptic)) {
+        return;
+    }
+
+    /* Check if it's still in use */
+    if (--haptic->ref_count < 0) {
+        return;
+    }
+
+    /* Close it, properly removing effects if needed */
+    for (i = 0; i < haptic->neffects; i++) {
+        if (haptic->effects[i].hweffect != NULL) {
+            SDL_HapticDestroyEffect(haptic, i);
+        }
+    }
+    SDL_SYS_HapticClose(haptic);
+
+    /* Remove from the list */
+    for (i = 0; SDL_haptics[i]; ++i) {
+        if (haptic == SDL_haptics[i]) {
+            SDL_haptics[i] = NULL;
+            SDL_memcpy(&SDL_haptics[i], &SDL_haptics[i + 1],
+                       (SDL_numhaptics - i) * sizeof(haptic));
+            break;
+        }
+    }
+
+    /* Free */
+    SDL_free(haptic);
+}
+
+/*
+ * Cleans up after the subsystem.
+ */
+void
+SDL_HapticQuit(void)
+{
+    SDL_SYS_HapticQuit();
+    if (SDL_haptics != NULL) {
+        SDL_free(SDL_haptics);
+        SDL_haptics = NULL;
+    }
+    SDL_numhaptics = 0;
+}
+
+/*
+ * Returns the number of effects a haptic device has.
+ */
+int
+SDL_HapticNumEffects(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return haptic->neffects;
+}
+
+
+/*
+ * Returns the number of effects a haptic device can play.
+ */
+int
+SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return haptic->nplaying;
+}
+
+
+/*
+ * Returns supported effects by the device.
+ */
+unsigned int
+SDL_HapticQuery(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return haptic->supported;
+}
+
+
+/*
+ * Returns the number of axis on the device.
+ */
+int
+SDL_HapticNumAxes(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return haptic->naxes;
+}
+
+/*
+ * Checks to see if the device can support the effect.
+ */
+int
+SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    if ((haptic->supported & effect->type) != 0)
+        return SDL_TRUE;
+    return SDL_FALSE;
+}
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+{
+    int i;
+
+    /* Check for device validity. */
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    /* Check to see if effect is supported */
+    if (SDL_HapticEffectSupported(haptic, effect) == SDL_FALSE) {
+        SDL_SetError("Haptic: Effect not supported by haptic device.");
+        return -2;
+    }
+
+    /* See if there's a free slot */
+    for (i = 0; i < haptic->neffects; i++) {
+        if (haptic->effects[i].hweffect == NULL) {
+
+            /* Now let the backend create the real effect */
+            if (SDL_SYS_HapticNewEffect(haptic, &haptic->effects[i], effect)
+                != 0) {
+                return -3;      /* Backend failed to create effect */
+            }
+
+            SDL_memcpy(&haptic->effects[i].effect, effect,
+                       sizeof(SDL_HapticEffect));
+            return i;
+        }
+    }
+
+    SDL_SetError("Haptic: Device has no free space left.");
+    return -4;
+}
+
+/*
+ * Checks to see if an effect is valid.
+ */
+static int
+ValidEffect(SDL_Haptic * haptic, int effect)
+{
+    if ((effect < 0) || (effect >= haptic->neffects)) {
+        SDL_SetError("Haptic: Invalid effect identifier.");
+        return 0;
+    }
+    return 1;
+}
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect,
+                       SDL_HapticEffect * data)
+{
+    if (!ValidHaptic(haptic) || !ValidEffect(haptic, effect)) {
+        return -1;
+    }
+
+    /* Can't change type dynamically. */
+    if (data->type != haptic->effects[effect].effect.type) {
+        SDL_SetError("Haptic: Updating effect type is illegal.");
+        return -1;
+    }
+
+    /* Updates the effect */
+    if (SDL_SYS_HapticUpdateEffect(haptic, &haptic->effects[effect], data) <
+        0) {
+        return -1;
+    }
+
+    SDL_memcpy(&haptic->effects[effect].effect, data,
+               sizeof(SDL_HapticEffect));
+    return 0;
+}
+
+
+/*
+ * Runs the haptic effect on the device.
+ */
+int
+SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations)
+{
+    if (!ValidHaptic(haptic) || !ValidEffect(haptic, effect)) {
+        return -1;
+    }
+
+    /* Run the effect */
+    if (SDL_SYS_HapticRunEffect(haptic, &haptic->effects[effect], iterations)
+        < 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Stops the haptic effect on the device.
+ */
+int
+SDL_HapticStopEffect(SDL_Haptic * haptic, int effect)
+{
+    if (!ValidHaptic(haptic) || !ValidEffect(haptic, effect)) {
+        return -1;
+    }
+
+    /* Stop the effect */
+    if (SDL_SYS_HapticStopEffect(haptic, &haptic->effects[effect]) < 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Gets rid of a haptic effect.
+ */
+void
+SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect)
+{
+    if (!ValidHaptic(haptic) || !ValidEffect(haptic, effect)) {
+        return;
+    }
+
+    /* Not allocated */
+    if (haptic->effects[effect].hweffect == NULL) {
+        return;
+    }
+
+    SDL_SYS_HapticDestroyEffect(haptic, &haptic->effects[effect]);
+}
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_HapticGetEffectStatus(SDL_Haptic * haptic, int effect)
+{
+    if (!ValidHaptic(haptic) || !ValidEffect(haptic, effect)) {
+        return -1;
+    }
+
+    //if ((haptic->supported & SDL_HAPTIC_STATUS) == 0) {
+    //    SDL_SetError("Haptic: Device does not support status queries.");
+    //    return -1;
+    //}
+
+    return SDL_SYS_HapticGetEffectStatus(haptic, &haptic->effects[effect]);
+}
+
+/*
+ * Sets the global gain of the device.
+ */
+int
+SDL_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+    const char *env;
+    int real_gain, max_gain;
+
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    if ((haptic->supported & SDL_HAPTIC_GAIN) == 0) {
+        SDL_SetError("Haptic: Device does not support setting gain.");
+        return -1;
+    }
+
+    if ((gain < 0) || (gain > 100)) {
+        SDL_SetError("Haptic: Gain must be between 0 and 100.");
+        return -1;
+    }
+
+    /* We use the envvar to get the maximum gain. */
+    env = SDL_getenv("SDL_HAPTIC_GAIN_MAX");
+    if (env != NULL) {
+        max_gain = SDL_atoi(env);
+
+        /* Check for sanity. */
+        if (max_gain < 0)
+            max_gain = 0;
+        else if (max_gain > 100)
+            max_gain = 100;
+
+        /* We'll scale it linearly with SDL_HAPTIC_GAIN_MAX */
+        real_gain = (gain * max_gain) / 100;
+    } else {
+        real_gain = gain;
+    }
+
+    if (SDL_SYS_HapticSetGain(haptic, real_gain) < 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Makes the device autocenter, 0 disables.
+ */
+int
+SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    if ((haptic->supported & SDL_HAPTIC_AUTOCENTER) == 0) {
+        SDL_SetError("Haptic: Device does not support setting autocenter.");
+        return -1;
+    }
+
+    if ((autocenter < 0) || (autocenter > 100)) {
+        SDL_SetError("Haptic: Autocenter must be between 0 and 100.");
+        return -1;
+    }
+
+    if (SDL_SYS_HapticSetAutocenter(haptic, autocenter) < 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Pauses the haptic device.
+ */
+int
+SDL_HapticPause(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    if ((haptic->supported & SDL_HAPTIC_PAUSE) == 0) {
+        SDL_SetError("Haptic: Device does not support setting pausing.");
+        return -1;
+    }
+
+    return SDL_SYS_HapticPause(haptic);
+}
+/*
+ * Unpauses the haptic device.
+ */
+int
+SDL_HapticUnpause(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    if ((haptic->supported & SDL_HAPTIC_PAUSE) == 0) {
+        return 0;               /* Not going to be paused, so we pretend it's unpaused. */
+    }
+
+    return SDL_SYS_HapticUnpause(haptic);
+}
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_HapticStopAll(SDL_Haptic * haptic)
+{
+    if (!ValidHaptic(haptic)) {
+        return -1;
+    }
+
+    return SDL_SYS_HapticStopAll(haptic);
+}
+
+/*
+ * Palm Edit: Returns minimum duration of vibration - which is 0ms;
+ */
+int
+SDL_HapticMinDuration(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticMinDuration(haptic);
+}
+
+/*
+ * Palm Edit: Returns minimum duration of vibration - which is 0ms;
+ */
+int
+SDL_HapticMaxDuration(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticMaxDuration(haptic);
+}
diff -pruN libsdl-1.2/src/haptic/SDL_syshaptic.h libsdl-1.2-palm/src/haptic/SDL_syshaptic.h
--- libsdl-1.2/src/haptic/SDL_syshaptic.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/haptic/SDL_syshaptic.h	2009-09-30 12:36:12.000000000 -0700
@@ -0,0 +1,217 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#include "SDL_config.h"
+
+#include "SDL_haptic.h"
+
+
+/*
+ * Number of haptic devices on the system.
+ */
+extern Uint8 SDL_numhaptics;
+
+
+struct haptic_effect
+{
+    int vibeEffectHandle;
+    SDL_HapticEffect effect;    /* The current event */
+    struct haptic_hweffect *hweffect;   /* The hardware behind the event */
+};
+
+/*
+ * The real SDL_Haptic struct.
+ */
+struct _SDL_Haptic
+{
+    Uint8 index;                /* Stores index it is attached to */
+
+    struct haptic_effect *effects;      /* Allocated effects */
+    int neffects;               /* Maximum amount of effects */
+    int nplaying;               /* Maximum amount of effects to play at the same time */
+    unsigned int supported;     /* Supported effects */
+    int naxes;                  /* Number of axes on the device. */
+
+    struct haptic_hwdata *hwdata;       /* Driver dependent */
+    int ref_count;              /* Count for multiple opens */
+};
+
+/* 
+ * Scans the system for haptic devices.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticInit(void);
+
+/*
+ * Gets the device dependent name of the haptic device
+ */
+extern const char *SDL_SYS_HapticName(int index);
+
+/*
+ * Opens the haptic device for usage.  The haptic device should have
+ * the index value set previously.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticOpen(SDL_Haptic * haptic);
+
+/*
+ * Returns the index of the haptic core pointer or -1 if none is found.
+ */
+int SDL_SYS_HapticMouse(void);
+
+/*
+ * Checks to see if the joystick has haptic capabilities.
+ *
+ * Returns >0 if haptic capabilities are detected, 0 if haptic
+ * capabilities aren't detected and -1 on error.
+ */
+//extern int SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick);
+
+/*
+ * Opens the haptic device for usage using the same device as
+ * the joystick.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+//extern int SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic,
+//                                          SDL_Joystick * joystick);
+/*
+ * Checks to see if haptic device and joystick device are the same.
+ *
+ * Returns 1 if they are the same, 0 if they aren't.
+ */
+//extern int SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic,
+//                                      SDL_Joystick * joystick);
+
+/*
+ * Closes a haptic device after usage.
+ */
+extern void SDL_SYS_HapticClose(SDL_Haptic * haptic);
+
+/*
+ * Performs a cleanup on the haptic subsystem.
+ */
+extern void SDL_SYS_HapticQuit(void);
+
+/*
+ * Creates a new haptic effect on the haptic device using base
+ * as a template for the effect.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                                   struct haptic_effect *effect,
+                                   SDL_HapticEffect * base);
+
+/*
+ * Updates the haptic effect on the haptic device using data
+ * as a template.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                                      struct haptic_effect *effect,
+                                      SDL_HapticEffect * data);
+
+/*
+ * Runs the effect on the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticRunEffect(SDL_Haptic * haptic,
+                                   struct haptic_effect *effect,
+                                   Uint32 iterations);
+
+/*
+ * Stops the effect on the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticStopEffect(SDL_Haptic * haptic,
+                                    struct haptic_effect *effect);
+
+/*
+ * Cleanups up the effect on the haptic device.
+ */
+extern void SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic,
+                                        struct haptic_effect *effect);
+
+/*
+ * Queries the device for the status of effect.
+ *
+ * Returns 0 if device is stopped, >0 if device is playing and
+ * -1 on error.
+ */
+extern int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic,
+                                         struct haptic_effect *effect);
+
+/*
+ * Sets the global gain of the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain);
+
+/*
+ * Sets the autocenter feature of the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter);
+
+/*
+ * Pauses the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticPause(SDL_Haptic * haptic);
+
+/*
+ * Unpauses the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticUnpause(SDL_Haptic * haptic);
+
+/*
+ * Stops all the currently playing haptic effects on the device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticStopAll(SDL_Haptic * haptic);
+
+/*
+ * Returns the minimum duration an effect can be played
+ *
+ * Returns minimum duration on success, -1 on error
+ */
+extern int SDL_SYS_HapticMinDuration(SDL_Haptic * haptic);
+
+/*
+ * Returns the maximum duration an effect can be played
+ *
+ * Returns maximum duration on success, -1 on error
+ */
+extern int SDL_SYS_HapticMaxDuration(SDL_Haptic * haptic);
+
diff -pruN libsdl-1.2/src/haptic/win32/sdl_syshaptic.c libsdl-1.2-palm/src/haptic/win32/sdl_syshaptic.c
--- libsdl-1.2/src/haptic/win32/sdl_syshaptic.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/haptic/win32/sdl_syshaptic.c	2009-10-01 13:29:01.000000000 -0700
@@ -0,0 +1,1422 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_DINPUT
+
+//#include <windows.h>
+#include <dinput.h>
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h"     /* For the real SDL_Joystick */
+//#include "../../joystick/win32/SDL_dxjoystick_c.h"      /* For joystick hwdata */
+
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+    DIDEVICEINSTANCE instance;
+    SDL_Haptic *haptic;
+    DIDEVCAPS capabilities;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+    LPDIRECTINPUTDEVICE2 device;
+    DWORD axes[3];              /* Axes to use. */
+    int is_joystick;            /* Device is loaded as joystick. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+	DWORD tickCount; /*Palm Edit: This was added to support windows vibration emulation...has nothing to do with hardware*/
+    DIEFFECT effect;
+    LPDIRECTINPUTEFFECT ref;
+};
+
+
+/*
+ * Internal stuff.
+ */
+static LPDIRECTINPUT dinput = NULL;
+
+
+/*
+ * External stuff.
+ */
+extern HWND SDL_HelperWindow;
+
+
+/*
+ * Prototypes.
+ */
+static void DI_SetError(const char *str, HRESULT err);
+static int DI_GUIDIsSame(const GUID * a, const GUID * b);
+static int SDL_SYS_HapticOpenFromInstance(SDL_Haptic * haptic,
+                                          DIDEVICEINSTANCE instance);
+static int SDL_SYS_HapticOpenFromDevice2(SDL_Haptic * haptic,
+                                         LPDIRECTINPUTDEVICE2 device2);
+static DWORD DIGetTriggerButton(Uint16 button);
+static int SDL_SYS_SetDirection(DIEFFECT * effect, SDL_HapticDirection * dir,
+                                int naxes);
+static int SDL_SYS_ToDIEFFECT(SDL_Haptic * haptic, DIEFFECT * dest,
+                              SDL_HapticEffect * src);
+static void SDL_SYS_HapticFreeDIEFFECT(DIEFFECT * effect, int type);
+static REFGUID SDL_SYS_HapticEffectType(SDL_HapticEffect * effect);
+/* Callbacks. */
+static BOOL CALLBACK EnumHapticsCallback(const DIDEVICEINSTANCE *
+                                         pdidInstance, VOID * pContext);
+static BOOL CALLBACK DI_EffectCallback(LPCDIEFFECTINFO pei, LPVOID pv);
+
+
+/* 
+ * Like SDL_SetError but for DX error codes.
+ */
+static void
+DI_SetError(const char *str, HRESULT err)
+{
+    /*
+       SDL_SetError("Haptic: %s - %s: %s", str,
+       DXGetErrorString8A(err), DXGetErrorDescription8A(err));
+     */
+    SDL_SetError("Haptic error %s", str);
+}
+
+
+/*
+ * Checks to see if two GUID are the same.
+ */
+static int
+DI_GUIDIsSame(const GUID * a, const GUID * b)
+{
+    if (((a)->Data1 == (b)->Data1) &&
+        ((a)->Data2 == (b)->Data2) &&
+        ((a)->Data3 == (b)->Data3) &&
+        (SDL_strcmp((a)->Data4, (b)->Data4) == 0))
+        return 1;
+    return 0;
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+    //HRESULT ret;
+    //HINSTANCE instance;
+
+    //if (dinput != NULL) {       /* Already open. */
+    //    SDL_SetError("Haptic: SubSystem already open.");
+    //    return -1;
+    //}
+
+    ///* Clear all the memory. */
+    //SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+    SDL_numhaptics = 1;
+
+    //ret = CoInitialize(NULL);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Coinitialize", ret);
+    //    return -1;
+    //}
+
+    //ret = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER,
+    //                       &IID_IDirectInput, (LPVOID) & dinput);
+    //if (FAILED(ret)) {
+    //    DI_SetError("CoCreateInstance", ret);
+    //    return -1;
+    //}
+
+    ///* Because we used CoCreateInstance, we need to Initialize it, first. */
+    //instance = GetModuleHandle(NULL);
+    //if (instance == NULL) {
+    //    SDL_SetError("GetModuleHandle() failed with error code %d.",
+    //                 GetLastError());
+    //    return -1;
+    //}
+    //ret = IDirectInput_Initialize(dinput, instance, DIRECTINPUT_VERSION);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Initializing DirectInput device", ret);
+    //    return -1;
+    //}
+
+    ///* Look for haptic devices. */
+    //ret = IDirectInput_EnumDevices(dinput,
+    //                               0,
+    //                               EnumHapticsCallback,
+    //                               NULL,
+    //                               DIEDFL_FORCEFEEDBACK |
+    //                               DIEDFL_ATTACHEDONLY);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Enumerating DirectInput devices", ret);
+    //    return -1;
+    //}
+
+    return SDL_numhaptics;
+}
+
+/*
+ * Callback to find the haptic devices.
+ */
+static BOOL CALLBACK
+EnumHapticsCallback(const DIDEVICEINSTANCE * pdidInstance, VOID * pContext)
+{
+    HRESULT ret;
+    LPDIRECTINPUTDEVICE device;
+
+    /* Copy the instance over, useful for creating devices. */
+    SDL_memcpy(&SDL_hapticlist[SDL_numhaptics].instance, pdidInstance,
+               sizeof(DIDEVICEINSTANCE));
+
+    /* Open the device */
+    ret = IDirectInput_CreateDevice(dinput, &pdidInstance->guidInstance,
+                                    &device, NULL);
+    if (FAILED(ret)) {
+        /* DI_SetError("Creating DirectInput device",ret); */
+        return DIENUM_CONTINUE;
+    }
+
+    /* Get capabilities. */
+    SDL_hapticlist[SDL_numhaptics].capabilities.dwSize = sizeof(DIDEVCAPS);
+    ret = IDirectInputDevice_GetCapabilities(device,
+                                             &SDL_hapticlist[SDL_numhaptics].
+                                             capabilities);
+    if (FAILED(ret)) {
+        /* DI_SetError("Getting device capabilities",ret); */
+        IDirectInputDevice_Release(device);
+        return DIENUM_CONTINUE;
+    }
+
+    /* Close up device and count it. */
+    IDirectInputDevice_Release(device);
+    SDL_numhaptics++;
+
+    /* Watch out for hard limit. */
+    if (SDL_numhaptics >= MAX_HAPTICS)
+        return DIENUM_STOP;
+
+    return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+    return SDL_hapticlist[index].instance.tszProductName;
+}
+
+
+/*
+ * Callback to get all supported effects.
+ */
+#define EFFECT_TEST(e,s)               \
+if (DI_GUIDIsSame(&pei->guid, &(e)))   \
+   haptic->supported |= (s)
+static BOOL CALLBACK
+DI_EffectCallback(LPCDIEFFECTINFO pei, LPVOID pv)
+{
+    /* Prepare the haptic device. */
+    SDL_Haptic *haptic = (SDL_Haptic *) pv;
+
+    /* Get supported. */
+    EFFECT_TEST(GUID_Spring, SDL_HAPTIC_SPRING);
+    EFFECT_TEST(GUID_Damper, SDL_HAPTIC_DAMPER);
+    EFFECT_TEST(GUID_Inertia, SDL_HAPTIC_INERTIA);
+    EFFECT_TEST(GUID_Friction, SDL_HAPTIC_FRICTION);
+    EFFECT_TEST(GUID_ConstantForce, SDL_HAPTIC_CONSTANT);
+    EFFECT_TEST(GUID_CustomForce, SDL_HAPTIC_CUSTOM);
+    EFFECT_TEST(GUID_Sine, SDL_HAPTIC_SINE);
+    EFFECT_TEST(GUID_Square, SDL_HAPTIC_SQUARE);
+    EFFECT_TEST(GUID_Triangle, SDL_HAPTIC_TRIANGLE);
+    EFFECT_TEST(GUID_SawtoothUp, SDL_HAPTIC_SAWTOOTHUP);
+    EFFECT_TEST(GUID_SawtoothDown, SDL_HAPTIC_SAWTOOTHDOWN);
+    EFFECT_TEST(GUID_RampForce, SDL_HAPTIC_RAMP);
+
+    /* Check for more. */
+    return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Callback to get supported axes.
+ */
+static BOOL CALLBACK
+DI_DeviceObjectCallback(LPCDIDEVICEOBJECTINSTANCE dev, LPVOID pvRef)
+{
+    SDL_Haptic *haptic = (SDL_Haptic *) pvRef;
+
+    if ((dev->dwType & DIDFT_AXIS) && (dev->dwFlags & DIDOI_FFACTUATOR)) {
+
+        haptic->hwdata->axes[haptic->naxes] = dev->dwOfs;
+        haptic->naxes++;
+
+        /* Currently using the artificial limit of 3 axes. */
+        if (haptic->naxes >= 3) {
+            return DIENUM_STOP;
+        }
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ *
+ *    Steps:
+ *       - Open temporary DirectInputDevice interface.
+ *       - Create DirectInputDevice2 interface.
+ *       - Release DirectInputDevice interface.
+ *       - Call SDL_SYS_HapticOpenFromDevice2
+ */
+static int
+SDL_SYS_HapticOpenFromInstance(SDL_Haptic * haptic, DIDEVICEINSTANCE instance)
+{
+//    HRESULT ret;
+    int ret2;
+//    LPDIRECTINPUTDEVICE device;
+
+    /* Allocate the hwdata */
+    haptic->hwdata = (struct haptic_hwdata *)
+        SDL_malloc(sizeof(*haptic->hwdata));
+    if (haptic->hwdata == NULL) {
+        SDL_OutOfMemory();
+        goto creat_err;
+    }
+    SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+    ///* Open the device */
+    //ret = IDirectInput_CreateDevice(dinput, &instance.guidInstance,
+    //                                &device, NULL);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Creating DirectInput device", ret);
+    //    goto creat_err;
+    //}
+
+    ///* Now get the IDirectInputDevice2 interface, instead. */
+    //ret = IDirectInputDevice_QueryInterface(device,
+    //                                        &IID_IDirectInputDevice2,
+    //                                        (LPVOID *) & haptic->hwdata->
+    //                                        device);
+    ///* Done with the temporary one now. */
+    //IDirectInputDevice_Release(device);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Querying DirectInput interface", ret);
+    //    goto creat_err;
+    //}
+
+    ret2 = SDL_SYS_HapticOpenFromDevice2(haptic, haptic->hwdata->device);
+    if (ret2 < 0) {
+        goto query_err;
+    }
+
+    return 0;
+
+  query_err:
+    IDirectInputDevice2_Release(haptic->hwdata->device);
+  creat_err:
+    if (haptic->hwdata != NULL) {
+        SDL_free(haptic->hwdata);
+        haptic->hwdata = NULL;
+    }
+    return -1;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ *
+ *    Steps:
+ *       - Set cooperative level.
+ *       - Set data format.
+ *       - Acquire exclusiveness.
+ *       - Reset actuators.
+ *       - Get supported featuers.
+ */
+static int
+SDL_SYS_HapticOpenFromDevice2(SDL_Haptic * haptic,
+                              LPDIRECTINPUTDEVICE2 device2)
+{
+    //HRESULT ret;
+    //DIPROPDWORD dipdw;
+
+    /* We'll use the device2 from now on. */
+    haptic->hwdata->device = device2;
+
+    /* Grab it exclusively to use force feedback stuff. */
+    //ret = IDirectInputDevice2_SetCooperativeLevel(haptic->hwdata->device,
+    //                                              SDL_HelperWindow,
+    //                                              DISCL_EXCLUSIVE |
+    //                                              DISCL_BACKGROUND);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Setting cooperative level to exclusive", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Set data format. */
+    //ret = IDirectInputDevice2_SetDataFormat(haptic->hwdata->device,
+    //                                        &c_dfDIJoystick2);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Setting data format", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Get number of axes. */
+    //ret = IDirectInputDevice2_EnumObjects(haptic->hwdata->device,
+    //                                      DI_DeviceObjectCallback,
+    //                                      haptic, DIDFT_AXIS);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Getting device axes", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Acquire the device. */
+    //ret = IDirectInputDevice2_Acquire(haptic->hwdata->device);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Acquiring DirectInput device", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Reset all actuators - just in case. */
+    //ret = IDirectInputDevice2_SendForceFeedbackCommand(haptic->hwdata->device,
+    //                                                   DISFFC_RESET);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Resetting device", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Enabling actuators. */
+    //ret = IDirectInputDevice2_SendForceFeedbackCommand(haptic->hwdata->device,
+    //                                                   DISFFC_SETACTUATORSON);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Enabling actuators", ret);
+    //    goto acquire_err;
+    //}
+
+    ///* Get supported effects. */
+    //ret = IDirectInputDevice2_EnumEffects(haptic->hwdata->device,
+    //                                      DI_EffectCallback, haptic,
+    //                                      DIEFT_ALL);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Enumerating supported effects", ret);
+    //    goto acquire_err;
+    //}
+    //if (haptic->supported == 0) {       /* Error since device supports nothing. */
+    //    SDL_SetError("Haptic: Internal error on finding supported effects.");
+    //    goto acquire_err;
+    //}
+
+    ///* Check autogain and autocenter. */
+    //dipdw.diph.dwSize = sizeof(DIPROPDWORD);
+    //dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    //dipdw.diph.dwObj = 0;
+    //dipdw.diph.dwHow = DIPH_DEVICE;
+    //dipdw.dwData = 10000;
+    //ret = IDirectInputDevice2_SetProperty(haptic->hwdata->device,
+    //                                      DIPROP_FFGAIN, &dipdw.diph);
+    //if (!FAILED(ret)) {         /* Gain is supported. */
+    //    haptic->supported |= SDL_HAPTIC_GAIN;
+    //}
+    //dipdw.diph.dwObj = 0;
+    //dipdw.diph.dwHow = DIPH_DEVICE;
+    //dipdw.dwData = DIPROPAUTOCENTER_OFF;
+    //ret = IDirectInputDevice2_SetProperty(haptic->hwdata->device,
+    //                                      DIPROP_AUTOCENTER, &dipdw.diph);
+    //if (!FAILED(ret)) {         /* Autocenter is supported. */
+    //    haptic->supported |= SDL_HAPTIC_AUTOCENTER;
+    //}
+
+    /* Status is always supported. */
+    haptic->supported |= SDL_HAPTIC_CONSTANT | SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+    /* Check maximum effects. */
+    haptic->neffects = 4;     /* This is not actually supported as thus under windows,
+                                   there is no way to tell the number of EFFECTS that a
+                                   device can hold, so we'll just use a "random" number
+                                   instead and put warnings in SDL_haptic.h */
+    haptic->nplaying = 4;     /* Even more impossible to get this then neffects. */
+
+    /* Prepare effects memory. */
+    haptic->effects = (struct haptic_effect *)
+        SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+    if (haptic->effects == NULL) {
+        SDL_OutOfMemory();
+        goto acquire_err;
+    }
+    /* Clear the memory */
+    SDL_memset(haptic->effects, 0,
+               sizeof(struct haptic_effect) * haptic->neffects);
+
+    return 0;
+
+    /* Error handling */
+  acquire_err:
+    IDirectInputDevice2_Unacquire(haptic->hwdata->device);
+    return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+    return SDL_SYS_HapticOpenFromInstance(haptic,
+                                          SDL_hapticlist[haptic->index].
+                                          instance);
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+    int i;
+
+    /* Grab the first mouse haptic device we find. */
+    for (i = 0; i < SDL_numhaptics; i++) {
+//        if (SDL_hapticlist[i].capabilities.dwDevType == DIDEVTYPE_MOUSE) {
+//           return i;
+//        }
+    }
+
+    return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+/*int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+    if (joystick->hwdata->Capabilities.dwFlags & DIDC_FORCEFEEDBACK) {
+        return SDL_TRUE;
+    }
+
+    return SDL_FALSE;
+}*/
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+//int
+//SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+//{
+//    HRESULT ret;
+//    DIDEVICEINSTANCE hap_instance, joy_instance;
+
+    ///* Get the device instances. */
+    //ret = IDirectInputDevice2_GetDeviceInfo(haptic->hwdata->device,
+    //                                        &hap_instance);
+    //if (FAILED(ret)) {
+        //return 0;
+    //}
+    //ret = IDirectInputDevice2_GetDeviceInfo(joystick->hwdata->InputDevice,
+      //                                      &joy_instance);
+    //if (FAILED(ret)) {
+      //  return 0;
+    //}
+
+    //if (DI_GUIDIsSame(&hap_instance.guidInstance, &joy_instance.guidInstance))
+      //  return 1;
+
+    //return 0;
+//}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+//int
+//SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+//{
+//    int ret;
+
+    /* Allocate the hwdata */
+//    haptic->hwdata = (struct haptic_hwdata *)
+//        SDL_malloc(sizeof(*haptic->hwdata));
+//    if (haptic->hwdata == NULL) {
+//        SDL_OutOfMemory();
+//        return -1;
+//    }
+//    SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+    /* Now open the device. */
+ //   ret =
+ //       SDL_SYS_HapticOpenFromDevice2(haptic, joystick->hwdata->InputDevice);
+ //   if (ret < 0) {
+ //       return -1;
+ // }
+
+    /* It's using the joystick device. */
+ //   haptic->hwdata->is_joystick = 1;
+
+//    return 0;
+//}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+    if (haptic->hwdata) {
+
+        /* Free effects. */
+        SDL_free(haptic->effects);
+        haptic->effects = NULL;
+        haptic->neffects = 0;
+
+        /* Clean up */
+        //IDirectInputDevice2_Unacquire(haptic->hwdata->device);
+        /* Only release if isn't grabbed by a joystick. */
+        //if (haptic->hwdata->is_joystick == 0) {
+        //    IDirectInputDevice2_Release(haptic->hwdata->device);
+        //}
+
+        /* Free */
+        SDL_free(haptic->hwdata);
+        haptic->hwdata = NULL;
+    }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+//    IDirectInput_Release(dinput);
+    dinput = NULL;
+}
+
+
+/*
+ * Converts an SDL trigger button to an DIEFFECT trigger button.
+ */
+static DWORD
+DIGetTriggerButton(Uint16 button)
+{
+    DWORD dwTriggerButton;
+
+    dwTriggerButton = DIEB_NOTRIGGER;
+
+    if (button != 0) {
+        dwTriggerButton = DIJOFS_BUTTON(button - 1);
+    }
+
+    return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection(DIEFFECT * effect, SDL_HapticDirection * dir, int naxes)
+{
+    LONG *rglDir;
+
+    /* Handle no axes a part. */
+    if (naxes == 0) {
+        effect->dwFlags |= DIEFF_SPHERICAL;     /* Set as default. */
+        effect->rglDirection = NULL;
+        return 0;
+    }
+
+    /* Has axes. */
+    rglDir = SDL_malloc(sizeof(LONG) * naxes);
+    if (rglDir == NULL) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    SDL_memset(rglDir, 0, sizeof(LONG) * naxes);
+    effect->rglDirection = rglDir;
+
+    switch (dir->type) {
+    case SDL_HAPTIC_POLAR:
+        effect->dwFlags |= DIEFF_POLAR;
+        rglDir[0] = dir->dir[0];
+        return 0;
+    case SDL_HAPTIC_CARTESIAN:
+        effect->dwFlags |= DIEFF_CARTESIAN;
+        rglDir[0] = dir->dir[0];
+        if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+        if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+        return 0;
+    case SDL_HAPTIC_SPHERICAL:
+        effect->dwFlags |= DIEFF_SPHERICAL;
+        rglDir[0] = dir->dir[0];
+        if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+        if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+        return 0;
+
+    default:
+        SDL_SetError("Haptic: Unknown direction type.");
+        return -1;
+    }
+}
+
+#define CONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/*
+ * Creates the DIEFFECT from a SDL_HapticEffect.
+ */
+static int
+SDL_SYS_ToDIEFFECT(SDL_Haptic * haptic, DIEFFECT * dest,
+                   SDL_HapticEffect * src)
+{
+    int i;
+    DICONSTANTFORCE *constant;
+    DIPERIODIC *periodic;
+    DICONDITION *condition;     /* Actually an array of conditions - one per axis. */
+    DIRAMPFORCE *ramp;
+    DICUSTOMFORCE *custom;
+    DIENVELOPE *envelope;
+    SDL_HapticConstant *hap_constant;
+    SDL_HapticPeriodic *hap_periodic;
+    SDL_HapticCondition *hap_condition;
+    SDL_HapticRamp *hap_ramp;
+    SDL_HapticCustom *hap_custom;
+    DWORD *axes;
+
+    /* Set global stuff. */
+    SDL_memset(dest, 0, sizeof(DIEFFECT));
+    dest->dwSize = sizeof(DIEFFECT);    /* Set the structure size. */
+    dest->dwSamplePeriod = 0;   /* Not used by us. */
+    dest->dwGain = 10000;       /* Gain is set globally, not locally. */
+    dest->dwFlags = DIEFF_OBJECTOFFSETS;        /* Seems obligatory. */
+
+    /* Envelope. */
+    envelope = SDL_malloc(sizeof(DIENVELOPE));
+    if (envelope == NULL) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    SDL_memset(envelope, 0, sizeof(DIENVELOPE));
+    dest->lpEnvelope = envelope;
+    envelope->dwSize = sizeof(DIENVELOPE);      /* Always should be this. */
+
+    /* Axes. */
+    dest->cAxes = haptic->naxes;
+    if (dest->cAxes > 0) {
+        axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+        if (axes == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        axes[0] = haptic->hwdata->axes[0];      /* Always at least one axis. */
+        if (dest->cAxes > 1) {
+            axes[1] = haptic->hwdata->axes[1];
+        }
+        if (dest->cAxes > 2) {
+            axes[2] = haptic->hwdata->axes[2];
+        }
+        dest->rgdwAxes = axes;
+    }
+
+
+    /* The big type handling switch, even bigger then linux's version. */
+    switch (src->type) {
+    case SDL_HAPTIC_CONSTANT:
+        hap_constant = &src->constant;
+        constant = SDL_malloc(sizeof(DICONSTANTFORCE));
+        if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        SDL_memset(constant, 0, sizeof(DICONSTANTFORCE));
+
+        /* Specifics */
+        constant->lMagnitude = CONVERT(hap_constant->level);
+        dest->cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
+        dest->lpvTypeSpecificParams = constant;
+
+        /* Generics */
+        dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+        dest->dwTriggerButton = DIGetTriggerButton(hap_constant->button);
+        dest->dwTriggerRepeatInterval = hap_constant->interval;
+        dest->dwStartDelay = hap_constant->delay * 1000;        /* In microseconds. */
+
+        /* Direction. */
+        if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes)
+            < 0) {
+            return -1;
+        }
+
+        /* Envelope */
+        if ((hap_constant->attack_length == 0)
+            && (hap_constant->fade_length == 0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+        } else {
+            envelope->dwAttackLevel = CONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+        }
+
+        break;
+
+    case SDL_HAPTIC_SINE:
+    case SDL_HAPTIC_SQUARE:
+    case SDL_HAPTIC_TRIANGLE:
+    case SDL_HAPTIC_SAWTOOTHUP:
+    case SDL_HAPTIC_SAWTOOTHDOWN:
+        hap_periodic = &src->periodic;
+        periodic = SDL_malloc(sizeof(DIPERIODIC));
+        if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        SDL_memset(periodic, 0, sizeof(DIPERIODIC));
+
+        /* Specifics */
+        periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+        periodic->lOffset = CONVERT(hap_periodic->offset);
+        periodic->dwPhase = hap_periodic->phase;
+        periodic->dwPeriod = hap_periodic->period * 1000;
+        dest->cbTypeSpecificParams = sizeof(DIPERIODIC);
+        dest->lpvTypeSpecificParams = periodic;
+
+        /* Generics */
+        dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+        dest->dwTriggerButton = DIGetTriggerButton(hap_periodic->button);
+        dest->dwTriggerRepeatInterval = hap_periodic->interval;
+        dest->dwStartDelay = hap_periodic->delay * 1000;        /* In microseconds. */
+
+        /* Direction. */
+        if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes)
+            < 0) {
+            return -1;
+        }
+
+        /* Envelope */
+        if ((hap_periodic->attack_length == 0)
+            && (hap_periodic->fade_length == 0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+        } else {
+            envelope->dwAttackLevel = CONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+        }
+
+        break;
+
+    case SDL_HAPTIC_SPRING:
+    case SDL_HAPTIC_DAMPER:
+    case SDL_HAPTIC_INERTIA:
+    case SDL_HAPTIC_FRICTION:
+        hap_condition = &src->condition;
+        condition = SDL_malloc(sizeof(DICONDITION) * dest->cAxes);
+        if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        SDL_memset(condition, 0, sizeof(DICONDITION));
+
+        /* Specifics */
+        for (i = 0; i < (int) dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient =
+                CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient =
+                CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation =
+                CONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation =
+                CONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CONVERT(hap_condition->deadband[i]);
+        }
+        dest->cbTypeSpecificParams = sizeof(DICONDITION) * dest->cAxes;
+        dest->lpvTypeSpecificParams = condition;
+
+        /* Generics */
+        dest->dwDuration = hap_condition->length * 1000;        /* In microseconds. */
+        dest->dwTriggerButton = DIGetTriggerButton(hap_condition->button);
+        dest->dwTriggerRepeatInterval = hap_condition->interval;
+        dest->dwStartDelay = hap_condition->delay * 1000;       /* In microseconds. */
+
+        /* Direction. */
+        if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes)
+            < 0) {
+            return -1;
+        }
+
+        /* Envelope - Not actually supported by most CONDITION implementations. */
+        SDL_free(dest->lpEnvelope);
+        dest->lpEnvelope = NULL;
+
+        break;
+
+    case SDL_HAPTIC_RAMP:
+        hap_ramp = &src->ramp;
+        ramp = SDL_malloc(sizeof(DIRAMPFORCE));
+        if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        SDL_memset(ramp, 0, sizeof(DIRAMPFORCE));
+
+        /* Specifics */
+        ramp->lStart = CONVERT(hap_ramp->start);
+        ramp->lEnd = CONVERT(hap_ramp->end);
+        dest->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
+        dest->lpvTypeSpecificParams = ramp;
+
+        /* Generics */
+        dest->dwDuration = hap_ramp->length * 1000;     /* In microseconds. */
+        dest->dwTriggerButton = DIGetTriggerButton(hap_ramp->button);
+        dest->dwTriggerRepeatInterval = hap_ramp->interval;
+        dest->dwStartDelay = hap_ramp->delay * 1000;    /* In microseconds. */
+
+        /* Direction. */
+        if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+        }
+
+        /* Envelope */
+        if ((hap_ramp->attack_length == 0) && (hap_ramp->fade_length == 0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+        } else {
+            envelope->dwAttackLevel = CONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+        }
+
+        break;
+
+    case SDL_HAPTIC_CUSTOM:
+        hap_custom = &src->custom;
+        custom = SDL_malloc(sizeof(DICUSTOMFORCE));
+        if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+        }
+        SDL_memset(custom, 0, sizeof(DICUSTOMFORCE));
+
+        /* Specifics */
+        custom->cChannels = hap_custom->channels;
+        custom->dwSamplePeriod = hap_custom->period * 1000;
+        custom->cSamples = hap_custom->samples;
+        custom->rglForceData =
+            SDL_malloc(sizeof(LONG) * custom->cSamples * custom->cChannels);
+        for (i = 0; i < hap_custom->samples * hap_custom->channels; i++) {      /* Copy data. */
+            custom->rglForceData[i] = CONVERT(hap_custom->data[i]);
+        }
+        dest->cbTypeSpecificParams = sizeof(DICUSTOMFORCE);
+        dest->lpvTypeSpecificParams = custom;
+
+        /* Generics */
+        dest->dwDuration = hap_custom->length * 1000;   /* In microseconds. */
+        dest->dwTriggerButton = DIGetTriggerButton(hap_custom->button);
+        dest->dwTriggerRepeatInterval = hap_custom->interval;
+        dest->dwStartDelay = hap_custom->delay * 1000;  /* In microseconds. */
+
+        /* Direction. */
+        if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) <
+            0) {
+            return -1;
+        }
+
+        /* Envelope */
+        if ((hap_custom->attack_length == 0)
+            && (hap_custom->fade_length == 0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+        } else {
+            envelope->dwAttackLevel = CONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+        }
+
+        break;
+
+
+    default:
+        SDL_SetError("Haptic: Unknown effect type.");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Frees an DIEFFECT allocated by SDL_SYS_ToDIEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeDIEFFECT(DIEFFECT * effect, int type)
+{
+    DICUSTOMFORCE *custom;
+
+    if (effect->lpEnvelope != NULL) {
+        SDL_free(effect->lpEnvelope);
+        effect->lpEnvelope = NULL;
+    }
+    if (effect->rgdwAxes != NULL) {
+        SDL_free(effect->rgdwAxes);
+        effect->rgdwAxes = NULL;
+    }
+    if (effect->lpvTypeSpecificParams != NULL) {
+        if (type == SDL_HAPTIC_CUSTOM) {        /* Must free the custom data. */
+            custom = (DICUSTOMFORCE *) effect->lpvTypeSpecificParams;
+            SDL_free(custom->rglForceData);
+            custom->rglForceData = NULL;
+        }
+        SDL_free(effect->lpvTypeSpecificParams);
+        effect->lpvTypeSpecificParams = NULL;
+    }
+    if (effect->rglDirection != NULL) {
+        SDL_free(effect->rglDirection);
+        effect->rglDirection = NULL;
+    }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+static REFGUID
+SDL_SYS_HapticEffectType(SDL_HapticEffect * effect)
+{
+    switch (effect->type) {
+    case SDL_HAPTIC_CONSTANT:
+        return &GUID_ConstantForce;
+
+    case SDL_HAPTIC_RAMP:
+        return &GUID_RampForce;
+
+    case SDL_HAPTIC_SQUARE:
+        return &GUID_Square;
+
+    case SDL_HAPTIC_SINE:
+        return &GUID_Sine;
+
+    case SDL_HAPTIC_TRIANGLE:
+        return &GUID_Triangle;
+
+    case SDL_HAPTIC_SAWTOOTHUP:
+        return &GUID_SawtoothUp;
+
+    case SDL_HAPTIC_SAWTOOTHDOWN:
+        return &GUID_SawtoothDown;
+
+    case SDL_HAPTIC_SPRING:
+        return &GUID_Spring;
+
+    case SDL_HAPTIC_DAMPER:
+        return &GUID_Damper;
+
+    case SDL_HAPTIC_INERTIA:
+        return &GUID_Inertia;
+
+    case SDL_HAPTIC_FRICTION:
+        return &GUID_Friction;
+
+    case SDL_HAPTIC_CUSTOM:
+        return &GUID_CustomForce;
+
+    default:
+        SDL_SetError("Haptic: Unknown effect type.");
+        return NULL;
+    }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect *effect,
+                        SDL_HapticEffect * base)
+{
+    //HRESULT ret;
+
+    /* Get the type. */
+    //REFGUID type = SDL_SYS_HapticEffectType(base);
+    //if (type == NULL) {
+    //    goto err_hweffect;
+    //}
+
+    /* Alloc the effect. */
+    effect->hweffect = (struct haptic_hweffect *)
+        SDL_malloc(sizeof(struct haptic_hweffect));
+    if (effect->hweffect == NULL) {
+        SDL_OutOfMemory();
+        goto err_hweffect;
+    }
+
+	/*Palm Edit: Stub for vibration emulation*/
+	/*Hacked to use this to emulate the run length of a device*/
+	effect->hweffect->tickCount = 0;
+
+    /* Get the effect. */
+    //if (SDL_SYS_ToDIEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+    //    goto err_effectdone;
+    //}
+
+    /* Create the actual effect. */
+    //ret = IDirectInputDevice2_CreateEffect(haptic->hwdata->device, type,
+    //                                       &effect->hweffect->effect,
+    //                                       &effect->hweffect->ref, NULL);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Unable to create effect", ret);
+    //    goto err_effectdone;
+    //}
+
+    return 0;
+
+//  err_effectdone:
+//    SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect, base->type);
+  err_hweffect:
+    if (effect->hweffect != NULL) {
+        SDL_free(effect->hweffect);
+        effect->hweffect = NULL;
+    }
+    return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect *effect,
+                           SDL_HapticEffect * data)
+{
+    HRESULT ret;
+    DWORD flags;
+    DIEFFECT temp;
+
+    /* Get the effect. */
+    SDL_memset(&temp, 0, sizeof(DIEFFECT));
+    if (SDL_SYS_ToDIEFFECT(haptic, &temp, data) < 0) {
+        goto err_update;
+    }
+
+    /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+     *  only change those parameters. */
+    flags = DIEP_DIRECTION |
+        DIEP_DURATION |
+        DIEP_ENVELOPE |
+        DIEP_STARTDELAY |
+        DIEP_TRIGGERBUTTON |
+        DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
+
+    /* Create the actual effect. */
+    ret =
+        IDirectInputEffect_SetParameters(effect->hweffect->ref, &temp, flags);
+    if (FAILED(ret)) {
+        DI_SetError("Unable to update effect", ret);
+        goto err_update;
+    }
+
+    /* Copy it over. */
+    SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect, data->type);
+    SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(DIEFFECT));
+
+    return 0;
+
+  err_update:
+    SDL_SYS_HapticFreeDIEFFECT(&temp, data->type);
+    return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect *effect,
+                        Uint32 iterations)
+{
+//    HRESULT ret;
+//    DWORD iter;
+
+	/*Palm Edit: Simulate effect playing by setting the current tick count*/
+	/*This can then be used on GetEffectStatus to see if it has expired by comparison to effect length*/
+	effect->hweffect->tickCount = GetTickCount();
+
+    /* Check if it's infinite. */
+    //if (iterations == SDL_HAPTIC_INFINITY) {
+    //    iter = INFINITE;
+    //} else
+    //    iter = iterations;
+
+    /* Run the effect. */
+    //ret = IDirectInputEffect_Start(effect->hweffect->ref, iter, 0);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Running the effect", ret);
+    //    return -1;
+    //}
+
+    return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect *effect)
+{
+
+	/*Palm Edit: Set tickCount to 0 to emulate effect stopped*/
+	effect->hweffect->tickCount = 0;
+
+    //HRESULT ret;
+
+    //ret = IDirectInputEffect_Stop(effect->hweffect->ref);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Unable to stop effect", ret);
+    //    return -1;
+    //}
+
+    return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect *effect)
+{
+    //HRESULT ret;
+
+    //ret = IDirectInputEffect_Unload(effect->hweffect->ref);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Removing effect from the device", ret);
+    //}
+    SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect,
+                               effect->effect.type);
+    SDL_free(effect->hweffect);
+    effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic,
+                              struct haptic_effect *effect)
+{
+	/*Palm Edit: If tickCount+effectLength is less than curent tick count, then effect is still running*/
+	/*TODO: Perform this with a timer for more accurate results*/
+	DWORD tCount = GetTickCount();
+
+	if (effect->hweffect->tickCount == 0){
+		return 0;
+	}
+	else if( (effect->hweffect->tickCount + 
+				effect->effect.constant.length ) >
+					tCount){
+		return 1;
+	}
+	else{
+		effect->hweffect->tickCount = 0;
+		return 0;
+	}
+
+    //HRESULT ret;
+    //DWORD status;
+
+    //ret = IDirectInputEffect_GetEffectStatus(effect->hweffect->ref, &status);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Getting effect status", ret);
+    //    return -1;
+    //}
+
+    //if (status == 0)
+    //    return SDL_FALSE;
+    //return SDL_TRUE;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+    HRESULT ret;
+    DIPROPDWORD dipdw;
+
+    /* Create the weird structure thingy. */
+    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
+    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    dipdw.diph.dwObj = 0;
+    dipdw.diph.dwHow = DIPH_DEVICE;
+    dipdw.dwData = gain * 100;  /* 0 to 10,000 */
+
+    /* Try to set the autocenter. */
+    ret = IDirectInputDevice2_SetProperty(haptic->hwdata->device,
+                                          DIPROP_FFGAIN, &dipdw.diph);
+    if (FAILED(ret)) {
+        DI_SetError("Setting gain", ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+    HRESULT ret;
+    DIPROPDWORD dipdw;
+
+    /* Create the weird structure thingy. */
+    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
+    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    dipdw.diph.dwObj = 0;
+    dipdw.diph.dwHow = DIPH_DEVICE;
+    dipdw.dwData = (autocenter == 0) ? DIPROPAUTOCENTER_OFF :
+        DIPROPAUTOCENTER_ON;
+
+    /* Try to set the autocenter. */
+    ret = IDirectInputDevice2_SetProperty(haptic->hwdata->device,
+                                          DIPROP_AUTOCENTER, &dipdw.diph);
+    if (FAILED(ret)) {
+        DI_SetError("Setting autocenter", ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+    HRESULT ret;
+
+    /* Pause the device. */
+    ret = IDirectInputDevice2_SendForceFeedbackCommand(haptic->hwdata->device,
+                                                       DISFFC_PAUSE);
+    if (FAILED(ret)) {
+        DI_SetError("Pausing the device", ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+    HRESULT ret;
+
+    /* Unpause the device. */
+    ret = IDirectInputDevice2_SendForceFeedbackCommand(haptic->hwdata->device,
+                                                       DISFFC_CONTINUE);
+    if (FAILED(ret)) {
+        DI_SetError("Pausing the device", ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Stops all the playing effects on the device.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+    //HRESULT ret;
+
+    /* Try to stop the effects. */
+    //ret = IDirectInputDevice2_SendForceFeedbackCommand(haptic->hwdata->device,
+    //                                                   DISFFC_STOPALL);
+    //if (FAILED(ret)) {
+    //    DI_SetError("Stopping the device", ret);
+    //    return -1;
+    //}
+
+    return 0;
+}
+
+int SDL_SYS_HapticMinDuration(haptic)
+{
+	return 0;
+}
+
+SDL_SYS_HapticMaxDuration(haptic)
+{
+	Uint16 i = 0xFF;
+	return i;
+}
+
+#endif /* SDL_HAPTIC_DINPUT */
diff -pruN libsdl-1.2/src/joystick/SDL_sysjoystick.h libsdl-1.2-palm/src/joystick/SDL_sysjoystick.h
--- libsdl-1.2/src/joystick/SDL_sysjoystick.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/joystick/SDL_sysjoystick.h	2009-10-16 14:56:35.000000000 -0700
@@ -80,3 +80,7 @@ extern void SDL_SYS_JoystickClose(SDL_Jo
 /* Function to perform any system-specific joystick related cleanup */
 extern void SDL_SYS_JoystickQuit(void);
 
+#ifdef PALM
+/* Read updated accelerometer state and store locally. */
+extern void SDL_SYS_JoystickEvent(void);
+#endif
diff -pruN libsdl-1.2/src/joystick/webos/SDL_sysjoystick.c libsdl-1.2-palm/src/joystick/webos/SDL_sysjoystick.c
--- libsdl-1.2/src/joystick/webos/SDL_sysjoystick.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/joystick/webos/SDL_sysjoystick.c	2009-10-21 21:26:47.000000000 -0700
@@ -0,0 +1,228 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2009 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+/* This is the system specific header for the SDL joystick API */
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/webos/SDL_WebOsEvent.h"
+
+#define MAX_NUM_EVENTS                   50
+
+static SDL_WebOsHandle pHandle = NULL;
+
+const char *accelerometerName = "webOS accelerometer";
+
+/* Function to scan the system for joysticks.
+ */
+int
+SDL_SYS_JoystickInit(void)
+{
+	pHandle = SDL_WebOsEventOpen(SDL_WEBOS_ACCELEROMETER);
+
+	return (pHandle == NULL) ? 0 : 1;
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char* SDL_SYS_JoystickName(int index)
+{
+	switch(index) {
+		case 0:
+			return accelerometerName;
+		default:
+			SDL_SetError("No joystick available with that index");
+			return NULL;
+	}
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick * joystick)
+{
+	//printf( "SDL_SYS_JoystickOpen %d\n", joystick->index);
+	
+	if (joystick->index == 0) {
+		joystick->naxes = 3;
+		joystick->nhats = 0;
+		joystick->nballs = 0;
+		joystick->nbuttons = 0;
+		joystick->name  = accelerometerName;
+		return 0;
+	}
+	else {
+		SDL_SetError("No joystick available with that index");
+		return (-1);
+	}
+	
+}
+
+typedef union IntFloat
+{
+    float floatForm;
+    int32_t intForm;
+} IntFloat_t;
+
+// Used to clamp incoming values because the driver doesn't.
+#define CLAMP(x) ((x > 1.0f) ? 1.0f : (x < -1.0f) ? -1.0f : x)
+
+static Sint16       Orientation[3];
+static SDL_bool     Updated[3];
+
+/* Read updated accelerometer state and store locally.
+ * Does NOT update the SDL joystick state; that happens in SDL_SYS_JoystickUpdate.
+ * Basically this turns event-based input into polling-based input.
+ */
+void SDL_SYS_JoystickEvent(void)
+{
+    struct timeval  tv = {0,0};
+    IntFloat_t      IntFloat;
+    fd_set          fdset;
+    int             i;
+
+    if (!pHandle) {
+        return;
+    }
+
+    int Fd = SDL_WebOsEventGetFd(pHandle);
+
+    // Check for any events on the socket.
+    FD_ZERO(&fdset);
+    FD_SET(Fd, &fdset);
+    if (select(Fd+1, &fdset, 0, 0, &tv) <= 0) {
+        return;
+    }
+
+    struct input_event aEvents[MAX_NUM_EVENTS];
+    int numEvents = SDL_WebOsEventRead(pHandle, aEvents, sizeof(aEvents)/sizeof(aEvents[0]));
+    if (!numEvents) {
+    	return;
+    }
+    
+    //  printf("SDL_SYS_JoystickUpdate: Read %d events\n", numEvents);
+
+    /* Updating state which may be read in the main thread */
+    SDL_Lock_EventThread();
+
+    for (i = 0; i < numEvents; i++)
+    {
+        switch (aEvents[i].type)
+        {
+            case EV_ABS:
+                switch (aEvents[i].code)
+                {
+                    case ABS_X:
+                        IntFloat.intForm = aEvents[i].value;
+                        //printf("x: %1.3f\n", IntFloat.floatForm);
+                        Orientation[0] = (CLAMP(IntFloat.floatForm) * ((1 << 15) - 1));
+                        Updated[0] = SDL_TRUE;
+                        break;
+
+                    case ABS_Y:
+                        IntFloat.intForm = aEvents[i].value;
+                        //printf("y: %1.3f\n", IntFloat.floatForm);
+                        Orientation[1] = -(CLAMP(IntFloat.floatForm) * ((1 << 15) - 1));
+                        Updated[1] = SDL_TRUE;
+                        break;
+
+                    case ABS_Z:
+                        IntFloat.intForm = aEvents[i].value;
+                        //printf("z: %1.3f\n", IntFloat.floatForm);
+                        Orientation[2] = (CLAMP(IntFloat.floatForm) * ((1 << 15) - 1));
+                        Updated[2] = SDL_TRUE;
+                        break;
+
+                    default:
+                        break;
+                }
+
+            case EV_SYN:
+                // Sync event ignored.
+                break;
+
+            default:
+                //printf("unhandled event: %d\n", aEvents[i].type);
+                break;
+        }
+    }
+
+    SDL_Unlock_EventThread();
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+void SDL_SYS_JoystickUpdate(SDL_Joystick * joystick)
+{
+    /* Since this may be called:
+     *  a) from the event thread (event mode)
+     *  b) from the main thread (polling mode, if the user calls SDL_JoystickEventState(SDL_IGNORE))
+     *
+     * ... we need to lock access to the shared state.
+     */
+    SDL_Lock_EventThread();
+
+	if (Updated[0]) {
+	    SDL_PrivateJoystickAxis(joystick, 0, Orientation[0]);
+	    Updated[0] = SDL_FALSE;
+	}
+	if (Updated[1]) {
+	    SDL_PrivateJoystickAxis(joystick, 1, Orientation[1]);
+	    Updated[1] = SDL_FALSE;
+	}
+	if (Updated[2]) {
+	    SDL_PrivateJoystickAxis(joystick, 2, Orientation[2]);
+	    Updated[2] = SDL_FALSE;
+	}
+
+	SDL_Unlock_EventThread();
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick * joystick)
+{
+#if 0
+	if (joystick->index == 0 && [[SDLUIAccelerationDelegate sharedDelegate] isRunning]) {
+		[[SDLUIAccelerationDelegate sharedDelegate] shutdown];
+	}
+	SDL_SetError("No joystick open with that index");
+#endif
+	
+    return;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+	SDL_WebOsEventClose(pHandle);
+}
+
diff -pruN libsdl-1.2/src/SDL.c libsdl-1.2-palm/src/SDL.c
--- libsdl-1.2/src/SDL.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/SDL.c	2009-12-03 16:37:28.000000000 -0800
@@ -1,350 +1,408 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2006 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* Initialization code for SDL */
-
-#include "SDL.h"
-#include "SDL_fatal.h"
-#if !SDL_VIDEO_DISABLED
-#include "video/SDL_leaks.h"
-#endif
-
-#if SDL_THREAD_PTH
-#include <pth.h>
-#endif
-
-/* Initialization/Cleanup routines */
-#if !SDL_JOYSTICK_DISABLED
-extern int  SDL_JoystickInit(void);
-extern void SDL_JoystickQuit(void);
-#endif
-#if !SDL_CDROM_DISABLED
-extern int  SDL_CDROMInit(void);
-extern void SDL_CDROMQuit(void);
-#endif
-#if !SDL_TIMERS_DISABLED
-extern void SDL_StartTicks(void);
-extern int  SDL_TimerInit(void);
-extern void SDL_TimerQuit(void);
-#endif
-
-/* The current SDL version */
-static SDL_version version = 
-	{ SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL };
-
-/* The initialized subsystems */
-static Uint32 SDL_initialized = 0;
-#if !SDL_TIMERS_DISABLED
-static Uint32 ticks_started = 0;
-#endif
-
-#ifdef CHECK_LEAKS
-int surfaces_allocated = 0;
-#endif
-
-int SDL_InitSubSystem(Uint32 flags)
-{
-#if !SDL_VIDEO_DISABLED
-	/* Initialize the video/event subsystem */
-	if ( (flags & SDL_INIT_VIDEO) && !(SDL_initialized & SDL_INIT_VIDEO) ) {
-		if ( SDL_VideoInit(SDL_getenv("SDL_VIDEODRIVER"),
-		                   (flags&SDL_INIT_EVENTTHREAD)) < 0 ) {
-			return(-1);
-		}
-		SDL_initialized |= SDL_INIT_VIDEO;
-	}
-#else
-	if ( flags & SDL_INIT_VIDEO ) {
-		SDL_SetError("SDL not built with video support");
-		return(-1);
-	}
-#endif
-
-#if !SDL_AUDIO_DISABLED
-	/* Initialize the audio subsystem */
-	if ( (flags & SDL_INIT_AUDIO) && !(SDL_initialized & SDL_INIT_AUDIO) ) {
-		if ( SDL_AudioInit(SDL_getenv("SDL_AUDIODRIVER")) < 0 ) {
-			return(-1);
-		}
-		SDL_initialized |= SDL_INIT_AUDIO;
-	}
-#else
-	if ( flags & SDL_INIT_AUDIO ) {
-		SDL_SetError("SDL not built with audio support");
-		return(-1);
-	}
-#endif
-
-#if !SDL_TIMERS_DISABLED
-	/* Initialize the timer subsystem */
-	if ( ! ticks_started ) {
-		SDL_StartTicks();
-		ticks_started = 1;
-	}
-	if ( (flags & SDL_INIT_TIMER) && !(SDL_initialized & SDL_INIT_TIMER) ) {
-		if ( SDL_TimerInit() < 0 ) {
-			return(-1);
-		}
-		SDL_initialized |= SDL_INIT_TIMER;
-	}
-#else
-	if ( flags & SDL_INIT_TIMER ) {
-		SDL_SetError("SDL not built with timer support");
-		return(-1);
-	}
-#endif
-
-#if !SDL_JOYSTICK_DISABLED
-	/* Initialize the joystick subsystem */
-	if ( (flags & SDL_INIT_JOYSTICK) &&
-	     !(SDL_initialized & SDL_INIT_JOYSTICK) ) {
-		if ( SDL_JoystickInit() < 0 ) {
-			return(-1);
-		}
-		SDL_initialized |= SDL_INIT_JOYSTICK;
-	}
-#else
-	if ( flags & SDL_INIT_JOYSTICK ) {
-		SDL_SetError("SDL not built with joystick support");
-		return(-1);
-	}
-#endif
-
-#if !SDL_CDROM_DISABLED
-	/* Initialize the CD-ROM subsystem */
-	if ( (flags & SDL_INIT_CDROM) && !(SDL_initialized & SDL_INIT_CDROM) ) {
-		if ( SDL_CDROMInit() < 0 ) {
-			return(-1);
-		}
-		SDL_initialized |= SDL_INIT_CDROM;
-	}
-#else
-	if ( flags & SDL_INIT_CDROM ) {
-		SDL_SetError("SDL not built with cdrom support");
-		return(-1);
-	}
-#endif
-	return(0);
-}
-
-int SDL_Init(Uint32 flags)
-{
-#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
-	if (!pth_init()) {
-		return -1;
-	}
-#endif
-
-	/* Clear the error message */
-	SDL_ClearError();
-
-	/* Initialize the desired subsystems */
-	if ( SDL_InitSubSystem(flags) < 0 ) {
-		return(-1);
-	}
-
-	/* Everything is initialized */
-	if ( !(flags & SDL_INIT_NOPARACHUTE) ) {
-		SDL_InstallParachute();
-	}
-	return(0);
-}
-
-void SDL_QuitSubSystem(Uint32 flags)
-{
-	/* Shut down requested initialized subsystems */
-#if !SDL_CDROM_DISABLED
-	if ( (flags & SDL_initialized & SDL_INIT_CDROM) ) {
-		SDL_CDROMQuit();
-		SDL_initialized &= ~SDL_INIT_CDROM;
-	}
-#endif
-#if !SDL_JOYSTICK_DISABLED
-	if ( (flags & SDL_initialized & SDL_INIT_JOYSTICK) ) {
-		SDL_JoystickQuit();
-		SDL_initialized &= ~SDL_INIT_JOYSTICK;
-	}
-#endif
-#if !SDL_TIMERS_DISABLED
-	if ( (flags & SDL_initialized & SDL_INIT_TIMER) ) {
-		SDL_TimerQuit();
-		SDL_initialized &= ~SDL_INIT_TIMER;
-	}
-#endif
-#if !SDL_AUDIO_DISABLED
-	if ( (flags & SDL_initialized & SDL_INIT_AUDIO) ) {
-		SDL_AudioQuit();
-		SDL_initialized &= ~SDL_INIT_AUDIO;
-	}
-#endif
-#if !SDL_VIDEO_DISABLED
-	if ( (flags & SDL_initialized & SDL_INIT_VIDEO) ) {
-		SDL_VideoQuit();
-		SDL_initialized &= ~SDL_INIT_VIDEO;
-	}
-#endif
-}
-
-Uint32 SDL_WasInit(Uint32 flags)
-{
-	if ( ! flags ) {
-		flags = SDL_INIT_EVERYTHING;
-	}
-	return (SDL_initialized&flags);
-}
-
-void SDL_Quit(void)
-{
-	/* Quit all subsystems */
-#ifdef DEBUG_BUILD
-  printf("[SDL_Quit] : Enter! Calling QuitSubSystem()\n"); fflush(stdout);
-#endif
-	SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
-
-#ifdef CHECK_LEAKS
-#ifdef DEBUG_BUILD
-  printf("[SDL_Quit] : CHECK_LEAKS\n"); fflush(stdout);
-#endif
-
-	/* Print the number of surfaces not freed */
-	if ( surfaces_allocated != 0 ) {
-		fprintf(stderr, "SDL Warning: %d SDL surfaces extant\n", 
-							surfaces_allocated);
-	}
-#endif
-#ifdef DEBUG_BUILD
-  printf("[SDL_Quit] : SDL_UninstallParachute()\n"); fflush(stdout);
-#endif
-
-	/* Uninstall any parachute signal handlers */
-	SDL_UninstallParachute();
-
-#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
-	pth_kill();
-#endif
-#ifdef DEBUG_BUILD
-  printf("[SDL_Quit] : Returning!\n"); fflush(stdout);
-#endif
-
-}
-
-/* Return the library version number */
-const SDL_version * SDL_Linked_Version(void)
-{
-	return(&version);
-}
-
-#if defined(__OS2__)
-/* Building for OS/2 */
-#ifdef __WATCOMC__
-
-#define INCL_DOSERRORS
-#define INCL_DOSEXCEPTIONS
-#include <os2.h>
-
-/* Exception handler to prevent the Audio thread hanging, making a zombie process! */
-ULONG _System SDL_Main_ExceptionHandler(PEXCEPTIONREPORTRECORD pERepRec,
-                                        PEXCEPTIONREGISTRATIONRECORD pERegRec,
-                                        PCONTEXTRECORD pCtxRec,
-                                        PVOID p)
-{
-  if (pERepRec->fHandlerFlags & EH_EXIT_UNWIND)
-    return XCPT_CONTINUE_SEARCH;
-  if (pERepRec->fHandlerFlags & EH_UNWINDING)
-    return XCPT_CONTINUE_SEARCH;
-  if (pERepRec->fHandlerFlags & EH_NESTED_CALL)
-    return XCPT_CONTINUE_SEARCH;
-
-  /* Do cleanup at every fatal exception! */
-  if (((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) == XCPT_FATAL_EXCEPTION) &&
-      (pERepRec->ExceptionNum != XCPT_BREAKPOINT) &&
-      (pERepRec->ExceptionNum != XCPT_SINGLE_STEP)
-     )
-  {
-    if (SDL_initialized & SDL_INIT_AUDIO)
-    {
-      /* This removes the zombie audio thread in case of emergency. */
-#ifdef DEBUG_BUILD
-      printf("[SDL_Main_ExceptionHandler] : Calling SDL_CloseAudio()!\n");
-#endif
-      SDL_CloseAudio();
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Initialization code for SDL */
+
+#include "SDL.h"
+#include "SDL_fatal.h"
+#if !SDL_VIDEO_DISABLED
+#include "video/SDL_leaks.h"
+#endif
+
+#ifdef PALM
+#include "events/webos/SDL_WebOsEvent.h"    /* for SDL_WebOsEventQuit */
+#include "video/fbcon/SDL_fbvideo.h"        /* for FB_Blank */
+#endif
+
+#if SDL_THREAD_PTH
+#include <pth.h>
+#endif
+
+/* Initialization/Cleanup routines */
+#if !SDL_JOYSTICK_DISABLED
+extern int  SDL_JoystickInit(void);
+extern void SDL_JoystickQuit(void);
+#endif
+#if !SDL_HAPTIC_DISABLED
+extern int SDL_HapticInit(void);
+extern int SDL_HapticQuit(void);
+#endif
+#if !SDL_CDROM_DISABLED
+extern int  SDL_CDROMInit(void);
+extern void SDL_CDROMQuit(void);
+#endif
+#if !SDL_TIMERS_DISABLED
+extern void SDL_StartTicks(void);
+extern int  SDL_TimerInit(void);
+extern void SDL_TimerQuit(void);
+#endif
+
+/* The current SDL version */
+static SDL_version version = 
+	{ SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL };
+
+/* The initialized subsystems */
+static Uint32 SDL_initialized = 0;
+#if !SDL_TIMERS_DISABLED
+static Uint32 ticks_started = 0;
+#endif
+
+#ifdef CHECK_LEAKS
+int surfaces_allocated = 0;
+#endif
+
+int SDL_InitSubSystem(Uint32 flags)
+{
+#if !SDL_VIDEO_DISABLED
+	/* Initialize the video/event subsystem */
+	if ( (flags & SDL_INIT_VIDEO) && !(SDL_initialized & SDL_INIT_VIDEO) ) {
+		if ( SDL_VideoInit(SDL_getenv("SDL_VIDEODRIVER"),
+		                   (flags&SDL_INIT_EVENTTHREAD)) < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_VIDEO;
+	}
+#else
+	if ( flags & SDL_INIT_VIDEO ) {
+		SDL_SetError("SDL not built with video support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_AUDIO_DISABLED
+	/* Initialize the audio subsystem */
+	if ( (flags & SDL_INIT_AUDIO) && !(SDL_initialized & SDL_INIT_AUDIO) ) {
+		if ( SDL_AudioInit(SDL_getenv("SDL_AUDIODRIVER")) < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_AUDIO;
+	}
+#else
+	if ( flags & SDL_INIT_AUDIO ) {
+		SDL_SetError("SDL not built with audio support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_TIMERS_DISABLED
+	/* Initialize the timer subsystem */
+	if ( ! ticks_started ) {
+		SDL_StartTicks();
+		ticks_started = 1;
+	}
+	if ( (flags & SDL_INIT_TIMER) && !(SDL_initialized & SDL_INIT_TIMER) ) {
+		if ( SDL_TimerInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_TIMER;
+	}
+#else
+	if ( flags & SDL_INIT_TIMER ) {
+		SDL_SetError("SDL not built with timer support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_JOYSTICK_DISABLED
+	/* Initialize the joystick subsystem */
+	if ( (flags & SDL_INIT_JOYSTICK) &&
+	     !(SDL_initialized & SDL_INIT_JOYSTICK) ) {
+		if ( SDL_JoystickInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_JOYSTICK;
+	}
+#else
+	if ( flags & SDL_INIT_JOYSTICK ) {
+		SDL_SetError("SDL not built with joystick support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_CDROM_DISABLED
+	/* Initialize the CD-ROM subsystem */
+	if ( (flags & SDL_INIT_CDROM) && !(SDL_initialized & SDL_INIT_CDROM) ) {
+		if ( SDL_CDROMInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_CDROM;
+	}
+#else
+	if ( flags & SDL_INIT_CDROM ) {
+		SDL_SetError("SDL not built with cdrom support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_HAPTIC_DISABLED
+    /* Initialize the haptic subsystem */
+    if ((flags & SDL_INIT_HAPTIC) && !(SDL_initialized & SDL_INIT_HAPTIC)) {
+        if (SDL_HapticInit() < 0) {
+            return (-1);
+        }
+        SDL_initialized |= SDL_INIT_HAPTIC;
+    }
+#else
+    if (flags & SDL_INIT_HAPTIC) {
+        SDL_SetError("SDL not built with haptic (force feedback) support");
+        return (-1);
+    }
+#endif
+
+	return(0);
+}
+
+#ifdef PALM
+void SDL_HighPriorityQuit(void)
+{
+    /* Any functions here must support being called more than once */
+    FB_Blank();
+    SDL_WebOsEventQuit();
+}
+#endif
+
+int SDL_Init(Uint32 flags)
+{
+#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
+	if (!pth_init()) {
+		return -1;
+	}
+#endif
+
+	/* Clear the error message */
+	SDL_ClearError();
+
+	/* Initialize the desired subsystems */
+	if ( SDL_InitSubSystem(flags) < 0 ) {
+		return(-1);
+	}
+
+	/* Everything is initialized */
+#ifndef PALM
+	// PALM; do not install parachutes because inevitably cleanup code calls malloc or free
+	// which can deadlock the app if the signal is handled while the app is in malloc or free.
+	// Necessary cleanup must be handled in some other way.
+	if ( !(flags & SDL_INIT_NOPARACHUTE) ) {
+		SDL_InstallParachute();
+	}
+#endif
+
+#ifdef PALM
+	/* Ensure certain cleanup happens even if the app forgets to call SDL_Quit on exit */
+	atexit(SDL_HighPriorityQuit);
+#endif
+
+	return(0);
+}
+
+void SDL_QuitSubSystem(Uint32 flags)
+{
+	/* Shut down requested initialized subsystems */
+#if !SDL_CDROM_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_CDROM) ) {
+		SDL_CDROMQuit();
+		SDL_initialized &= ~SDL_INIT_CDROM;
+	}
+#endif
+#if !SDL_JOYSTICK_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_JOYSTICK) ) {
+		SDL_JoystickQuit();
+		SDL_initialized &= ~SDL_INIT_JOYSTICK;
+	}
+#endif
+#if !SDL_HAPTIC_DISABLED
+    if ((flags & SDL_initialized & SDL_INIT_HAPTIC)) {
+        SDL_HapticQuit();
+        SDL_initialized &= ~SDL_INIT_HAPTIC;
     }
-  }
-  return (XCPT_CONTINUE_SEARCH);
-}
-
-
-EXCEPTIONREGISTRATIONRECORD SDL_Main_xcpthand = {0, SDL_Main_ExceptionHandler};
-
-/* The main DLL entry for DLL Initialization and Uninitialization: */
-unsigned _System LibMain(unsigned hmod, unsigned termination)
-{
-  if (termination)
-  {
-#ifdef DEBUG_BUILD
-/*    printf("[SDL DLL Unintialization] : Removing exception handler\n"); */
-#endif
-    DosUnsetExceptionHandler(&SDL_Main_xcpthand);
-    return 1;
-  } else
-  {
-#ifdef DEBUG_BUILD
-    /* Make stdout and stderr unbuffered! */
-    setbuf(stdout, NULL);
-    setbuf(stderr, NULL);
-#endif
-    /* Fire up exception handler */
-#ifdef DEBUG_BUILD
-/*    printf("[SDL DLL Initialization] : Setting exception handler\n"); */
-#endif
-    /* Set exception handler */
-    DosSetExceptionHandler(&SDL_Main_xcpthand);
-
-    return 1;
-  }
-}
-#endif /* __WATCOMC__ */
-
-#elif defined(__WIN32__)  && !defined(__SYMBIAN32__)
-
-#if !defined(HAVE_LIBC) || (defined(__WATCOMC__) && defined(BUILD_DLL))
-/* Need to include DllMain() on Watcom C for some reason.. */
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
-BOOL APIENTRY _DllMainCRTStartup( HANDLE hModule, 
-                       DWORD  ul_reason_for_call, 
-                       LPVOID lpReserved )
-{
-	switch (ul_reason_for_call) {
-		case DLL_PROCESS_ATTACH:
-		case DLL_THREAD_ATTACH:
-		case DLL_THREAD_DETACH:
-		case DLL_PROCESS_DETACH:
-			break;
-	}
-	return TRUE;
-}
-#endif /* building DLL with Watcom C */
-
-#endif /* OS/2 elif __WIN32__ */
+#endif
+#if !SDL_TIMERS_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_TIMER) ) {
+		SDL_TimerQuit();
+		SDL_initialized &= ~SDL_INIT_TIMER;
+	}
+#endif
+#if !SDL_AUDIO_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_AUDIO) ) {
+		SDL_AudioQuit();
+		SDL_initialized &= ~SDL_INIT_AUDIO;
+	}
+#endif
+#if !SDL_VIDEO_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_VIDEO) ) {
+		SDL_VideoQuit();
+		SDL_initialized &= ~SDL_INIT_VIDEO;
+	}
+#endif
+}
+
+Uint32 SDL_WasInit(Uint32 flags)
+{
+	if ( ! flags ) {
+		flags = SDL_INIT_EVERYTHING;
+	}
+	return (SDL_initialized&flags);
+}
+
+void SDL_Quit(void)
+{
+#ifdef PALM
+    /* Do the most important quit items first (especially those that, if they do not happen,
+     * could leave the device in a bad state.  The rest of the quit process may crash.
+     */
+    SDL_HighPriorityQuit();
+#endif
+
+	/* Quit all subsystems */
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : Enter! Calling QuitSubSystem()\n"); fflush(stdout);
+#endif
+	SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
+
+#ifdef CHECK_LEAKS
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : CHECK_LEAKS\n"); fflush(stdout);
+#endif
+
+	/* Print the number of surfaces not freed */
+	if ( surfaces_allocated != 0 ) {
+		fprintf(stderr, "SDL Warning: %d SDL surfaces extant\n", 
+							surfaces_allocated);
+	}
+#endif
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : SDL_UninstallParachute()\n"); fflush(stdout);
+#endif
+
+	/* Uninstall any parachute signal handlers */
+	SDL_UninstallParachute();
+
+#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
+	pth_kill();
+#endif
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : Returning!\n"); fflush(stdout);
+#endif
+
+}
+
+/* Return the library version number */
+const SDL_version * SDL_Linked_Version(void)
+{
+	return(&version);
+}
+
+#if defined(__OS2__)
+/* Building for OS/2 */
+#ifdef __WATCOMC__
+
+#define INCL_DOSERRORS
+#define INCL_DOSEXCEPTIONS
+#include <os2.h>
+
+/* Exception handler to prevent the Audio thread hanging, making a zombie process! */
+ULONG _System SDL_Main_ExceptionHandler(PEXCEPTIONREPORTRECORD pERepRec,
+                                        PEXCEPTIONREGISTRATIONRECORD pERegRec,
+                                        PCONTEXTRECORD pCtxRec,
+                                        PVOID p)
+{
+  if (pERepRec->fHandlerFlags & EH_EXIT_UNWIND)
+    return XCPT_CONTINUE_SEARCH;
+  if (pERepRec->fHandlerFlags & EH_UNWINDING)
+    return XCPT_CONTINUE_SEARCH;
+  if (pERepRec->fHandlerFlags & EH_NESTED_CALL)
+    return XCPT_CONTINUE_SEARCH;
+
+  /* Do cleanup at every fatal exception! */
+  if (((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) == XCPT_FATAL_EXCEPTION) &&
+      (pERepRec->ExceptionNum != XCPT_BREAKPOINT) &&
+      (pERepRec->ExceptionNum != XCPT_SINGLE_STEP)
+     )
+  {
+    if (SDL_initialized & SDL_INIT_AUDIO)
+    {
+      /* This removes the zombie audio thread in case of emergency. */
+#ifdef DEBUG_BUILD
+      printf("[SDL_Main_ExceptionHandler] : Calling SDL_CloseAudio()!\n");
+#endif
+      SDL_CloseAudio();
+    }
+  }
+  return (XCPT_CONTINUE_SEARCH);
+}
+
+
+EXCEPTIONREGISTRATIONRECORD SDL_Main_xcpthand = {0, SDL_Main_ExceptionHandler};
+
+/* The main DLL entry for DLL Initialization and Uninitialization: */
+unsigned _System LibMain(unsigned hmod, unsigned termination)
+{
+  if (termination)
+  {
+#ifdef DEBUG_BUILD
+/*    printf("[SDL DLL Unintialization] : Removing exception handler\n"); */
+#endif
+    DosUnsetExceptionHandler(&SDL_Main_xcpthand);
+    return 1;
+  } else
+  {
+#ifdef DEBUG_BUILD
+    /* Make stdout and stderr unbuffered! */
+    setbuf(stdout, NULL);
+    setbuf(stderr, NULL);
+#endif
+    /* Fire up exception handler */
+#ifdef DEBUG_BUILD
+/*    printf("[SDL DLL Initialization] : Setting exception handler\n"); */
+#endif
+    /* Set exception handler */
+    DosSetExceptionHandler(&SDL_Main_xcpthand);
+
+    return 1;
+  }
+}
+#endif /* __WATCOMC__ */
+
+#elif defined(__WIN32__)  && !defined(__SYMBIAN32__)
+
+#if !defined(HAVE_LIBC) || (defined(__WATCOMC__) && defined(BUILD_DLL))
+/* Need to include DllMain() on Watcom C for some reason.. */
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+BOOL APIENTRY _DllMainCRTStartup( HANDLE hModule, 
+                       DWORD  ul_reason_for_call, 
+                       LPVOID lpReserved )
+{
+	switch (ul_reason_for_call) {
+		case DLL_PROCESS_ATTACH:
+		case DLL_THREAD_ATTACH:
+		case DLL_THREAD_DETACH:
+		case DLL_PROCESS_DETACH:
+			break;
+	}
+	return TRUE;
+}
+#endif /* building DLL with Watcom C */
+
+#endif /* OS/2 elif __WIN32__ */
diff -pruN libsdl-1.2/src/SDL_fatal.c libsdl-1.2-palm/src/SDL_fatal.c
--- libsdl-1.2/src/SDL_fatal.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/SDL_fatal.c	2009-11-23 00:46:27.000000000 -0800
@@ -30,6 +30,10 @@
 #include "SDL.h"
 #include "SDL_fatal.h"
 
+#ifdef PALM
+#include "events/SDL_events_c.h" /* for SDL_HighPriorityQuit */
+#endif
+
 /* This installs some signal handlers for the more common fatal signals,
    so that if the programmer is lazy, the app doesn't die so horribly if
    the program crashes.
@@ -38,7 +42,15 @@
 static void SDL_Parachute(int sig)
 {
 	signal(sig, SIG_DFL);
+#ifdef PALM
+	/* SDL_Quit is not really signal-safe; it frees memory, for example, which could hang
+	 * if the application crashed while holding an allocator lock.
+	 * Do only the high priority stuff here.
+	 */
+	SDL_HighPriorityQuit();
+#else
 	SDL_Quit();
+#endif
 	raise(sig);
 }
 
diff -pruN libsdl-1.2/src/thread/pthread/SDL_syssem.c libsdl-1.2-palm/src/thread/pthread/SDL_syssem.c
--- libsdl-1.2/src/thread/pthread/SDL_syssem.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/thread/pthread/SDL_syssem.c	2009-11-12 11:31:13.000000000 -0800
@@ -24,6 +24,9 @@
 #include <pthread.h>
 #include <semaphore.h>
 #include <errno.h>
+#ifdef PALM
+#include <sys/time.h>
+#endif
 
 #include "SDL_thread.h"
 #include "SDL_timer.h"
@@ -111,6 +114,28 @@ int SDL_SemWaitTimeout(SDL_sem *sem, Uin
 		return SDL_SemWait(sem);
 	}
 
+#ifdef PALM
+	/* abstime calculation cloned from pthread SDL_CondWaitTimeout */
+	struct timeval curtime;
+    struct timespec abstime;
+
+    gettimeofday(&curtime, NULL);
+
+    abstime.tv_sec = curtime.tv_sec + (timeout/1000);
+    abstime.tv_nsec = (curtime.tv_usec + (timeout%1000) * 1000) * 1000;
+    if ( abstime.tv_nsec > 1000000000 ) {
+        abstime.tv_sec += 1;
+        abstime.tv_nsec -= 1000000000;
+    }
+
+    while ( (retval = sem_timedwait(sem, &abstime)) == -1 && (errno == EINTR)) {
+        /* Loop */
+    }
+
+    if (retval == -1 && errno == ETIMEDOUT) {
+        retval = SDL_MUTEX_TIMEDOUT;
+    }
+#else
 	/* Ack!  We have to busy wait... */
 	/* FIXME: Use sem_timedwait()? */
 	timeout += SDL_GetTicks();
@@ -121,6 +146,7 @@ int SDL_SemWaitTimeout(SDL_sem *sem, Uin
 		}
 		SDL_Delay(1);
 	} while ( SDL_GetTicks() < timeout );
+#endif
 
 	return retval;
 }
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbevents.c libsdl-1.2-palm/src/video/fbcon/SDL_fbevents.c
--- libsdl-1.2/src/video/fbcon/SDL_fbevents.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbevents.c	2009-11-06 21:25:16.000000000 -0800
@@ -58,6 +58,12 @@
 /*#define DEBUG_KEYBOARD*/
 /*#define DEBUG_MOUSE*/
 
+#ifdef PALM
+#include "../../events/webos/SDL_WebOsEvent.h"
+static SDL_WebOsHandle pHandle = NULL;
+int DoOverlay = 0;
+#endif
+
 /* The translation tables from a console scancode to a SDL keysym */
 #define NUM_VGAKEYMAPS	(1<<KG_CAPSSHIFT)
 static Uint16 vga_keymap[NUM_VGAKEYMAPS][NR_KEYS];
@@ -65,6 +71,15 @@ static SDLKey keymap[128];
 static Uint16 keymap_temp[128]; /* only used at startup */
 static SDL_keysym *TranslateKey(int scancode, SDL_keysym *keysym);
 
+// PALM
+static int input_xform_enabled;
+static int input_rotate;
+static int input_xoffset;
+static float input_scale = 1.0f;
+static int input_rect_x, input_rect_width;
+static int input_rect_y, input_rect_height;
+///PALM
+
 /* Ugh, we have to duplicate the kernel's keysym mapping code...
    Oh, it's not so bad. :-)
 
@@ -166,9 +181,18 @@ int FB_EnterGraphicsMode(_THIS)
 			if ( ioctl(keyboard_fd, VT_GETSTATE, &vtstate) == 0 ) {
 				saved_vt = vtstate.v_active;
 			}
-			if ( ioctl(keyboard_fd, VT_ACTIVATE, current_vt) == 0 ) {
-				ioctl(keyboard_fd, VT_WAITACTIVE, current_vt);
+
+#ifdef PALM
+			// Don't switch if we're already at the correct VT.
+			// webOS doesn't seem to like the WAITACTIVE.
+			if (saved_vt != current_vt) {
+#endif			
+				if ( ioctl(keyboard_fd, VT_ACTIVATE, current_vt) == 0 ) {
+					ioctl(keyboard_fd, VT_WAITACTIVE, current_vt);
+				}
+#ifdef PALM
 			}
+#endif			
 		}
 
 		/* Set the terminal input mode */
@@ -240,6 +264,13 @@ void FB_CloseKeyboard(_THIS)
 		}
 	}
 	keyboard_fd = -1;
+	
+#ifdef PALM
+	if (pHandle) {
+		SDL_WebOsEventClose(pHandle);
+		pHandle = NULL;
+	}
+#endif	
 }
 
 int FB_OpenKeyboard(_THIS)
@@ -250,51 +281,63 @@ int FB_OpenKeyboard(_THIS)
 		static const char * const vcs[] = { "/dev/vc/%d", "/dev/tty%d", NULL };
 		int i, tty0_fd;
 
-		/* Try to query for a free virtual terminal */
-		tty0_fd = -1;
-		for ( i=0; tty0[i] && (tty0_fd < 0); ++i ) {
-			tty0_fd = open(tty0[i], O_WRONLY, 0);
-		}
-		if ( tty0_fd < 0 ) {
-			tty0_fd = dup(0); /* Maybe stdin is a VT? */
-		}
-		ioctl(tty0_fd, VT_OPENQRY, &current_vt);
-		close(tty0_fd);
-		if ( (geteuid() == 0) && (current_vt > 0) ) {
-			for ( i=0; vcs[i] && (keyboard_fd < 0); ++i ) {
-				char vtpath[12];
-
-				SDL_snprintf(vtpath, SDL_arraysize(vtpath), vcs[i], current_vt);
-				keyboard_fd = open(vtpath, O_RDWR, 0);
+#ifdef PALM
+		struct vt_stat vtstate;
+			
+		keyboard_fd = open("/dev/console", O_RDWR);
+		if (keyboard_fd >= 0 && ioctl(keyboard_fd, VT_GETSTATE, &vtstate) == 0 ) {
+			current_vt = vtstate.v_active;
+			pHandle = SDL_WebOsEventOpen(SDL_WEBOS_KEYPAD);
+		}
+#endif
+		if (current_vt < 0) {
+			/* Try to query for a free virtual terminal */
+			tty0_fd = -1;
+			for ( i=0; tty0[i] && (tty0_fd < 0); ++i ) {
+				tty0_fd = open(tty0[i], O_WRONLY, 0);
+			}
+			if ( tty0_fd < 0 ) {
+				tty0_fd = dup(0); /* Maybe stdin is a VT? */
+			}
+			ioctl(tty0_fd, VT_OPENQRY, &current_vt);
+			close(tty0_fd);
+			if ( (geteuid() == 0) && (current_vt > 0) ) {
+				for ( i=0; vcs[i] && (keyboard_fd < 0); ++i ) {
+					char vtpath[12];
+					
+					SDL_snprintf(vtpath, SDL_arraysize(vtpath), vcs[i], current_vt);
+					keyboard_fd = open(vtpath, O_RDWR, 0);
 #ifdef DEBUG_KEYBOARD
-				fprintf(stderr, "vtpath = %s, fd = %d\n",
-					vtpath, keyboard_fd);
+					fprintf(stderr, "vtpath = %s, fd = %d\n",
+							vtpath, keyboard_fd);
 #endif /* DEBUG_KEYBOARD */
-
-				/* This needs to be our controlling tty
-				   so that the kernel ioctl() calls work
-				*/
-				if ( keyboard_fd >= 0 ) {
-					tty0_fd = open("/dev/tty", O_RDWR, 0);
-					if ( tty0_fd >= 0 ) {
-						ioctl(tty0_fd, TIOCNOTTY, 0);
-						close(tty0_fd);
+					
+					/* This needs to be our controlling tty
+					   so that the kernel ioctl() calls work
+					*/
+					if ( keyboard_fd >= 0 ) {
+						tty0_fd = open("/dev/tty", O_RDWR, 0);
+						if ( tty0_fd >= 0 ) {
+							ioctl(tty0_fd, TIOCNOTTY, 0);
+							close(tty0_fd);
+						}
 					}
 				}
 			}
-		}
- 		if ( keyboard_fd < 0 ) {
-			/* Last resort, maybe our tty is a usable VT */
-			struct vt_stat vtstate;
-
-			keyboard_fd = open("/dev/tty", O_RDWR);
-
-			if ( ioctl(keyboard_fd, VT_GETSTATE, &vtstate) == 0 ) {
-				current_vt = vtstate.v_active;
-			} else {
-				current_vt = 0;
+			if ( keyboard_fd < 0 ) {
+				/* Last resort, maybe our tty is a usable VT */
+				struct vt_stat vtstate;
+				
+				keyboard_fd = open("/dev/tty", O_RDWR);
+				
+				if ( ioctl(keyboard_fd, VT_GETSTATE, &vtstate) == 0 ) {
+					current_vt = vtstate.v_active;
+				} else {
+					current_vt = 0;
+				}
 			}
- 		}
+		}
+		
 #ifdef DEBUG_KEYBOARD
 		fprintf(stderr, "Current VT: %d\n", current_vt);
 #endif
@@ -549,6 +592,11 @@ int FB_OpenMouse(_THIS)
 	mousedev = SDL_getenv("SDL_MOUSEDEV");
 	mouse_fd = -1;
 
+#ifdef PALM
+	mousedrv = "TSLIB";
+	mousedev = "DUMMYDEV";
+#endif
+
 #if SDL_INPUT_TSLIB
 	if ( mousedrv && (SDL_strcmp(mousedrv, "TSLIB") == 0) ) {
 		if (mousedev == NULL) mousedev = SDL_getenv("TSLIB_TSDEVICE");
@@ -703,7 +751,8 @@ fprintf(stderr, "Using (default) MS mous
 
 static int posted = 0;
 
-void FB_vgamousecallback(int button, int relative, int dx, int dy)
+//PALM
+void FB_vgamousecallbackExt(int which, int button, int relative, int dx, int dy)
 {
 	int button_1, button_3;
 	int button_state;
@@ -711,8 +760,53 @@ void FB_vgamousecallback(int button, int
 	int i;
 	Uint8 state;
 
+	// PALM
+	if (which >= SDL_MAXMOUSE) {
+#ifdef DEBUG_MOUSE
+	    fprintf(stderr, "Mouse id out of range: %d\n", which);
+#endif	    
+	    return;
+	}
+
+	if (input_xform_enabled) {		
+		if (input_rotate) {
+			int save_dy = dy;
+			dy = input_xoffset - dx;
+			dx = save_dy;
+
+		    dx -= input_rect_y;
+		    dy -= input_rect_x;
+		}
+		else {
+            // Make mouse coordinates relative to the window
+            dx -= input_rect_x;
+            dy -= input_rect_y;
+		}
+
+		// Clip to window bounds
+		if (dx < 0) {
+			dx = 0;
+		}
+		if (dx > input_rect_width) {
+			dx = input_rect_width;
+		}
+		if (dy < 0) {
+			dy = 0;
+		}
+		if (dy > input_rect_height) {
+			dy = input_rect_height;
+		}
+	
+		if (input_scale != 1.0f) {
+			dy = (int)((float)dy * input_scale);
+			dx = (int)((float)dx * input_scale);
+		}	
+	}
+	///PALM
+	
 	if ( dx || dy ) {
-		posted += SDL_PrivateMouseMotion(0, relative, dx, dy);
+	    //PALM
+		posted += SDL_PrivateMultiMouseMotion(which, 0, relative, dx, dy);
 	}
 
 	/* Swap button 1 and 3 */
@@ -722,7 +816,7 @@ void FB_vgamousecallback(int button, int
 	button |= (button_1|button_3);
 
 	/* See what changed */
-	button_state = SDL_GetMouseState(NULL, NULL);
+	button_state = SDL_GetMultiMouseState(which, NULL, NULL);
 	state_changed = button_state ^ button;
 	for ( i=0; i<8; ++i ) {
 		if ( state_changed & (1<<i) ) {
@@ -731,22 +825,35 @@ void FB_vgamousecallback(int button, int
 			} else {
 				state = SDL_RELEASED;
 			}
-			posted += SDL_PrivateMouseButton(state, i+1, 0, 0);
+			posted += SDL_PrivateMultiMouseButton(which, state, i+1, 0, 0);
 		}
 	}
 }
 
+//PALM
+void FB_vgamousecallback(int button, int relative, int dx, int dy)
+{
+    FB_vgamousecallbackExt(0, button, relative, dx, dy);
+}
+///PALM
+
 /* Handle input from tslib */
 #if SDL_INPUT_TSLIB
 static void handle_tslib(_THIS)
 {
 	struct ts_sample sample;
 	int button;
-
+	int which = 0;
+	
 	while (ts_read(ts_dev, &sample, 1) > 0) {
 		button = (sample.pressure > 0) ? 1 : 0;
 		button <<= 2;	/* must report it as button 3 */
-		FB_vgamousecallback(button, 0, sample.x, sample.y);
+		//PALM
+#ifdef TSLIB_MULTITOUCH
+		which = sample.id;
+#endif		
+		FB_vgamousecallbackExt(which, button, 0, sample.x, sample.y);
+		///PALM
 	}
 	return;
 }
@@ -990,15 +1097,39 @@ static void handle_keyboard(_THIS)
 	int scancode;
 	SDL_keysym keysym;
 
+#ifdef PALM
+	struct input_event aEvents[16];
+	nread = SDL_WebOsEventRead(pHandle, aEvents, sizeof(aEvents)/sizeof(aEvents[0]));
+#else
 	nread = read(keyboard_fd, keybuf, BUFSIZ);
+#endif	
 	for ( i=0; i<nread; ++i ) {
+#ifdef PALM
+	    if (aEvents[i].type != EV_KEY || aEvents[i].value > 1) {
+	        /* ignored */
+	        continue;
+	    }
+	    scancode = aEvents[i].code;
+	    pressed = (aEvents[i].value == 0 ? SDL_RELEASED : SDL_PRESSED);
+#else
 		scancode = keybuf[i] & 0x7F;
 		if ( keybuf[i] & 0x80 ) {
 			pressed = SDL_RELEASED;
 		} else {
 			pressed = SDL_PRESSED;
 		}
+#endif
 		TranslateKey(scancode, &keysym);
+
+#ifdef PALM
+		if (0) {
+            // Temporary!  Fiddle with fake overlay for testing purposes
+            if (keysym.sym == SDLK_o && pressed == SDL_RELEASED) {
+                DoOverlay = !DoOverlay;
+            }
+		}
+#endif
+		
 		/* Handle Ctrl-Alt-FN for vt switch */
 		switch (keysym.sym) {
 		    case SDLK_F1:
@@ -1034,6 +1165,11 @@ void FB_PumpEvents(_THIS)
 	int max_fd;
 	static struct timeval zero;
 
+#ifdef PALM
+	int fd_save = keyboard_fd;
+	keyboard_fd = SDL_WebOsEventGetFd(pHandle);
+#endif
+	
 	do {
 		if ( switched_away ) {
 			struct vt_stat vtstate;
@@ -1076,6 +1212,10 @@ void FB_PumpEvents(_THIS)
 			}
 		}
 	} while ( posted );
+	
+#ifdef PALM
+	keyboard_fd = fd_save;
+#endif	
 }
 
 void FB_InitOSKeymap(_THIS)
@@ -1208,8 +1348,15 @@ static SDL_keysym *TranslateKey(int scan
 	keysym->sym = keymap[scancode];
 	keysym->mod = KMOD_NONE;
 
-	/* If UNICODE is on, get the UNICODE value for the key */
-	keysym->unicode = 0;
+    /* If UNICODE is on, get the UNICODE value for the key */
+    keysym->unicode = 0;
+
+#ifdef PALM
+    if (SDL_WebOsEventTranslateKey(keysym)) {
+        return(keysym);
+    }
+#endif
+
 	if ( SDL_TranslateUNICODE ) {
 		int map;
 		SDLMod modstate;
@@ -1243,3 +1390,24 @@ static SDL_keysym *TranslateKey(int scan
 	}
 	return(keysym);
 }
+
+//PALM
+void FB_SetInputTransform(_THIS)
+{
+	input_xform_enabled = 0;
+	
+#if SDL_FBCON_VFB	  
+	struct SDL_fbvideo_virtualfb* vfb = &this->hidden->vfb;
+	if (this->hidden->use_vfb) {
+		input_xform_enabled = 1;
+		input_rotate = vfb->rotated;
+		input_xoffset = cache_vinfo.xres;
+		input_scale = 1.0f / vfb->scale;
+		input_rect_x = vfb->dx;
+		input_rect_y = vfb->dy;
+		input_rect_width = vfb->scaled_width;
+		input_rect_height = vfb->scaled_height;
+	}
+#endif	  
+}
+///PALM
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbevents_c.h libsdl-1.2-palm/src/video/fbcon/SDL_fbevents_c.h
--- libsdl-1.2/src/video/fbcon/SDL_fbevents_c.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbevents_c.h	2009-04-19 21:40:37.000000000 -0700
@@ -36,3 +36,7 @@ extern void FB_LeaveGraphicsMode(_THIS);
 
 extern void FB_InitOSKeymap(_THIS);
 extern void FB_PumpEvents(_THIS);
+
+//PALM
+extern void FB_SetInputTransform(_THIS);
+///PALM
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbgles.c libsdl-1.2-palm/src/video/fbcon/SDL_fbgles.c
--- libsdl-1.2/src/video/fbcon/SDL_fbgles.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbgles.c	2009-11-20 02:20:54.000000000 -0800
@@ -0,0 +1,1420 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#include <stdlib.h>	/* For getenv() prototype */
+#include <string.h>
+
+#include "SDL_error.h"
+#include "SDL_fbgles.h"
+#include "SDL_fbvideo.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/webos/SDL_WebOsEvent.h"
+#include "SDL_timer.h"
+
+#if defined(PALM)
+#define DEFAULT_EGL		    "libEGL.so"
+#define DEFAULT_EGLSUBDRV   "/usr/lib/egl/libeglsubdrv.so"
+#define DEFAULT_OPENGL	    "libGLES_CM.so"
+#endif
+
+#if defined(sgi)
+/* IRIX doesn't have a GL library versioning system */
+#define DEFAULT_OPENGL	"libGLES_CM.so"
+#endif
+
+#ifndef DEFAULT_OPENGL
+#define DEFAULT_OPENGL	"libGLES_CM.so.1"
+#endif
+
+#if 0
+#define DEBUGTRACE(format, ...) do {                            \
+            printf("[%s:%4d] ", __FILE__, __LINE__ );           \
+            printf(format, ## __VA_ARGS__);                     \
+        } while(0)
+#else
+#define DEBUGTRACE(format, ...) do {} while(0)
+#endif
+
+/* return the preferred visual to use for openGL graphics */
+void *Fbcon_GLES_GetVisual(_THIS)
+{
+#ifdef SDL_VIDEO_OPENGL_ES
+	/* 64 seems nice. */
+	EGLint attribs[64];
+	EGLint found_configs = 0;
+//	VisualID visual_id;
+	int i;
+
+	/* load the gl driver from a default path */
+	if ( ! this->gl_config.driver_loaded ) {
+	        /* no driver has been loaded, use default (ourselves) */
+	        if ( Fbcon_GLES_LoadLibrary(this, NULL) < 0 ) {
+		        return NULL;
+		}
+	}
+
+	/* See if we already have a window which we must use */
+/*
+	if ( SDL_windowid ) {
+		XWindowAttributes a;
+		XVisualInfo vi_in;
+		int out_count;
+
+		vi_in.screen = SDL_Screen;
+		vi_in.visualid = XVisualIDFromVisual(a.visual);
+		return this->gles_data->egl_visualinfo;
+	}
+*/
+        /* Setup our GLX attributes according to the gl_config. */
+
+    // Print out all of the available configs
+#if 0
+    EGLConfig Configs[256];
+    int Num;
+
+    memset(Configs, 0, sizeof(Configs));
+
+    this->gles_data->eglGetConfigs(this->gles_data->egl_display, &Configs[0], sizeof(Configs) / sizeof(Configs[0]), &Num);
+
+    printf("Found %d configs\n\n", Num);
+
+    for (i = 0; i < Num; i++) {
+        int Val;
+
+        printf("\n[Config %d]\n", i);
+
+        char Names[][32] = {
+            "EGL_RED_SIZE",
+            "EGL_GREEN_SIZE",
+            "EGL_BLUE_SIZE",
+            "EGL_ALPHA_SIZE",
+            "EGL_BUFFER_SIZE",
+            "EGL_DEPTH_SIZE",
+            "EGL_STENCIL_SIZE",
+            "EGL_SAMPLE_BUFFERS",
+            "EGL_SAMPLES",
+            "EGL_RENDERABLE_TYPE",
+            "EGL_SURFACE_TYPE",
+        };
+        int ID[] = {
+            EGL_RED_SIZE,
+            EGL_GREEN_SIZE,
+            EGL_BLUE_SIZE,
+            EGL_ALPHA_SIZE,
+            EGL_BUFFER_SIZE,
+            EGL_DEPTH_SIZE,
+            EGL_STENCIL_SIZE,
+            EGL_SAMPLE_BUFFERS,
+            EGL_SAMPLES,
+            EGL_RENDERABLE_TYPE,
+            EGL_SURFACE_TYPE,
+        };
+
+        int j;
+        for (j = 0; j < sizeof(ID) / sizeof(int); j++) {
+            this->gles_data->eglGetConfigAttrib(this->gles_data->egl_display, Configs[i], ID[j], &Val);
+
+            printf("%s = %x\n", Names[j], Val);
+        }        
+    }
+
+#endif
+	i = 0;
+
+    if (this->gl_config.red_size) {
+    	attribs[i++] = EGL_RED_SIZE;
+	    attribs[i++] = this->gl_config.red_size;
+    }
+
+    if (this->gl_config.green_size) {
+    	attribs[i++] = EGL_GREEN_SIZE;
+	    attribs[i++] = this->gl_config.green_size;
+    }
+
+    if (this->gl_config.blue_size) {
+    	attribs[i++] = EGL_BLUE_SIZE;
+	    attribs[i++] = this->gl_config.blue_size;
+    }
+
+	if( this->gl_config.alpha_size ) {
+		attribs[i++] = EGL_ALPHA_SIZE;
+		attribs[i++] = this->gl_config.alpha_size;
+	}
+
+	if( this->gl_config.buffer_size ) {
+		attribs[i++] = EGL_BUFFER_SIZE;
+		attribs[i++] = this->gl_config.buffer_size;
+	}
+
+    if (this->gl_config.depth_size) {
+    	attribs[i++] = EGL_DEPTH_SIZE;
+	    attribs[i++] = this->gl_config.depth_size;
+    }
+
+	if( this->gl_config.stencil_size ) {
+		attribs[i++] = EGL_STENCIL_SIZE;
+		attribs[i++] = this->gl_config.stencil_size;
+	}
+
+	if( this->gl_config.multisamplebuffers ) {
+		attribs[i++] = EGL_SAMPLE_BUFFERS;
+		attribs[i++] = this->gl_config.multisamplebuffers;
+	}
+	
+	if( this->gl_config.multisamplesamples ) {
+		attribs[i++] = EGL_SAMPLES;
+		attribs[i++] = this->gl_config.multisamplesamples;
+	}
+
+    if(this->gl_config.major_version == 2) {
+        DEBUGTRACE( "Using GLES2\n");
+        attribs[i++] = EGL_RENDERABLE_TYPE;
+        attribs[i++] = EGL_OPENGL_ES2_BIT;
+    }
+
+	int SurfaceTypeIndex = i;
+	
+	attribs[i++] = EGL_SURFACE_TYPE;
+	attribs[i++] = EGL_PBUFFER_BIT | EGL_WINDOW_BIT;
+	
+	attribs[i++] = EGL_NONE;
+
+	if (this->gles_data->eglChooseConfig(this->gles_data->egl_display, attribs, 
+	        &this->gles_data->egl_config, 1, &found_configs) == EGL_FALSE || 
+	        found_configs == 0) {
+	           
+        DEBUGTRACE( "No config with EGL_PBUFFER_BIT, trying EGL_WINDOW_BIT\n");
+        attribs[SurfaceTypeIndex + 1] = EGL_WINDOW_BIT;
+        
+        if (this->gles_data->eglChooseConfig(this->gles_data->egl_display, attribs, 
+                &this->gles_data->egl_config, 1, &found_configs) == EGL_FALSE ||
+                found_configs == 0) {
+            
+            SDL_SetError( "Couldn't find matching EGL config");
+            return NULL;
+        }
+	}
+/*
+	if (this->gles_data->eglGetConfigAttrib(
+	      this->gles_data->egl_display,
+	      this->gles_data->egl_config,
+	      EGL_NATIVE_VISUAL_ID,
+	      (EGLint*)&visual_id) == EGL_FALSE ||
+	      !visual_id) {
+
+		XVisualInfo vi_in;
+		int out_count;
+		vi_in.screen = SDL_Screen;
+	
+	}
+	else
+	{
+		XVisualInfo vi_in;
+		int out_count;
+
+		vi_in.screen = SDL_Screen;
+		vi_in.visualid = visual_id;
+	}
+*/
+	return 1; //this->gles_data->egl_visualinfo;
+#else
+	SDL_SetError("Fbcon driver not configured with OpenGL ES");
+	return 0;
+#endif
+}
+
+#ifdef SDL_VIDEO_OPENGL_ES
+/* Creates or destroys the window surface as appropriate */
+static int ManageSurfaces(_THIS)
+{
+    if (this->hidden->Active) {
+        if (this->gles_data->egl_window == EGL_NO_SURFACE) {
+
+            this->gles_data->HasFlipped = SDL_FALSE;
+
+            // Create a window surface
+            DEBUGTRACE( "Window creation\n" );
+            this->gles_data->egl_window = this->gles_data->eglCreateWindowSurface(
+                this->gles_data->egl_display, this->gles_data->egl_config, NULL, NULL);
+        
+            if (this->gles_data->egl_window == EGL_NO_SURFACE) {
+                DEBUGTRACE("Could not create GLES window error 0x%x\n", this->gles_data->eglGetError());
+                return -1;
+            }
+
+#if 0
+            EGLint Swap;        
+            if (this->gles_data->eglQuerySurface(this->gles_data->egl_display, this->gles_data->egl_window, 
+                    EGL_SWAP_BEHAVIOR, &Swap)) {
+                DEBUGTRACE( "EGL_SWAP_BEHAVIOR is %s (0x%x)\n",
+                        (Swap == EGL_BUFFER_PRESERVED ? "EGL_BUFFER_PRESERVED" : (Swap == EGL_BUFFER_DESTROYED ? "EGL_BUFFER_DESTROYED" : "Unknown")),
+                        Swap);
+            }
+#endif
+        }
+    }
+    else {
+        if (this->gles_data->egl_window != EGL_NO_SURFACE) {
+            // Destroy window so another app can own it
+            this->gles_data->eglDestroySurface(this->gles_data->egl_display, this->gles_data->egl_window);
+            this->gles_data->egl_window = EGL_NO_SURFACE;
+        }
+
+        if (this->gles_data->egl_pbuffer == EGL_NO_SURFACE) {
+            
+            EGLint SurfaceType = -1;    
+            this->gles_data->eglGetConfigAttrib(this->gles_data->egl_display, this->gles_data->egl_config, EGL_SURFACE_TYPE, &SurfaceType);
+            DEBUGTRACE( "supported surface type 0x%x\n", SurfaceType);
+
+            if (SurfaceType & EGL_PBUFFER_BIT) {            
+                EGLint attribs[] = {
+                        EGL_WIDTH, this->gles_data->width,
+                        EGL_HEIGHT, this->gles_data->height,
+                        EGL_NONE
+                        };    
+                
+                DEBUGTRACE( "PBuffer creation\n" );
+                this->gles_data->egl_pbuffer = this->gles_data->eglCreatePbufferSurface(
+                                this->gles_data->egl_display, this->gles_data->egl_config, attribs);        
+                
+                if (this->gles_data->egl_pbuffer == EGL_NO_SURFACE) {
+                    DEBUGTRACE("eglCreatePbufferSurface failed error 0x%x\n", this->gles_data->eglGetError());
+                }
+            }
+            
+            if (this->gles_data->egl_pbuffer == EGL_NO_SURFACE) {
+                return -1;
+            }
+        }
+    }
+    return 0;
+}
+#endif
+
+int Fbcon_GLES_CreateWindow(_THIS, int width, int height)
+{
+	int retval;
+
+#ifdef SDL_VIDEO_OPENGL_ES
+    Fbcon_GLES_Shutdown(this);
+
+/*
+	if ( !SDL_Window ) {
+		SDL_SetError("Could not create window");
+		return -1;
+	}
+*/
+	if (Fbcon_GLES_GetVisual(this) == NULL) {
+		return -1;
+	}
+
+	
+	retval = Fbcon_GLES_CreateContext(this);
+	if (retval != 0) {
+		return retval;
+	}
+	
+	this->gles_data->width = width;
+	this->gles_data->height = height;
+	
+	this->gles_data->egl_pbuffer = EGL_NO_SURFACE;
+	this->gles_data->egl_window = EGL_NO_SURFACE;
+	    
+    if (ManageSurfaces(this) < 0) {
+        SDL_SetError( "Error initializing GLES surface(s)\n");
+        return -1;
+    }
+           
+    DEBUGTRACE( "GLES surface(s) created\n");
+	retval = 0;
+	
+#else
+	SDL_SetError("Fbcon driver not configured with OpenGL ES");
+	retval = -1;
+#endif
+	return(retval);
+}
+
+int Fbcon_GLES_CreateContext(_THIS)
+{
+	int retval;
+
+#ifdef SDL_VIDEO_OPENGL_ES
+	EGLint context_attribs[] = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE};
+	
+	/* We do this to create a clean separation between X and GLX errors. */
+
+    if (this->gl_config.major_version == 2)
+        this->gles_data->egl_context =
+           this->gles_data->eglCreateContext(this->gles_data->egl_display,
+                                             this->gles_data->egl_config,
+                                                 EGL_NO_CONTEXT, context_attribs);
+    else
+        this->gles_data->egl_context =
+           this->gles_data->eglCreateContext(this->gles_data->egl_display,
+                                             this->gles_data->egl_config,
+                                                 EGL_NO_CONTEXT, NULL);
+
+
+	if (this->gles_data->egl_context == EGL_NO_CONTEXT) {
+		SDL_SetError("Could not create EGL context");
+		return -1;
+	}
+
+	this->gles_data->egl_active = 1;
+#else
+	SDL_SetError("Fbcon driver not configured with OpenGL ES");
+#endif
+	if ( this->gles_data->egl_active ) {
+		retval = 0;
+	} else {
+		retval = -1;
+	}
+
+	return(retval);
+}
+
+void Fbcon_GLES_Shutdown(_THIS)
+{
+#ifdef SDL_VIDEO_OPENGL_ES
+	/* Clean up GLES and EGL */
+	if( this->gles_data->egl_context != EGL_NO_CONTEXT ||
+	    this->gles_data->egl_pbuffer != EGL_NO_SURFACE ||
+	    this->gles_data->egl_window != EGL_NO_SURFACE ) {
+	    
+		this->gles_data->eglMakeCurrent(this->gles_data->egl_display, EGL_NO_SURFACE,
+		                                EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+		if (this->gles_data->egl_context != EGL_NO_CONTEXT)
+		{
+			this->gles_data->eglDestroyContext(this->gles_data->egl_display, this->gles_data->egl_context);
+			this->gles_data->egl_context = EGL_NO_CONTEXT;
+		}
+
+		if (this->gles_data->egl_pbuffer != EGL_NO_SURFACE)
+		{
+			this->gles_data->eglDestroySurface(this->gles_data->egl_display, this->gles_data->egl_pbuffer);
+			this->gles_data->egl_pbuffer = EGL_NO_SURFACE;
+		}
+		if (this->gles_data->egl_window != EGL_NO_SURFACE)
+        {
+            this->gles_data->eglDestroySurface(this->gles_data->egl_display, this->gles_data->egl_window);
+            this->gles_data->egl_window = EGL_NO_SURFACE;
+        }
+	}
+	this->gles_data->egl_active = 0;
+#endif /* SDL_VIDEO_OPENGL_ES */
+}
+
+#ifdef SDL_VIDEO_OPENGL_ES
+
+static int ExtensionSupported(const char *extension)
+{
+	const GLubyte *extensions = NULL;
+	const GLubyte *start;
+	GLubyte *where, *terminator;
+
+	/* Extension names should not have spaces. */
+	where = (GLubyte *) strchr(extension, ' ');
+	if (where || *extension == '\0')
+	      return 0;
+	
+	extensions = current_video->GLES_glGetString(GL_EXTENSIONS);
+	/* It takes a bit of care to be fool-proof about parsing the
+	 *      OpenGL extensions string. Don't be fooled by sub-strings,
+	 *           etc. */
+	
+	start = extensions;
+	
+	for (;;)
+	{
+		where = (GLubyte *) strstr((const char *) start, extension);
+		if (!where) break;
+		
+		terminator = where + strlen(extension);
+		if (where == start || *(where - 1) == ' ')
+	        if (*terminator == ' ' || *terminator == '\0') return 1;
+						  
+		start = terminator;
+	}
+	
+	return 0;
+}
+
+static void KillTransparency(Uint32* Buffer, int NumWords)
+{
+    __builtin_prefetch(Buffer);
+
+    Uint32* Pixel = Buffer;
+    int Count;
+
+    for (Count = (NumWords >> 3); Count; Count--) {
+        __builtin_prefetch(Pixel + 64);
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+        *Pixel++ |= 0xFF000000;
+    }
+    for (Count = (NumWords & 0x7); Count; Count--) {
+        *Pixel++ |= 0xFF000000;
+    }
+}
+
+//#define PRINT_TIMING(X)      printf("+%s: %d ms\n", X, SDL_GetTicks() - __Time)
+//#define START_TIMING(X)      Uint32 __Time = SDL_GetTicks(); printf( "Timing %s:\n", X)
+#ifndef PRINT_TIMING
+#define START_TIMING(X)
+#define PRINT_TIMING(X)
+#endif
+
+/* Make the current context active */
+int Fbcon_GLES_MakeCurrent(_THIS)
+{
+    void* Offscreen;
+    int SizeInBytes;
+
+    DEBUGTRACE("MakeCurrent active %d\n", this->hidden->Active);
+
+    START_TIMING("MakeCurrent");
+
+    SDL_WebOsEventOffscreenLock(&Offscreen, &SizeInBytes);
+
+    // If we have generated any frames with the GPU (HasFlipped), then initialize the offscreen surface with
+    // the last frame (before window is deleted in ManageSurfaces).
+    if (Offscreen) {
+        if (!this->hidden->Active) {
+            // Update the offscreen surface now, if there is a new frame.
+            if (this->gles_data->HasFlipped) {
+                if (this->gles_data->egl_window != EGL_NO_SURFACE) {
+                    if (!this->gles_data->eglCopyBuffers(this->gles_data->egl_display, this->gles_data->egl_window, Offscreen)) {
+                        DEBUGTRACE( "eglCopyBuffers failed error 0x%x\n", this->gles_data->eglGetError());
+                        Offscreen = NULL;
+                    }
+                }
+                else {
+                    Offscreen = NULL;
+                }
+
+                PRINT_TIMING("eglCopyBuffers");
+                
+                if (Offscreen) {
+                    KillTransparency(Offscreen, SizeInBytes >> 2);
+
+                    // When going inactive, the GPU pipeline is shut down (in eglMakeCurrent) and the first FB buffer will be displayed.
+                    // Ensure this buffer matches the offscreen buffer.
+                    void* FirstBuffer = mapped_mem + mapped_offset;
+					SDL_memcpy(FirstBuffer, Offscreen, SizeInBytes);
+                }
+            }
+            else {
+                // If MultiLayer, we have lost our offscreen surface, so tell app to repaint.
+                DEBUGTRACE( "No offscreen update available, sending repaint\n");
+                SDL_PrivateExpose();
+                KillTransparency(Offscreen, SizeInBytes >> 2);
+            }
+
+            // Update offscreen if it changed
+            SDL_WebOsEventOffscreenUnlock(Offscreen != NULL);
+        }
+        else {
+            // When going active, the sysmgr animates our last offscreen frame up to fullscreen.
+            // If the GPU is drawing into the FB, we don't really need to init the FB, we can
+            // just wait for the game to update the screen.
+            // However if the GPU is rendering into a separate layer, we need to make that layer
+            // visible now (so any incoming notifications will be displayed), and this requires
+            // the GPU layer to be initialized properly to avoid glitches.
+            // The GPU layer will be initialized based on the content of the FB when the window
+            // surface is created, in ManageSurfaces.  Make the FB transparent *after* that.
+            int ScreenSize = this->screen->pitch * this->screen->h;
+            int Offset;
+
+            for (Offset = 0; Offset + ScreenSize <= mapped_memlen; Offset += ScreenSize) {
+                SDL_memcpy(mapped_mem + mapped_offset + Offset, Offscreen, ScreenSize);
+            }
+
+            // No change to offscreen
+            SDL_WebOsEventOffscreenUnlock(SDL_FALSE);
+        }
+	}
+
+    if (ManageSurfaces(this) < 0) {
+        SDL_SetError( "Failed managing window surfaces\n");
+        return -1;
+    }
+    
+    PRINT_TIMING( "ManageSurfaces");
+
+    EGLSurface Surface = this->hidden->Active ? this->gles_data->egl_window : this->gles_data->egl_pbuffer;
+    
+	if ( ! this->gles_data->eglMakeCurrent(this->gles_data->egl_display, Surface, Surface, 
+	                                       this->gles_data->egl_context) ) {
+		SDL_SetError("Unable to make EGL context current");
+		return -1;
+	}
+	
+    if(this->gl_config.swap_control != -1) {
+        DEBUGTRACE( "Using swap_control %d\n", this->gl_config.swap_control);
+        this->gles_data->eglSwapInterval(this->gles_data->egl_display, this->gl_config.swap_control);
+    }
+
+    PRINT_TIMING("eglMakeCurrent");
+	
+	return 0;
+}
+
+/* Get attribute data from glX. */
+int Fbcon_GLES_GetAttribute(_THIS, SDL_GLattr attr, int* value)
+{
+	EGLint attrib = EGL_NONE;
+
+	switch( attr ) {
+	    case SDL_GL_RED_SIZE:
+		attrib = EGL_RED_SIZE;
+		break;
+	    case SDL_GL_GREEN_SIZE:
+		attrib = EGL_GREEN_SIZE;
+		break;
+	    case SDL_GL_BLUE_SIZE:
+		attrib = EGL_BLUE_SIZE;
+		break;
+	    case SDL_GL_ALPHA_SIZE:
+		attrib = EGL_ALPHA_SIZE;
+		break;
+	    case SDL_GL_BUFFER_SIZE:
+		attrib = EGL_BUFFER_SIZE;
+		break;
+	    case SDL_GL_DEPTH_SIZE:
+		attrib = EGL_DEPTH_SIZE;
+		break;
+	    case SDL_GL_STENCIL_SIZE:
+		attrib = EGL_STENCIL_SIZE;
+		break;
+ 	    case SDL_GL_MULTISAMPLEBUFFERS:
+ 		attrib = EGL_SAMPLE_BUFFERS;
+ 		break;
+ 	    case SDL_GL_MULTISAMPLESAMPLES:
+ 		attrib = EGL_SAMPLES;
+ 		break;
+	    default:
+		*value = 0;
+		return(-1);
+	}
+
+	this->gles_data->eglGetConfigAttrib(this->gles_data->egl_display,
+	                                    this->gles_data->egl_config,
+	                                    attrib, value);
+
+	return 0;
+}
+
+#define glIsEnabled				this->gles_data->glIsEnabled
+#define glEnable				this->gles_data->glEnable
+#define glDisable				this->gles_data->glDisable
+#define glGetTexEnvfv			this->gles_data->glGetTexEnvfv
+#define glGetIntegerv			this->gles_data->glGetIntegerv
+#define glMatrixMode			this->gles_data->glMatrixMode
+#define glPushMatrix			this->gles_data->glPushMatrix
+#define glPopMatrix				this->gles_data->glPopMatrix
+#define glLoadIdentity  		this->gles_data->glLoadIdentity
+#define glBlendFunc 			this->gles_data->glBlendFunc
+#define glTexEnvf				this->gles_data->glTexEnvf
+#define glGenTextures			this->gles_data->glGenTextures
+#define glBindTexture			this->gles_data->glBindTexture
+#define glTexImage2D			this->gles_data->glTexImage2D
+#define glOrthof				this->gles_data->glOrthof
+#define glEnableClientState		this->gles_data->glEnableClientState
+#define glVertexPointer			this->gles_data->glVertexPointer
+#define glTexCoordPointer		this->gles_data->glTexCoordPointer
+#define glDrawElements			this->gles_data->glDrawElements
+#define glDrawArrays            this->gles_data->glDrawArrays
+#define glActiveTexture         this->gles_data->glActiveTexture
+#define glClientActiveTexture   this->gles_data->glClientActiveTexture
+#define glDisableClientState    this->gles_data->glDisableClientState
+#define glGetPointerv           this->gles_data->glGetPointerv
+#define glTexParameteri         this->gles_data->glTexParameteri
+#define glGetError              this->gles_data->glGetError
+
+#define MAX_TEXTURE_UNITS       64
+
+typedef struct
+{
+    int GlActiveTexture;
+    int GlMaxTextureUnits;
+	int GlTextureEnable2D[MAX_TEXTURE_UNITS];
+	int	GlBoundTexture;
+
+    int GlClientActiveTexture;
+   	int GlTexCoordArray;
+    int GlTexCoordArrayBuffer;
+    int GlTexCoordArraySize;
+    int GlTexCoordArrayStride;
+    int GlTexCoordArrayType;
+
+	int GlBlend;
+	int GlNormalize;
+	int GlCullFace;
+	int GlDepthTest;
+	int GlLighting;
+	int GlClipPlane1;
+	int GlClipPlane2;
+	int GlMultisample;
+	int GlPolyOffset;
+	int GlFog;
+	int GlScissorTest;
+	int GlAlphaTest;
+	int GlStencilTest;
+	int GlDither;
+	int GlColorLogicOp;
+	int GlRescaleNormal;
+	int GlVertexArray;
+	
+	int GlVertexArrayBuffer;
+	int GlVertexArraySize;
+	int GlVertexArrayStride;
+	int GlVertexArrayType;
+
+	GLfloat GlTexEnv;
+	GLint GlBlendSrc;
+	GLint GlBlendDst;	
+	
+} OverlayStateTy;
+	    
+/* Save all GL state here that are modified for drawing the overlay */	    
+static void SaveStateForOverlay(_THIS, OverlayStateTy* State)
+{
+    int i;
+    
+    /* Save active texture */
+    glGetIntegerv(GL_ACTIVE_TEXTURE,        &State->GlActiveTexture);
+    glGetIntegerv(GL_CLIENT_ACTIVE_TEXTURE, &State->GlClientActiveTexture);
+    glGetIntegerv(GL_MAX_TEXTURE_UNITS,     &State->GlMaxTextureUnits);
+
+    if (State->GlMaxTextureUnits > MAX_TEXTURE_UNITS) {
+        DEBUGTRACE( "Not enough texture unit state storage: %d > %d\n", State->GlMaxTextureUnits, MAX_TEXTURE_UNITS);
+        State->GlMaxTextureUnits = MAX_TEXTURE_UNITS;
+    }
+
+    /* Save TEXTURE0 server state */
+	glActiveTexture(GL_TEXTURE0);
+	State->GlTextureEnable2D[0] = glIsEnabled(GL_TEXTURE_2D);
+	glGetTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &State->GlTexEnv);
+	// TODO: save state from glTexParameter
+
+	/* Save TEXTURE0 client state */
+	glClientActiveTexture(GL_TEXTURE0);
+	State->GlTexCoordArray = glIsEnabled(GL_TEXTURE_COORD_ARRAY);
+	glGetIntegerv(GL_TEXTURE_BINDING_2D, &State->GlBoundTexture);
+	glGetIntegerv(GL_TEXTURE_COORD_ARRAY_SIZE,            &State->GlTexCoordArraySize);
+    glGetIntegerv(GL_TEXTURE_COORD_ARRAY_TYPE,            &State->GlTexCoordArrayType);
+    glGetIntegerv(GL_TEXTURE_COORD_ARRAY_STRIDE,          &State->GlTexCoordArrayStride);
+    glGetPointerv(GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING,  &State->GlTexCoordArrayBuffer);
+
+	/* Save enable status of all texture units */
+    for (i = 1; i < State->GlMaxTextureUnits; i++) {
+        glActiveTexture(GL_TEXTURE0 + i);
+        State->GlTextureEnable2D[i] = glIsEnabled(GL_TEXTURE_2D);
+    }
+
+	State->GlBlend 		   = glIsEnabled(GL_BLEND);
+	State->GlNormalize 	   = glIsEnabled(GL_NORMALIZE);
+	State->GlCullFace 	   = glIsEnabled(GL_CULL_FACE);
+	State->GlDepthTest 	   = glIsEnabled(GL_DEPTH_TEST);
+	State->GlLighting 	   = glIsEnabled(GL_LIGHTING);
+	State->GlClipPlane1    = glIsEnabled(GL_CLIP_PLANE1);
+	State->GlClipPlane2    = glIsEnabled(GL_CLIP_PLANE2);
+	State->GlMultisample   = glIsEnabled(GL_MULTISAMPLE);
+	State->GlPolyOffset    = glIsEnabled(GL_POLYGON_OFFSET_FILL);
+	State->GlFog           = glIsEnabled(GL_FOG);
+	State->GlScissorTest   = glIsEnabled(GL_SCISSOR_TEST);
+	State->GlAlphaTest     = glIsEnabled(GL_ALPHA_TEST);
+	State->GlStencilTest   = glIsEnabled(GL_STENCIL_TEST);
+	State->GlDither        = glIsEnabled(GL_DITHER);
+	State->GlColorLogicOp  = glIsEnabled(GL_COLOR_LOGIC_OP);
+	State->GlRescaleNormal = glIsEnabled(GL_RESCALE_NORMAL);
+	State->GlVertexArray   = glIsEnabled(GL_VERTEX_ARRAY);	
+
+    glGetIntegerv(GL_VERTEX_ARRAY_SIZE,            &State->GlVertexArraySize);
+    glGetIntegerv(GL_VERTEX_ARRAY_TYPE,            &State->GlVertexArrayType);
+    glGetIntegerv(GL_VERTEX_ARRAY_STRIDE,          &State->GlVertexArrayStride);
+    glGetPointerv(GL_VERTEX_ARRAY_BUFFER_BINDING,  &State->GlVertexArrayBuffer);
+
+	glGetIntegerv(GL_BLEND_SRC, &State->GlBlendSrc);
+	glGetIntegerv(GL_BLEND_DST, &State->GlBlendDst);
+				
+	glMatrixMode(GL_PROJECTION);
+	glPushMatrix();
+
+	glMatrixMode(GL_MODELVIEW);
+	glPushMatrix();
+}
+
+#define RESTORE(a,b) 			if (a) glEnable(b); else glDisable(b)
+#define RESTORECLIENT(a,b) 		if (a) glEnableClientState(b); else glDisableClientState(b)
+
+/* Restore saved GL state here */
+static void RestoreStateForOverlay(_THIS, OverlayStateTy* State)
+{
+    int i;
+	
+    /* Restore TEXTURE0 server state */
+    glActiveTexture(GL_TEXTURE0);
+    RESTORE(State->GlTextureEnable2D[0], GL_TEXTURE_2D);
+    glBindTexture(GL_TEXTURE_2D, &State->GlBoundTexture);
+    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, State->GlTexEnv);
+
+    /* Restore TEXTURE0 client state */
+    glClientActiveTexture(GL_TEXTURE0);
+    RESTORECLIENT(State->GlTexCoordArray,   GL_TEXTURE_COORD_ARRAY);
+    glTexCoordPointer(State->GlTexCoordArraySize, State->GlTexCoordArrayType, State->GlTexCoordArrayStride, State->GlTexCoordArrayBuffer);
+
+    /* Restore enable status of all texture units */
+    for (i = 1; i < State->GlMaxTextureUnits; i++) {
+        if (State->GlTextureEnable2D[i]) {
+            glActiveTexture(GL_TEXTURE0 + i);
+            RESTORE(State->GlTextureEnable2D[i], GL_TEXTURE_2D);
+        }
+    }
+
+    /* Restore active texture */
+    glActiveTexture(State->GlActiveTexture);
+    glClientActiveTexture(State->GlClientActiveTexture);
+
+    /* Restore enable bits */
+	RESTORE(State->GlBlend,        GL_BLEND);
+	RESTORE(State->GlNormalize,    GL_NORMALIZE);
+	RESTORE(State->GlCullFace,     GL_CULL_FACE);
+	RESTORE(State->GlDepthTest,    GL_DEPTH_TEST);
+	RESTORE(State->GlLighting,     GL_LIGHTING);
+	RESTORE(State->GlClipPlane1,   GL_CLIP_PLANE1);
+	RESTORE(State->GlClipPlane2,   GL_CLIP_PLANE2);
+	RESTORE(State->GlMultisample,  GL_MULTISAMPLE);
+	RESTORE(State->GlPolyOffset,   GL_POLYGON_OFFSET_FILL);
+	RESTORE(State->GlFog,          GL_FOG);
+	RESTORE(State->GlScissorTest,  GL_SCISSOR_TEST);
+	RESTORE(State->GlAlphaTest,    GL_ALPHA_TEST);
+	RESTORE(State->GlStencilTest,  GL_STENCIL_TEST);
+	RESTORE(State->GlDither,       GL_DITHER);
+	RESTORE(State->GlColorLogicOp, GL_COLOR_LOGIC_OP);
+	RESTORE(State->GlRescaleNormal,GL_RESCALE_NORMAL);
+	
+	RESTORECLIENT(State->GlVertexArray, GL_VERTEX_ARRAY);
+    glVertexPointer(State->GlVertexArraySize, State->GlVertexArrayType, State->GlVertexArrayStride, State->GlVertexArrayBuffer);
+
+	glBlendFunc(State->GlBlendSrc, State->GlBlendDst);
+
+	glMatrixMode(GL_MODELVIEW);
+	glPopMatrix();
+	
+	glMatrixMode(GL_PROJECTION);
+	glPopMatrix();
+}
+
+static void SetStateForOverlay(_THIS, OverlayStateTy* State)
+{
+    int i;
+    
+	/* Assume no defaults, set everything here.
+	 * If anything is added here, it must be saved and restored!
+	 * FIXME: ensure this is complete.
+	 */
+
+    /* Disable all enabled texture units */
+    for (i = 1; i < State->GlMaxTextureUnits; i++) {
+        if (State->GlTextureEnable2D[i]) {
+            glActiveTexture(GL_TEXTURE0 + i);
+            glDisable(GL_TEXTURE_2D);
+        }
+    }
+    
+    glActiveTexture(GL_TEXTURE0);
+    glClientActiveTexture(GL_TEXTURE0);
+    
+    glEnable(GL_TEXTURE_2D);
+	glEnable(GL_BLEND);
+
+	glDisable(GL_NORMALIZE);
+	glDisable(GL_CULL_FACE);
+	glDisable(GL_DEPTH_TEST);
+	glDisable(GL_LIGHTING);
+	glDisable(GL_CLIP_PLANE1);
+	glDisable(GL_CLIP_PLANE2);
+	glDisable(GL_MULTISAMPLE);
+	glDisable(GL_POLYGON_OFFSET_FILL);
+	glDisable(GL_FOG);
+	glDisable(GL_SCISSOR_TEST);
+	glDisable(GL_ALPHA_TEST);
+	glDisable(GL_STENCIL_TEST);
+	glDisable(GL_DITHER);
+	glDisable(GL_COLOR_LOGIC_OP);
+	glDisable(GL_RESCALE_NORMAL);
+
+	/* Texture data is premultiplied */
+	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+#ifdef __arm__
+	glOrthof(0.0, this->gles_data->width, this->gles_data->height, 0.0, 0.0, 1.0);
+#else	
+	glOrtho(0.0, this->gles_data->width, this->gles_data->height, 0.0, 0.0, 1.0);
+#endif	
+
+	glMatrixMode(GL_MODELVIEW);
+	glLoadIdentity();
+}
+
+
+static int power_of_two(int input)
+{
+    int value = 1;
+
+    while ( value < input ) {
+        value <<= 1;
+    }
+    return value;
+}
+
+static void DrawOverlay(_THIS, GLint TextureId, int X, int Y, int Width, int Height)
+{
+	float fVertices[12];
+	float ScaleX = (float)Width / power_of_two(Width);
+	float ScaleY = (float)Height / power_of_two(Height);
+	float fTexCoords [8] = {
+	    0.0f, 0.0f, ScaleX, 0.0f, 0.0f, ScaleY, ScaleX, ScaleY
+	};
+
+	fVertices[0] = (float)X;
+	fVertices[1] = (float)Y;
+	fVertices[2] = (float)0;
+
+	fVertices[3] = (float)(X + Width);
+	fVertices[4] = (float)Y;
+	fVertices[5] = (float)0;
+
+	fVertices[6] = (float)X;
+	fVertices[7] = (float)(Y + Height);
+	fVertices[8] = (float)0;
+
+	fVertices[9] = (float)(X + Width);
+	fVertices[10] = (float)(Y + Height);
+	fVertices[11] = (float)0;
+
+	glBindTexture(GL_TEXTURE_2D, TextureId);
+	glEnableClientState(GL_VERTEX_ARRAY);
+	glVertexPointer(3, GL_FLOAT, 0, fVertices);
+	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+	glTexCoordPointer(2, GL_FLOAT, 0, fTexCoords);
+
+	printf( "DrawOverlay X %d Y %d  Width %d Height %d\n", X, Y, Width, Height);
+
+	glDrawArrays(GL_TRIANGLE_STRIP, 0, 12);
+
+	glDisableClientState(GL_VERTEX_ARRAY);
+	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+}
+
+
+static void DoOverlay(_THIS)
+{
+    OverlayStateTy State;
+
+    if (this->gles_data->gles_handle) {
+
+        SaveStateForOverlay(this, &State);
+        SetStateForOverlay(this, &State);
+
+        if (SDL_WebOsEventOverlayChanged()) {
+            void* Buffer;
+            int Width, Height;
+
+            SDL_WebOsEventOverlayLock(&Buffer, &Width, &Height);
+            if (Buffer) {
+
+                if (this->gles_data->OverlayTexture == 0) {
+                    /* Create a texture id */
+                    glGenTextures(1, &this->gles_data->OverlayTexture);
+                }
+
+                const int BytesPerPixel = 4;
+
+                /* Texture dimensions must be power-of-two */
+                int TexWidth = power_of_two(Width);
+                int TexHeight = power_of_two(Height);
+
+                void* TexBuffer = SDL_malloc(TexWidth * TexHeight * BytesPerPixel);
+
+                int Y;
+                for (Y = 0; Y < Height; Y++) {
+                    SDL_memcpy(TexBuffer + Y * TexWidth * BytesPerPixel,
+                            Buffer + Y * Width * BytesPerPixel, Width * BytesPerPixel);
+                }
+
+                /* Buffer no longer required */
+                SDL_WebOsEventOverlayUnlock();
+
+                /* Upload the texture */
+                glBindTexture(GL_TEXTURE_2D, this->gles_data->OverlayTexture);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+                glTexImage2D(GL_TEXTURE_2D,
+                             0,
+                             GL_RGBA,
+                             TexWidth, TexHeight,
+                             0,
+                             GL_RGBA,
+                             GL_UNSIGNED_BYTE,
+                             TexBuffer);
+
+                SDL_free(TexBuffer);
+
+                this->gles_data->OverlayWidth   = Width;
+                this->gles_data->OverlayHeight  = Height;
+            }
+            else {
+                this->gles_data->OverlayWidth   = 0;
+                this->gles_data->OverlayHeight  = 0;
+            }
+        }
+
+        if (this->gles_data->OverlayWidth && this->gles_data->OverlayHeight) {
+            int X = 0;
+            int Y = 480 - this->gles_data->OverlayHeight;
+
+            DrawOverlay(this, this->gles_data->OverlayTexture, X, Y, this->gles_data->OverlayWidth, this->gles_data->OverlayHeight);
+        }
+
+        RestoreStateForOverlay(this, &State);
+    }
+    else {
+        DEBUGTRACE( "No GLES handle, can't draw overlay\n");
+    }
+}
+
+#undef glIsEnabled
+#undef glEnable
+#undef glDisable
+#undef glGetTexEnvfv
+#undef glGetIntegerv
+#undef glMatrixMode
+#undef glPushMatrix
+#undef glPopMatrix
+#undef glLoadIdentity
+#undef glBlendFunc
+#undef glTexEnvf
+#undef glGenTextures
+#undef glBindTexture
+#undef glTexImage2D
+#undef glOrthof
+#undef glEnableClientState
+#undef glVertexPointer
+#undef glTexCoordPointer
+#undef glDrawElements
+#undef glDrawArrays
+#undef glActiveTexture
+#undef glClientActiveTexture
+#undef glDisableClientState
+#undef glGetPointerv
+#undef glTexParameteri
+#undef glGetError
+
+
+void Fbcon_GLES_SwapBuffers(_THIS)
+{
+    /* PALM */
+    FB_DisplayFps();
+    /*/PALM */
+
+    if (this->hidden->Active) {
+
+        /* Overlay drawing client side is deprecated; to be removed */
+        /*if (SDL_WebOsEventOverlayActive()) { */
+        if (SDL_FALSE) {
+            /* Draw any overlays */
+            DoOverlay(this);
+        }
+
+        this->gles_data->eglSwapBuffers(this->gles_data->egl_display, this->gles_data->egl_window);
+
+        this->gles_data->HasFlipped = SDL_TRUE;
+    }
+    else {
+        void* Offscreen;
+        int SizeInBytes;
+
+        DEBUGTRACE( "FBcon_GLES_SwapBuffers: not active\n");
+
+        SDL_WebOsEventOffscreenLock(&Offscreen, &SizeInBytes);
+        if (Offscreen) {
+            if (!this->gles_data->eglCopyBuffers(this->gles_data->egl_display, this->gles_data->egl_pbuffer, Offscreen)) {
+                DEBUGTRACE( "eglCopyBuffers failed error 0x%x\n", this->gles_data->eglGetError());
+                Offscreen = NULL;
+            }
+            else {
+                KillTransparency(Offscreen, SizeInBytes >> 2);
+            }
+            SDL_WebOsEventOffscreenUnlock(Offscreen != NULL);
+        }
+    }
+
+    if (this->hidden->Paused) {
+        // Cap the frame rate
+        Uint32 Ms = 1000 / SDL_WEBOS_DEACTIVATED_FPS_CAP;
+        if (SDL_DelayWithEventInterrupt(Ms) == 0) {
+            DEBUGTRACE( "Event interrupted my delay!\n");
+        }
+    }
+}
+
+#endif /* SDL_VIDEO_OPENGL_ES */
+
+void Fbcon_GLES_UnloadLibrary(_THIS)
+{
+#ifdef SDL_VIDEO_OPENGL_ES
+	if ( this->gl_config.driver_loaded ) {
+		if (this->gles_data->OverlayTexture) {
+			DEBUGTRACE( "TODO: free texture");
+		}
+		this->gles_data->OverlayTexture = 0;
+		this->gles_data->OverlayWidth = 0;
+		this->gles_data->OverlayHeight = 0;
+		
+		this->gles_data->eglTerminate(this->gles_data->egl_display);
+		
+		if (this->gles_data->gles_handle) {
+		    dlclose(this->gles_data->gles_handle);
+	        this->gles_data->gles_handle = NULL;
+		}
+		dlclose(this->gles_data->egl_handle);
+        this->gles_data->egl_handle = NULL;
+
+		this->gles_data->eglGetProcAddress = NULL;
+		this->gles_data->eglGetError = NULL;
+		this->gles_data->eglChooseConfig = NULL;
+		this->gles_data->eglCreateContext = NULL;
+		this->gles_data->eglCreateWindowSurface = NULL;
+		this->gles_data->eglCreatePbufferSurface = NULL;
+		this->gles_data->eglCreatePixmapSurface = NULL;
+		this->gles_data->eglDestroyContext = NULL;
+		this->gles_data->eglDestroySurface = NULL;
+		this->gles_data->eglMakeCurrent = NULL;
+		this->gles_data->eglSwapBuffers = NULL;
+		this->gles_data->eglSwapInterval = NULL;
+		this->gles_data->eglCopyBuffers = NULL;
+		this->gles_data->eglGetDisplay = NULL;
+		this->gles_data->eglTerminate = NULL;
+		this->gles_data->eglSurfaceAttrib = NULL;
+		this->gles_data->eglQuerySurface = NULL;
+		
+		this->gles_data->eglSubDrvBufferConfig = NULL;		
+		dlclose(this->gles_data->eglsubdrv_handle);
+		this->gles_data->eglsubdrv_handle = NULL;
+
+		this->gles_data->glIsEnabled = NULL;
+		this->gles_data->glEnable = NULL;
+		this->gles_data->glDisable = NULL;
+		this->gles_data->glIsEnabled = NULL;
+		this->gles_data->glEnable = NULL;
+		this->gles_data->glDisable = NULL;
+		this->gles_data->glGetTexEnvfv = NULL;
+	    this->gles_data->glGetIntegerv = NULL;
+	    this->gles_data->glMatrixMode = NULL;	
+	    this->gles_data->glPushMatrix = NULL;
+	    this->gles_data->glPopMatrix = NULL;
+	    this->gles_data->glLoadIdentity = NULL;
+	    this->gles_data->glBlendFunc = NULL;
+	    this->gles_data->glTexEnvf = NULL;
+	    this->gles_data->glGenTextures = NULL;
+	    this->gles_data->glBindTexture = NULL;
+	    this->gles_data->glTexImage2D = NULL;
+	    this->gles_data->glOrthof = NULL;
+	    this->gles_data->glEnableClientState = NULL;
+	    this->gles_data->glVertexPointer = NULL;
+	    this->gles_data->glTexCoordPointer = NULL;
+	    this->gles_data->glDrawElements = NULL;
+	    this->gles_data->glDrawArrays = NULL;
+	    this->gles_data->glActiveTexture = NULL;
+	    this->gles_data->glClientActiveTexture = NULL;
+        this->gles_data->glDisableClientState = NULL;
+        this->gles_data->glGetPointerv = NULL;
+        this->gles_data->glTexParameteri = NULL;
+        this->gles_data->glGetError = NULL;
+
+		this->gl_config.driver_loaded = 0;
+	}
+#endif
+}
+
+#ifdef SDL_VIDEO_OPENGL_ES
+
+/*
+ *  A macro for loading a function pointer with dlsym
+ */
+#define LOAD_FUNC(NAME) \
+	*((void**)&this->gles_data->NAME) = dlsym(handle, #NAME); \
+	if (!this->gles_data->NAME) \
+	{ \
+		SDL_SetError("Could not retrieve function " #NAME); \
+		return -1; \
+	}
+  
+
+/* PALM */
+static int LoadEgl(_THIS, const char* path)
+{
+    void* handle;
+    int dlopen_flags;
+
+#ifdef RTLD_GLOBAL
+    dlopen_flags = RTLD_LAZY | RTLD_GLOBAL;
+#else
+    dlopen_flags = RTLD_LAZY;
+#endif
+    handle = dlopen(path, dlopen_flags);
+    /* Catch the case where the application isn't linked with EGL */
+    if ( (dlsym(handle, "eglChooseConfig") == NULL) && (path == NULL) ) {
+        dlclose(handle);
+        const char* path = getenv("SDL_VIDEO_EGL_DRIVER");
+        if ( path == NULL ) {
+            path = DEFAULT_EGL;
+        }
+        DEBUGTRACE( "Opening EGL %s\n", path);
+        handle = dlopen(path, dlopen_flags);
+    }
+    if ( handle == NULL ) {
+        SDL_SetError("Could not load EGL library");
+        return -1;
+    }
+
+    /* Unload the old driver and reset the pointers */
+    Fbcon_GLES_UnloadLibrary(this);
+
+    /* Load EGL function pointers */
+    LOAD_FUNC(eglGetError);
+    LOAD_FUNC(eglGetDisplay);
+    LOAD_FUNC(eglInitialize);
+    LOAD_FUNC(eglTerminate);
+    LOAD_FUNC(eglGetProcAddress);
+    LOAD_FUNC(eglChooseConfig);
+    LOAD_FUNC(eglGetConfigs);
+    LOAD_FUNC(eglGetConfigAttrib);
+    LOAD_FUNC(eglCreateContext);
+    LOAD_FUNC(eglDestroyContext);
+    LOAD_FUNC(eglCreateWindowSurface);
+    LOAD_FUNC(eglCreatePbufferSurface);
+    LOAD_FUNC(eglCreatePixmapSurface);
+    LOAD_FUNC(eglDestroySurface);
+    LOAD_FUNC(eglMakeCurrent);
+    LOAD_FUNC(eglSwapBuffers);
+    LOAD_FUNC(eglSwapInterval);
+    LOAD_FUNC(eglCopyBuffers);
+    LOAD_FUNC(eglSurfaceAttrib);
+    LOAD_FUNC(eglQuerySurface);
+
+    this->gles_data->egl_handle = handle;
+
+    return 0;
+}
+
+static int LoadEglSubDrv(_THIS, const char* path)
+{
+    void* handle;
+    int dlopen_flags;
+
+#ifdef RTLD_GLOBAL
+    dlopen_flags = RTLD_LAZY | RTLD_GLOBAL;
+#else
+    dlopen_flags = RTLD_LAZY;
+#endif
+    handle = dlopen(path, dlopen_flags);
+    /* Catch the case where the application isn't linked with eglsubdrv */
+    if ( (dlsym(handle, "eglSubDrvBufferConfig") == NULL) && (path == NULL) ) {
+        dlclose(handle);
+        const char* path = getenv("SDL_VIDEO_EGL_SUBDRIVER");
+        if ( path == NULL ) {
+            path = DEFAULT_EGLSUBDRV;
+        }
+        DEBUGTRACE( "Opening EGL subdriver %s\n", path);
+        handle = dlopen(path, dlopen_flags);
+    }
+    if ( handle == NULL ) {
+        SDL_SetError("Could not load EGL subdriver library");
+        return -1;
+    }
+
+    /* Load function pointers */
+    LOAD_FUNC(eglSubDrvBufferConfig);
+
+    this->gles_data->eglsubdrv_handle = handle;
+
+    return 0;
+}
+
+static int LoadGles(_THIS, const char* path)
+{
+    if (this->gl_config.major_version == 1) {
+        void* handle;
+        int dlopen_flags;
+
+#ifdef RTLD_GLOBAL
+        dlopen_flags = RTLD_LAZY | RTLD_GLOBAL;
+#else
+        dlopen_flags = RTLD_LAZY;
+#endif
+        /* Now open GL library */
+        handle = dlopen(path, dlopen_flags);
+        /* Catch the case where the application isn't linked with EGL */
+        if ( (dlsym(handle, "glIsEnabled") == NULL) && (path == NULL) ) {
+            dlclose(handle);
+            const char* path = getenv("SDL_VIDEO_GL_DRIVER");
+            if ( path == NULL ) {
+                path = DEFAULT_OPENGL;
+            }
+            DEBUGTRACE( "Opening GLES1 %s\n", path);
+            handle = dlopen(path, dlopen_flags);
+        }
+        if ( handle == NULL ) {
+            SDL_SetError("Could not load OpenGL ES library");
+            return -1;
+        }
+
+        /* Load GLES function pointers */
+        LOAD_FUNC(glIsEnabled);
+        LOAD_FUNC(glEnable);
+        LOAD_FUNC(glDisable);
+        LOAD_FUNC(glGetTexEnvfv);
+        LOAD_FUNC(glGetIntegerv);
+        LOAD_FUNC(glMatrixMode);
+        LOAD_FUNC(glPushMatrix);
+        LOAD_FUNC(glPopMatrix);
+        LOAD_FUNC(glLoadIdentity);
+        LOAD_FUNC(glBlendFunc);
+        LOAD_FUNC(glTexEnvf);
+        LOAD_FUNC(glGenTextures);
+        LOAD_FUNC(glBindTexture);
+        LOAD_FUNC(glTexImage2D);
+        LOAD_FUNC(glOrthof);
+        LOAD_FUNC(glEnableClientState);
+        LOAD_FUNC(glVertexPointer);
+        LOAD_FUNC(glTexCoordPointer);
+        LOAD_FUNC(glDrawElements);
+        LOAD_FUNC(glDrawArrays);
+        LOAD_FUNC(glActiveTexture);
+        LOAD_FUNC(glClientActiveTexture);
+        LOAD_FUNC(glDisableClientState);
+        LOAD_FUNC(glGetPointerv);
+        LOAD_FUNC(glTexParameteri);
+        LOAD_FUNC(glGetError);
+
+        this->gles_data->gles_handle = handle;
+    }
+    else {
+        this->gles_data->gles_handle = 0;
+    }
+
+    return 0;
+}
+/*/PALM */
+
+/* Passing a NULL path means load pointers from the application */
+int Fbcon_GLES_LoadLibrary(_THIS, const char* path)
+{
+    if ( this->gles_data->egl_active ) {
+        SDL_SetError("OpenGL ES context already created");
+        return -1;
+    }
+
+    /* Unload the old driver and reset the pointers */
+    Fbcon_GLES_UnloadLibrary(this);
+
+    if (LoadEgl(this, path) < 0) {
+        return -1;
+    }
+    if (LoadEglSubDrv(this, path) < 0) {
+        return -1;
+    }
+    if (LoadGles(this, path) < 0) {
+        return -1;
+    }
+	
+	/*
+	 *  Initialize EGL
+	 */
+	this->gles_data->egl_display = this->gles_data->eglGetDisplay(EGL_DEFAULT_DISPLAY);
+
+	if ( !this->gles_data->egl_display ) {
+		SDL_SetError("Could not get EGL display");
+		return -1;
+	}
+
+    if (this->gles_data->eglSubDrvBufferConfig) {
+        int NumBuffers = this->gl_config.double_buffer ? 2 : 3;
+        DEBUGTRACE( "Setting numbuffers in eglsubdrv: %d\n", NumBuffers);
+        this->gles_data->eglSubDrvBufferConfig(NumBuffers);
+    }
+
+	if ( this->gles_data->eglInitialize(this->gles_data->egl_display, NULL, NULL) != EGL_TRUE ) {
+		SDL_SetError("Could not initialize EGL");
+		return -1;
+	}
+		
+	this->gl_config.driver_loaded = 1;
+	if ( path ) {
+		strncpy(this->gl_config.driver_path, path,
+			sizeof(this->gl_config.driver_path)-1);
+	} else {
+		strcpy(this->gl_config.driver_path, "");
+	}
+	return 0;
+}
+
+void *Fbcon_GLES_GetProcAddress(_THIS, const char* proc)
+{
+	static char procname[1024];
+	void* handle;
+	void* retval;
+	
+	handle = this->gl_config.dll_handle;
+	if ( this->gles_data->eglGetProcAddress ) {
+		retval = this->gles_data->eglGetProcAddress(proc);
+		if (retval) {
+			return retval;
+		}
+	}
+#if defined(__OpenBSD__) && !defined(__ELF__)
+#undef dlsym(x,y);
+#endif
+	retval = dlsym(handle, proc);
+	if (!retval && strlen(proc) <= 1022) {
+		procname[0] = '_';
+		strcpy(procname + 1, proc);
+		retval = dlsym(handle, procname);
+	}
+	return retval;
+}
+
+#endif /* SDL_VIDEO_OPENGL_ES */
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbgles.h libsdl-1.2-palm/src/video/fbcon/SDL_fbgles.h
--- libsdl-1.2/src/video/fbcon/SDL_fbgles.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbgles.h	2009-11-10 14:32:36.000000000 -0800
@@ -0,0 +1,163 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: SDL_x11gl_c.h,v 1.8 2004/01/04 16:49:27 slouken Exp $";
+#endif
+
+#if SDL_VIDEO_OPENGL_ES
+#include <GLES/gl.h>
+#include <GLES/egl.h>
+#include <dlfcn.h>
+#if defined(__OpenBSD__) && !defined(__ELF__)
+#define dlsym(x,y) dlsym(x, "_" y)
+#endif
+#endif
+#include "../SDL_sysvideo.h"
+
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_VideoDevice *this
+
+struct SDL_PrivateGLESData {
+    int egl_active; /* to stop switching drivers while we have a valid context */
+    int width;
+    int height;
+    SDL_bool    HasFlipped;
+    
+#if SDL_VIDEO_OPENGL_ES
+    void* gles_handle;
+    void* egl_handle;
+    void* eglsubdrv_handle;
+
+    EGLDisplay egl_display;
+    EGLContext egl_context;	/* Current GLES context */
+    EGLSurface egl_window;
+    EGLSurface egl_pbuffer;
+    EGLConfig  egl_config;
+    
+    GLint	OverlayTexture;
+    GLint	OverlayWidth;
+    GLint	OverlayHeight;
+
+    EGLint (*eglGetError)(void);
+    
+    EGLDisplay (*eglGetDisplay) (NativeDisplayType display);
+    EGLBoolean (*eglInitialize) (EGLDisplay dpy, EGLint *major, EGLint *minor);
+    EGLBoolean (*eglTerminate) (EGLDisplay dpy);
+
+    void * (*eglGetProcAddress)(const GLubyte *procName);
+
+    EGLBoolean (*eglChooseConfig) (EGLDisplay dpy,
+                                   const EGLint *attrib_list,
+                                   EGLConfig *configs,
+                                   EGLint config_size,
+                                   EGLint *num_config);
+
+    EGLContext (*eglCreateContext) (EGLDisplay dpy,
+                                    EGLConfig config,
+                                    EGLContext share_list,
+                                    const EGLint *attrib_list);
+
+    EGLBoolean (*eglDestroyContext) (EGLDisplay dpy, EGLContext ctx);
+
+    EGLSurface (*eglCreateWindowSurface) (EGLDisplay dpy,
+                                          EGLConfig config,
+                                          NativeWindowType window,
+                                          const EGLint *attrib_list);
+    EGLSurface (*eglCreatePbufferSurface) (EGLDisplay dpy, EGLConfig config,
+                                           const EGLint *attrib_list);
+    EGLSurface (*eglCreatePixmapSurface) (EGLDisplay dpy, EGLConfig config,
+                                          EGLNativePixmapType pixmap,
+                                          const EGLint *attrib_list);
+    
+    EGLBoolean (*eglDestroySurface) (EGLDisplay dpy, EGLSurface surface);
+
+    EGLBoolean (*eglMakeCurrent) (EGLDisplay dpy, EGLSurface draw,
+                                  EGLSurface read, EGLContext ctx);
+
+    EGLBoolean (*eglSwapBuffers) (EGLDisplay dpy, EGLSurface draw);
+    EGLBoolean (*eglSwapInterval) (EGLDisplay dpy, EGLint interval);
+    EGLBoolean (*eglCopyBuffers) (EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target);
+    
+    const char *(*eglQueryString) (EGLDisplay dpy, EGLint name);
+
+    EGLBoolean (*eglGetConfigs) (EGLDisplay dpy, EGLConfig *configs,
+                                      EGLint config_size, EGLint *num_config);
+    
+    EGLBoolean (*eglGetConfigAttrib) (EGLDisplay dpy, EGLConfig config,
+                                      EGLint attribute, EGLint *value);
+    
+    EGLBoolean (*eglSurfaceAttrib) (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value);   
+    EGLBoolean (*eglQuerySurface) (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value);
+
+    EGLBoolean (*eglSubDrvBufferConfig) (int NumBuffers);
+
+    GLboolean  (*glIsEnabled) (GLenum cap);
+    void       (*glEnable) (GLenum cap);
+    void       (*glDisable) (GLenum cap);
+    void       (*glGetTexEnvfv) (GLenum env, GLenum pname, GLfloat *params);
+    void       (*glGetIntegerv) (GLenum pname, GLint *params);
+    void       (*glMatrixMode) (GLenum mode);
+    void       (*glPushMatrix) (void);
+    void       (*glPopMatrix) (void);
+    void       (*glLoadIdentity) (void);
+    void       (*glBlendFunc) (GLenum sfactor, GLenum dfactor);
+    void       (*glTexEnvf) (GLenum target, GLenum pname, GLfloat param);
+    void       (*glGenTextures) (GLsizei n, GLuint *textures);
+    void       (*glBindTexture) (GLenum target, GLuint texture);
+    void       (*glTexImage2D) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    void       (*glOrthof) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+    void       (*glEnableClientState) (GLenum array);
+    void       (*glVertexPointer) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    void       (*glTexCoordPointer) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    void       (*glDrawElements) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+    void       (*glDrawArrays) (GLenum mode, GLint first, GLsizei count);
+    void       (*glActiveTexture) (GLenum texture);
+    void       (*glClientActiveTexture) (GLenum texture);
+    void       (*glDisableClientState) (GLenum array);
+    void       (*glGetPointerv) (GLenum pname, void **params);
+    void       (*glTexParameteri) (GLenum target, GLenum pname, GLint param);
+    GLenum     (*glGetError) (void);
+
+#endif /* SDL_VIDEO_OPENGL_ES */
+};
+
+/* OpenGL functions */
+extern int Fbcon_GLES_CreateWindow(_THIS, int w, int h);
+extern int Fbcon_GLES_CreateContext(_THIS);
+extern void Fbcon_GLES_Shutdown(_THIS);
+#if SDL_VIDEO_OPENGL_ES
+extern void *Fbcon_GLES_GetVisual(_THIS);
+extern int Fbcon_GLES_MakeCurrent(_THIS);
+extern int Fbcon_GLES_GetAttribute(_THIS, SDL_GLattr attrib, int* value);
+extern void Fbcon_GLES_SwapBuffers(_THIS);
+extern int Fbcon_GLES_LoadLibrary(_THIS, const char* path);
+extern void *Fbcon_GLES_GetProcAddress(_THIS, const char* proc);
+#else
+/* Dummy EGL types */
+typedef int EGLConfig;
+typedef int EGLint;
+#endif
+extern void Fbcon_GLES_UnloadLibrary(_THIS);
+
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbvfb.cc libsdl-1.2-palm/src/video/fbcon/SDL_fbvfb.cc
--- libsdl-1.2/src/video/fbcon/SDL_fbvfb.cc	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbvfb.cc	2009-11-03 17:36:32.000000000 -0800
@@ -0,0 +1,44 @@
+#include <stdio.h>
+#include "SDL_fbvfb.h"
+
+#ifdef PALM
+#include "Piranha/PContext.h"
+static PContext2D Context;
+#endif
+
+
+void FB_VfbBlit(FB_VfbBlitSurface* Dst, FB_VfbBlitSurface* Src, int Rotate)
+{    
+#ifdef PALM
+    PPixmap* DstPix = Context.CreatePixmap(Dst->Width, Dst->Height);
+    DstPix->Wrap(PFORMAT_8888, Dst->Mem, Dst->Pitch, false);
+    
+    Context.RenderToTexture(DstPix);
+    
+    PPixmap* SrcPix = Context.CreatePixmap(Src->Width, Src->Height);
+    SrcPix->Wrap(PFORMAT_8888, Src->Mem, Src->Pitch, false);
+    
+    PMatrix3D Transform;    
+    if (Rotate) {
+        Transform.Rotate(PValue(270));
+        Transform.Translate(PVertex2D(PValue(Dst->Width),0));
+    }
+    Context.SetTransform(&Transform);
+    
+    PVertex2D DstStart(PValue(Dst->RectX), PValue(Dst->RectY));
+    PVertex2D DstEnd = DstStart + PVertex2D(PValue(Dst->RectWidth), PValue(Dst->RectHeight));
+    
+    PVertex2D SrcStart(PValue(Src->RectX), PValue(Src->RectY));
+    PVertex2D SrcEnd = SrcStart + PVertex2D(PValue(Src->RectWidth), PValue(Src->RectHeight));
+
+    //fprintf(stderr, "Dst %d:%d %d:%d  Src %d:%d %d:%d\n",
+    //(int)DstStart.X, (int)DstStart.Y, (int)DstEnd.X, (int)DstEnd.Y,
+    //            (int)SrcStart.X, (int)SrcStart.Y, (int)SrcEnd.X, (int)SrcEnd.Y);
+    Context.DrawSubPixmap(SrcPix, DstStart, DstEnd, SrcStart, SrcEnd);
+    
+    Context.DestroyPixmap(DstPix);
+    Context.DestroyPixmap(SrcPix);
+#else
+    fprintf(stderr, "FB_VfbBlit: not implemented\n");
+#endif
+}
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbvfb.h libsdl-1.2-palm/src/video/fbcon/SDL_fbvfb.h
--- libsdl-1.2/src/video/fbcon/SDL_fbvfb.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbvfb.h	2009-04-19 21:40:37.000000000 -0700
@@ -0,0 +1,26 @@
+#ifndef SDL_FBVFB_H
+#define SDL_FBVFB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct FB_VfbBlitSurface
+{
+    char* Mem;
+    int   Width;
+    int   Height;
+    int   Pitch;
+    float RectX;
+    float RectY;
+    float RectWidth;
+    float RectHeight;
+};
+
+void FB_VfbBlit(struct FB_VfbBlitSurface* Dst, struct FB_VfbBlitSurface* Src, int Rotate);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbvideo.c libsdl-1.2-palm/src/video/fbcon/SDL_fbvideo.c
--- libsdl-1.2/src/video/fbcon/SDL_fbvideo.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbvideo.c	2009-11-24 00:14:18.000000000 -0800
@@ -23,12 +23,12 @@
 
 /* Framebuffer console based SDL video driver implementation.
 */
-
 #include <stdio.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
+#include <linux/matroxfb.h> // for FBIO_WAITFORVSYNC
 
 #ifndef HAVE_GETPAGESIZE
 #include <asm/page.h>		/* For definition of PAGE_SIZE */
@@ -47,6 +47,22 @@
 #include "SDL_fb3dfx.h"
 #include "SDL_fbmatrox.h"
 #include "SDL_fbriva.h"
+#include "SDL_fbgles.h"
+
+//PALM
+#include "SDL_timer.h" // for SDL_Delay
+#include "SDL_audio.h" 
+#include "../../audio/SDL_audio_c.h" 
+///PALM
+
+#ifdef SDL_FBCON_VFB
+#include <math.h>
+#include "SDL_fbvfb.h"
+#endif
+
+#ifdef PALM
+#include "../../events/webos/SDL_WebOsEvent.h"
+#endif
 
 /*#define FBCON_DEBUG*/
 
@@ -166,6 +182,148 @@ static int SDL_getpagesize(void)
 }
 
 
+#ifdef PALM
+// Executes in the event thread
+static void PausedCb(void* UserData, SDL_bool Paused)
+{
+    SDL_VideoDevice *this = (SDL_VideoDevice*)UserData;
+
+#ifdef FBCON_DEBUG
+    fprintf(stderr, "PausedCb: %d\n", Paused);
+#endif
+
+    if (Paused != this->hidden->Paused) {
+        this->hidden->Paused = Paused;
+        
+        // low-level pause/resume the audio. This is even lower level
+        // than SDL_PauseAudio, and does not affect its state. Also, it
+        // doesn't matter what thread calls it. The sound thread ultimately
+        // executes the pausing when it gets around to it.
+        SDL_SuppressAudio(Paused);
+
+        SDL_PrivateAppActive(Paused ? 0 : 1, (SDL_APPACTIVE|SDL_APPINPUTFOCUS|SDL_APPMOUSEFOCUS));
+    }
+}
+
+// Executes in the event thread
+static void FocusedCb(void* UserData, SDL_bool Focused)
+{
+    SDL_VideoDevice *this = (SDL_VideoDevice*)UserData;
+
+#ifdef FBCON_DEBUG
+    fprintf(stderr, "FocusedCb: %d\n", Focused);
+#endif
+
+    if (this->screen) {
+        if (this->hidden->MultiLayer && !Focused) {
+            FB_Blank();
+        }
+    }
+}
+
+// Executes in the main thread
+static void ActivateCb(void* UserData, int Active)
+{
+    SDL_VideoDevice *this = (SDL_VideoDevice*)UserData;
+    
+#ifdef FBCON_DEBUG
+    fprintf(stderr, "ActivateCb: %d\n", Active);
+    Uint32 Time = SDL_GetTicks();
+#endif
+
+    if (Active != this->hidden->Active) {
+        this->hidden->Active = Active;
+         
+        if (this->screen) {
+            if (this->screen->flags & SDL_OPENGLES) {
+#if SDL_VIDEO_OPENGL_ES
+                if (Fbcon_GLES_MakeCurrent(this) < 0) {
+#ifdef FBCON_DEBUG                
+                    fprintf(stderr, "MakeCurrent failed!\n");
+#endif                
+                }
+#endif                
+            }
+            else {
+                if (this->hidden->Active) {
+                    /* Update cache_vinfo to get current yoffset */
+                    ioctl(console_fd, FBIOGET_VSCREENINFO, &cache_vinfo);
+                }
+
+                int ScreenSize = cache_vinfo.yres * this->hidden->cache_finfo.line_length;
+                void *Display = mapped_mem + mapped_offset;
+                Display += cache_vinfo.yoffset * this->hidden->cache_finfo.line_length;
+
+                void *Offscreen;
+                int SizeInBytes;
+
+                SDL_WebOsEventOffscreenLock(&Offscreen, &SizeInBytes);
+                if (Offscreen) {
+#ifdef FBCON_DEBUG
+                    if (SizeInBytes != ScreenSize) {
+                        fprintf(stderr, "SizeInBytes (%d) != ScreenSize (%d)\n", SizeInBytes, ScreenSize);
+                    }
+#endif
+
+                    if (this->hidden->Active) {
+                        // Going active: copy offscreen surface to FB
+                        SDL_memcpy(Display, Offscreen, ScreenSize);
+
+#ifdef SDL_FBCON_VFB
+                        if (0 && this->screen->flags & SDL_HWSURFACE) {
+                            printf( "*** Enabling direct rendering to the screen\n");
+                            this->screen->pixels = Display;
+                        }
+#endif
+                    }
+                    else {
+                        // Going inactive: copy FB to offscreen surface
+                        SDL_memcpy(Offscreen, Display, ScreenSize);
+
+#ifdef SDL_FBCON_VFB
+                        if (0 && this->screen->flags & SDL_HWSURFACE) {
+                            printf( "*** Disabling direct rendering to the screen\n");
+                            this->screen->pixels = this->hidden->vfb.mem;
+                        }
+#endif
+                    }
+
+                    SDL_WebOsEventOffscreenUnlock(SDL_TRUE);
+                }
+            }
+
+            if (this->hidden->MultiLayer) {
+                if (this->hidden->Active) {
+                    /* Enable video layer while UiLayer has offscreen surface */
+                    FB_Unblank();
+
+                    /* Clear the UI layer to transparent by trashing the offscreen buffer */
+                    void* Offscreen;
+                    int SizeInBytes;
+
+                    SDL_WebOsEventOffscreenLock(&Offscreen, &SizeInBytes);
+                    if (Offscreen) {
+                        SDL_memset(Offscreen, 0, SizeInBytes);
+                        SDL_WebOsEventOffscreenUnlock(SDL_TRUE);
+                    }
+                }
+                else {
+                    /* Do nothing here.  Video layer is disabled later, in the focused callback */
+                }
+            }
+
+        }
+    }
+
+#ifdef FBCON_DEBUG
+    Time = SDL_GetTicks() - Time;
+    printf( "ActivateCb took %d ms\n", Time);
+#endif
+
+}
+#endif
+
+
 /* Small wrapper for mmap() so we can play nicely with no-mmu hosts
  * (non-mmu hosts disallow the MAP_SHARED flag) */
 
@@ -208,6 +366,11 @@ static void FB_DeleteDevice(SDL_VideoDev
 {
 	SDL_free(device->hidden);
 	SDL_free(device);
+#ifdef HAVE_OPENGL_ES
+    if ( device->gles_data ) {
+        free(device->gles_data);
+    }
+#endif
 }
 
 static SDL_VideoDevice *FB_CreateDevice(int devindex)
@@ -220,8 +383,16 @@ static SDL_VideoDevice *FB_CreateDevice(
 		SDL_memset(this, 0, (sizeof *this));
 		this->hidden = (struct SDL_PrivateVideoData *)
 				SDL_malloc((sizeof *this->hidden));
+#if SDL_VIDEO_OPENGL_ES
+        this->gles_data = (struct SDL_PrivateGLESData *)
+                SDL_malloc((sizeof *this->gles_data));
+#endif
 	}
-	if ( (this == NULL) || (this->hidden == NULL) ) {
+	if ( (this == NULL) || (this->hidden == NULL) 
+#if SDL_VIDEO_OPENGL_ES
+        || (this->gles_data == NULL)
+#endif
+        ) {
 		SDL_OutOfMemory();
 		if ( this ) {
 			SDL_free(this);
@@ -229,11 +400,22 @@ static SDL_VideoDevice *FB_CreateDevice(
 		return(0);
 	}
 	SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+#ifdef SDL_VIDEO_OPENGL_ES
+    SDL_memset(this->gles_data, 0, (sizeof *this->gles_data));
+#endif
+
 	wait_vbl = FB_WaitVBL;
 	wait_idle = FB_WaitIdle;
 	mouse_fd = -1;
 	keyboard_fd = -1;
 
+#ifdef PALM
+	this->hidden->Active = SDL_FALSE;
+	this->hidden->Paused = SDL_FALSE;
+	this->hidden->Visible = SDL_FALSE;
+	this->hidden->OverlayBuffer = NULL;
+#endif	
+
 	/* Set the function pointers */
 	this->VideoInit = FB_VideoInit;
 	this->ListModes = FB_ListModes;
@@ -250,6 +432,28 @@ static SDL_VideoDevice *FB_CreateDevice(
 	this->UnlockHWSurface = FB_UnlockHWSurface;
 	this->FlipHWSurface = FB_FlipHWSurface;
 	this->FreeHWSurface = FB_FreeHWSurface;
+
+#ifdef SDL_VIDEO_OPENGL
+#ifdef PALM // Palm's implementation of GL is only partial and it goes through GL-ES
+    this->GL_LoadLibrary = Fbcon_GLES_LoadLibrary;
+    this->GL_GetProcAddress = Fbcon_GLES_GetProcAddress;
+    this->GL_GetAttribute = Fbcon_GLES_GetAttribute;
+    this->GL_MakeCurrent = Fbcon_GLES_MakeCurrent;
+    this->GL_SwapBuffers = Fbcon_GLES_SwapBuffers;
+#endif
+#endif
+
+#ifdef SDL_VIDEO_OPENGL_ES
+    this->GLES_LoadLibrary      = Fbcon_GLES_LoadLibrary;
+    this->GLES_GetProcAddress   = Fbcon_GLES_GetProcAddress;
+    this->GLES_GetAttribute     = Fbcon_GLES_GetAttribute;
+    this->GLES_MakeCurrent      = Fbcon_GLES_MakeCurrent;
+    this->GLES_SwapBuffers      = Fbcon_GLES_SwapBuffers;
+
+    this->gles_data->egl_window = EGL_NO_SURFACE;
+    this->gles_data->egl_pbuffer= EGL_NO_SURFACE;
+#endif
+
 	this->SetCaption = NULL;
 	this->SetIcon = NULL;
 	this->IconifyWindow = NULL;
@@ -481,6 +685,143 @@ static void FB_SortModes(_THIS)
 	}
 }
 
+/* PALM */
+static void FB_LayerQuit(struct SDL_FbLayer* Layer)
+{
+    if (Layer->Fd) {
+        close(Layer->Fd);
+        Layer->Fd = 0;
+    }
+
+    if (Layer->MappedMem) {
+        munmap(Layer->MappedMem, Layer->MappedMemLen);
+        Layer->MappedMem = NULL;
+    }
+}
+
+static int FB_LayerInit(const char* Device, struct SDL_FbLayer* Layer)
+{
+    const int pagesize = SDL_getpagesize();
+
+    SDL_memset(Layer, 0, sizeof(struct SDL_FbLayer));
+
+    int Fd = open(Device, O_RDWR, 0);
+    if ( Fd < 0 ) {
+        SDL_SetError("Unable to open layer %s", Device);
+        return(-1);
+    }
+
+    Layer->Fd = Fd;
+
+    if ( ioctl(Layer->Fd, FBIOGET_FSCREENINFO, &Layer->finfo) < 0 ) {
+        SDL_SetError("Couldn't get layer hardware info");
+        FB_LayerQuit(Layer);
+        return(-1);
+    }
+
+    switch (Layer->finfo.type) {
+        case FB_TYPE_PACKED_PIXELS:
+            /* Supported, no worries.. */
+            break;
+        default:
+            SDL_SetError("Unsupported console layer hardware");
+            FB_LayerQuit(Layer);
+            return(-1);
+    }
+
+    switch (Layer->finfo.visual) {
+        case FB_VISUAL_TRUECOLOR:
+        case FB_VISUAL_PSEUDOCOLOR:
+        case FB_VISUAL_STATIC_PSEUDOCOLOR:
+        case FB_VISUAL_DIRECTCOLOR:
+            break;
+        default:
+            SDL_SetError("Unsupported console layer hardware");
+            FB_LayerQuit(Layer);
+            return(-1);
+    }
+
+    /* Check if the user wants to disable hardware acceleration */
+    { const char *fb_accel;
+        fb_accel = SDL_getenv("SDL_FBACCEL");
+        if ( fb_accel ) {
+            Layer->finfo.accel = SDL_atoi(fb_accel);
+        }
+    }
+
+    /* Memory map the device, compensating for buggy PPC mmap() */
+    Layer->MappedOffset = (((long)Layer->finfo.smem_start) - (((long)Layer->finfo.smem_start)&~(pagesize-1)));
+    Layer->MappedMemLen = Layer->finfo.smem_len + Layer->MappedOffset;
+
+    //printf( "Layer %s: MappedMemLen %d\n", Device, Layer->MappedMemLen);
+
+    Layer->MappedMem = do_mmap(NULL, Layer->MappedMemLen, PROT_READ|PROT_WRITE, MAP_SHARED, Layer->Fd, 0);
+    if (Layer->MappedMem == (char *)-1 ) {
+        SDL_SetError("Unable to memory map the layer hardware");
+        Layer->MappedMem = NULL;
+        FB_LayerQuit(Layer);
+        return(-1);
+    }
+
+    /* Determine the current screen depth */
+    if ( ioctl(Layer->Fd, FBIOGET_VSCREENINFO, &Layer->vinfo) < 0 ) {
+        SDL_SetError("Couldn't get layer pixel format");
+        FB_LayerQuit(Layer);
+        return(-1);
+    }
+
+    return 0;
+}
+
+void FB_LayerWaitForVsync(struct SDL_FbLayer* Layer)
+{
+    int StartTime = SDL_GetTicks();
+    int Dummy;
+
+    ioctl(Layer->Fd, FBIO_WAITFORVSYNC, &Dummy);
+
+    if (SDL_GetTicks() - StartTime == 0) {
+        /* To be sure it worked, wait for the next one */
+        ioctl(Layer->Fd, FBIO_WAITFORVSYNC, &Dummy);
+    }
+}
+
+void FB_LayerGetBuffer(struct SDL_FbLayer* Layer, void** Buffer, int* SizeInBytes)
+{
+    ioctl(Layer->Fd, FBIOGET_VSCREENINFO, &Layer->vinfo);
+
+	if (Buffer) {
+	    *Buffer = Layer->MappedMem + Layer->MappedOffset + Layer->vinfo.yoffset * Layer->finfo.line_length;
+	}
+	if (SizeInBytes) {
+    	*SizeInBytes = Layer->vinfo.yres * Layer->finfo.line_length;
+    }
+}
+
+void FB_Blank(void)
+{
+    SDL_VideoDevice* this = current_video;
+    if (this && console_fd > 0) {
+        if (this->hidden->Visible) {
+            SDL_WebOsEventLayerEnable(SDL_FALSE, console_fd);
+            this->hidden->Visible = SDL_FALSE;
+        }
+    }
+}
+
+void FB_Unblank(void)
+{
+    SDL_VideoDevice* this = current_video;
+    if (this && console_fd > 0) {
+        if (!this->hidden->Visible) {
+            SDL_WebOsEventLayerEnable(SDL_TRUE, console_fd);
+            this->hidden->Visible = SDL_TRUE;
+        }
+    }
+}
+
+/*/PALM */
+
 static int FB_VideoInit(_THIS, SDL_PixelFormat *vformat)
 {
 	const int pagesize = SDL_getpagesize();
@@ -496,7 +837,11 @@ static int FB_VideoInit(_THIS, SDL_Pixel
 	/* Initialize the library */
 	SDL_fbdev = SDL_getenv("SDL_FBDEV");
 	if ( SDL_fbdev == NULL ) {
+#ifdef PALM
+	    SDL_fbdev = "/dev/fb1";
+#else
 		SDL_fbdev = "/dev/fb0";
+#endif
 	}
 	console_fd = open(SDL_fbdev, O_RDWR, 0);
 	if ( console_fd < 0 ) {
@@ -504,6 +849,25 @@ static int FB_VideoInit(_THIS, SDL_Pixel
 		return(-1);
 	}
 
+	/* PALM */
+	FB_LayerInit("/dev/fb0", &this->hidden->UiLayer);
+
+	this->hidden->MultiLayer = (strcmp(SDL_fbdev, "/dev/fb0") != 0);
+	
+    if (SDL_WebOsEventInit() < 0) {
+        return 0;
+    }
+    if (!SDL_WebOsEventRegisterActivateCallback(ActivateCb, this)) {
+        return 0;
+    }
+    if (!SDL_WebOsEventRegisterFocusedCallback(FocusedCb, this)) {
+        return 0;
+    }
+    if (!SDL_WebOsEventRegisterPausedCallback(PausedCb, this)) {
+        return 0;
+    }
+	/*/PALM */
+	
 #if !SDL_THREADS_DISABLED
 	/* Create the hardware surface lock mutex */
 	hw_lock = SDL_CreateMutex();
@@ -715,6 +1079,10 @@ static int FB_VideoInit(_THIS, SDL_Pixel
 		}
 	}
 
+#if SDL_FBCON_VFB
+	memset(&this->hidden->vfb, 0, sizeof(this->hidden->vfb));
+#endif
+
 	/* Enable mouse and keyboard support */
 	if ( FB_OpenKeyboard(this) < 0 ) {
 		FB_VideoQuit(this);
@@ -737,6 +1105,10 @@ static int FB_VideoInit(_THIS, SDL_Pixel
 
 static SDL_Rect **FB_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
 {
+#if SDL_FBCON_VFB
+    /* With VFB we support any resolution. */
+    return (SDL_Rect **)-1;
+#endif    
 	return(SDL_modelist[((format->BitsPerPixel+7)/8)-1]);
 }
 
@@ -927,14 +1299,30 @@ static SDL_Surface *FB_SetVideoMode(_THI
 	Uint32 Rmask;
 	Uint32 Gmask;
 	Uint32 Bmask;
+	/* PALM */
+	Uint32 Amask;
+	/* /PALM */
 	char *surfaces_mem;
 	int surfaces_len;
 
 	/* Set the terminal into graphics mode */
+#if defined PALM
+	if (flags & (SDL_HWSURFACE | SDL_DOUBLEBUF)) {
+	    SDL_SetError( "SDL_HWSURFACE and/or SDL_DOUBLEBUF not supported\n");
+	    return(NULL);
+	}
+	
+#ifdef FBCON_DEBUG
+    fprintf(stderr, "%s:%d skipping terminal set into graphics mode because it hangs on Castle\n",
+			__FILE__, __LINE__);
+#endif
+
+#else	
 	if ( FB_EnterGraphicsMode(this) < 0 ) {
 		return(NULL);
 	}
-
+#endif
+	
 	/* Restore the original palette */
 	FB_RestorePalette(this);
 
@@ -947,8 +1335,119 @@ static SDL_Surface *FB_SetVideoMode(_THI
 	fprintf(stderr, "Printing original vinfo:\n");
 	print_vinfo(&vinfo);
 #endif
+
+#if SDL_FBCON_VFB  
+    struct SDL_fbvideo_virtualfb* vfb = &this->hidden->vfb;
+
+    this->hidden->use_vfb = (flags & SDL_OPENGLES) == 0;
+    if (this->hidden->use_vfb) {
+
+        const char* vfb_rot = SDL_getenv("SDL_VFB_ROT");
+
+        if (vfb_rot) {
+            this->hidden->vfb.rotated = (atoi(vfb_rot) ? 1 : 0);
+        }
+        else {
+            this->hidden->vfb.rotated = (width > height);
+        }
+
+        if (this->hidden->vfb.rotated) {
+        	/* Hopefully the user would never want anything different! */
+            SDL_WebOsEventSetOrientation("left");
+        }
+
+#ifdef FBCON_DEBUG
+        fprintf(stderr, "VFB rotated: %d\n", this->hidden->vfb.rotated);
+#endif
+
+        if (vfb->mem) {
+	        SDL_free(vfb->mem);
+	    }
+	    
+	    // Virtual framebuffer gives the app whatever resolution it requests.
+	    // We don't want to deal with color conversion though, so we force the FB to 32bpp.
+	    // If the app requests a bit depth other than 32bpp, SDL will create a shadow
+	    // surface and do the conversion for us.  This is a performance issue.
+#ifdef FBCON_DEBUG
+	    if (bpp != 32) {
+	        fprintf(stderr, "VFB buffer at 32bpp only (not %d)\n", bpp );
+	    }
+#endif
+	    bpp = 32;
+	    
+	    vfb->width = width;
+	    vfb->height = height;
+	    vfb->pitch = width * bpp / 8;
+	    vfb->mem = (char*)SDL_malloc(vfb->pitch * vfb->pitch);
+	    if (vfb->mem) {        
+	        // The display resolution is always the native resolution.
+	        width = vinfo.xres;
+	        height = vinfo.yres;
+#ifdef FBCON_DEBUG
+	        fprintf(stderr, "Using VFB %dx%d rotated %d\n", vfb->width, vfb->height, vfb->rotated);
+#endif
+	    }
+	    
+	    vfb->scale = 1.0f;
+	    
+	    float sx, sy;
+	    if (vfb->rotated) {
+	        sx = (float)width / (float)vfb->height;
+	        sy = (float)height / (float)vfb->width;
+	    }
+	    else {
+	        sx = (float)width / (float)vfb->width;
+	        sy = (float)height / (float)vfb->height;
+	    }
+	    if (sx < 1.0f || sy < 1.0f) {
+	        vfb->scale = (sx < sy ? sx : sy);
+	    }
+	    else if (sx > 1.0f && sy > 1.0f) {
+	        vfb->scale = (sx < sy ? sx : sy);
+	        //printf( "%f %f %f\n", sx, sy, vfb->scale);
+	        
+	        if (fabs(1.0f - vfb->scale) < 0.25) {
+	             // Don't bother scaling.
+	             vfb->scale = 1.0f;
+	        }
+	    }
+	    
+	    vfb->scaled_width = (int)(vfb->scale * (float)vfb->width);
+	    vfb->scaled_height = (int)(vfb->scale * (float)vfb->height);
+	    
+	    int finalw = vfb->rotated ? vfb->scaled_height : vfb->scaled_width;
+	    int finalh = vfb->rotated ? vfb->scaled_width  : vfb->scaled_height;
+
+	    vfb->dx = 0;
+	    vfb->dy = 0;
+	    
+        if (finalh < height) {                    
+            // Center the display.
+            vfb->dy = (height - finalh) / 2;
+        }
+        if (finalw < width) {
+            // Center the display.
+            vfb->dx = (width - finalw) / 2;
+        }
+        
+#ifdef FBCON_DEBUG
+        fprintf(stderr, "VFB w:h %d:%d scale %f sw:sh %d:%d dx:dy %d:%d\n",
+                vfb->width, vfb->height, vfb->scale, vfb->scaled_width, vfb->scaled_height, vfb->dx, vfb->dy);
+#endif
+	}
+#endif
+	
+#ifdef PALM
+	// Only allow 32 bpp framebuffers because when we are deactivated we will be rendering into a 32bpp offscreen buffer
+	// FIXME: may degrade perf for apps that request other than 32bpp, can we work around this?
+	bpp = 32;
+	width = vinfo.xres;
+	height = vinfo.yres;
+#endif
+	
 	if ( (vinfo.xres != width) || (vinfo.yres != height) ||
-	     (vinfo.bits_per_pixel != bpp) || (flags & SDL_DOUBLEBUF) ) {
+	     (vinfo.bits_per_pixel != bpp) || (flags & SDL_DOUBLEBUF)) {
+
 		vinfo.activate = FB_ACTIVATE_NOW;
 		vinfo.accel_flags = 0;
 		vinfo.bits_per_pixel = bpp;
@@ -966,9 +1465,20 @@ static SDL_Surface *FB_SetVideoMode(_THI
 		vinfo.green.length = vinfo.green.offset = 0;
 		vinfo.blue.length = vinfo.blue.offset = 0;
 		vinfo.transp.length = vinfo.transp.offset = 0;
-		if ( ! choose_fbmodes_mode(&vinfo) ) {
+#if defined PALM
+		/* OMAP FB driver will disable alpha if transp.length is zero */
+		vinfo.transp.length = (bpp == 32) ? 8 : 0;
+		
+#ifdef FBCON_DEBUG
+		fprintf(stderr, "%s:%d skipping fancy mode set stuff because Castle FB driver rejects it\n",
+				__FILE__, __LINE__);
+#endif
+#else		
+        if ( ! choose_fbmodes_mode(&vinfo) ) {
 			choose_vesa_mode(&vinfo);
-		}
+        }
+#endif
+		
 #ifdef FBCON_DEBUG
 		fprintf(stderr, "Printing wanted vinfo:\n");
 		print_vinfo(&vinfo);
@@ -1013,11 +1523,19 @@ static SDL_Surface *FB_SetVideoMode(_THI
 		Bmask <<= 1;
 		Bmask |= (0x00000001<<vinfo.blue.offset);
 	}
+	/* PALM */
+	Amask = 0;
+    for ( i=0; i<vinfo.transp.length; ++i ) {
+        Amask <<= 1;
+        Amask |= (0x00000001<<vinfo.transp.offset);
+    }
+	
 	if ( ! SDL_ReallocFormat(current, vinfo.bits_per_pixel,
-	                                  Rmask, Gmask, Bmask, 0) ) {
+	                                  Rmask, Gmask, Bmask, Amask) ) {
 		return(NULL);
 	}
-
+	/*/PALM */
+	
 	/* Get the fixed information about the console hardware.
 	   This is necessary since finfo.line_length changes.
 	 */
@@ -1030,12 +1548,42 @@ static SDL_Surface *FB_SetVideoMode(_THI
 	FB_SavePalette(this, &finfo, &vinfo);
 
 	/* Set up the new mode framebuffer */
-	current->flags = (SDL_FULLSCREEN|SDL_HWSURFACE);
-	current->w = vinfo.xres;
-	current->h = vinfo.yres;
-	current->pitch = finfo.line_length;
-	current->pixels = mapped_mem+mapped_offset;
+#if SDL_FBCON_VFB
+	this->hidden->cache_finfo = finfo;
 
+	if (this->hidden->use_vfb && vfb->mem) {
+	    current->flags = SDL_FULLSCREEN;	    
+	    if (0 && vfb->scale == 1.0f && !vfb->rotated) {
+	        /* We can give the app direct access to the screen */
+	        current->flags |= SDL_HWSURFACE;
+	    }
+	    current->w = vfb->width;
+	    current->h = vfb->height;
+	    current->pitch = vfb->pitch;
+	    current->pixels = vfb->mem;
+	}
+	else {
+#endif
+    	current->flags = (SDL_FULLSCREEN|SDL_HWSURFACE);
+#if SDL_VIDEO_OPENGL_ES
+		// PALM
+        if (flags & SDL_OPENGLES) {
+            current->flags |= SDL_OPENGLES;
+            if (Fbcon_GLES_CreateWindow(this,width,height) < 0) {
+				// TODO: double check should we just return NULL here?
+                return NULL;
+            }
+        }
+		///PALM
+#endif
+    	current->w = vinfo.xres;
+    	current->h = vinfo.yres;
+    	current->pitch = finfo.line_length;
+    	current->pixels = mapped_mem+mapped_offset;
+#if SDL_FBCON_VFB    	
+	}
+#endif
+	
 	/* Set up the information for hardware surfaces */
 	surfaces_mem = (char *)current->pixels +
 	                        vinfo.yres_virtual*current->pitch;
@@ -1069,6 +1617,10 @@ static SDL_Surface *FB_SetVideoMode(_THI
 	/* Set the update rectangle function */
 	this->UpdateRects = FB_DirectUpdate;
 
+	//PALM
+    FB_SetInputTransform(this);
+    ///PALM
+    
 	/* We're done */
 	return(current);
 }
@@ -1329,9 +1881,253 @@ static int FB_FlipHWSurface(_THIS, SDL_S
 	return(0);
 }
 
+static inline void memcpyrot(char* dst, char* src, int count, int elemsize, int dstincr)
+{
+    switch(elemsize) {
+    case 4:
+        while (count--) {
+            *(int*)dst = *(int*)src;
+            src += elemsize;
+            dst += dstincr;
+        }
+        break;
+        
+    case 2:
+        while (count--) {
+            *(short*)dst = *(short*)src;
+            src += elemsize;
+            dst += dstincr;
+        }
+        break;
+        
+    case 1:
+        while (count--) {
+            *dst = *src;
+            src += elemsize;
+            dst += dstincr;
+        }
+        break;
+        
+    default:
+        printf( "memcpyrot: unimplemented %d\n", elemsize);
+        break;
+    }
+}
+
+
+/* PALM */
+void FB_DisplayFps()
+{
+    if (SDL_FALSE) {
+        const  Uint32 SamplePeriodMs = 1000;
+        static Uint32 LastSampleMs = 0;
+        static Uint32 FrameCount = 0;
+
+        ++FrameCount;
+
+        Uint32 TimeMs = SDL_GetTicks();
+        if (TimeMs - LastSampleMs >= SamplePeriodMs) {
+            float Fps = FrameCount * 1000 / (float)(TimeMs - LastSampleMs);
+            printf( "SDL FPS: %.2f\n", Fps);
+            LastSampleMs = TimeMs;
+            FrameCount = 0;
+        }
+    }
+}
+/*/PALM */
+
 static void FB_DirectUpdate(_THIS, int numrects, SDL_Rect *rects)
 {
+    /* PALM */
+    FB_DisplayFps();
+    /*/PALM */
+
+#ifdef SDL_FBCON_VFB
+    struct SDL_fbvideo_virtualfb* vfb = &this->hidden->vfb;
+    
+    if (this->hidden->use_vfb && vfb->mem) {
+        int dst_pitch = this->hidden->cache_finfo.line_length;
+        int bytespp = cache_vinfo.bits_per_pixel / 8;
+        float scale = vfb->scale;
+        SDL_bool Overlay = SDL_FALSE;
+        SDL_Rect FullScreen;
+        void* DstMem;
+
+#ifdef FBCON_DEBUG
+        //fprintf(stderr, "FB_DirectUpdate active %d yoffset %d\n", this->hidden->Active, cache_vinfo.yoffset);
+#endif
+
+        if (this->hidden->Active) {
+            DstMem = mapped_mem + mapped_offset + cache_vinfo.yoffset * dst_pitch;
+
+            /* Overlay drawing on client side is deprecated; to be removed */
+            /* Overlay = SDL_WebOsEventOverlayActive(); */
+            if (Overlay) {
+
+                /* Update the entire screen so we can draw the overlay anywhere.
+                 * This is slow, but otherwise we need to map the screen overlay area into the VFB.
+                 * Also, we end of drawing to the FB twice in the overlay region, which causes flicker
+                 * because we aren't double buffering.
+                 */
+                numrects = 1;
+                rects = &FullScreen;
+
+                rects->x = 0;
+                rects->y = 0;
+                rects->w = vfb->width;
+                rects->h = vfb->height;
+
+                if (SDL_WebOsEventOverlayChanged()) {
+                    void* Buffer;
+                    int Width, Height;
+
+                    SDL_WebOsEventOverlayLock(&Buffer, &Width, &Height);
+
+                    if (Buffer) {
+                        /* Try to reuse an existing overlay buffer */
+                        if (this->hidden->OverlayBuffer) {
+                            if (Width != this->hidden->OverlayWidth || Height != this->hidden->OverlayHeight) {
+                                SDL_free(this->hidden->OverlayBuffer);
+                                this->hidden->OverlayBuffer = NULL;
+                            }
+                        }
+
+                        /* Allocate an overlay buffer if necessary */
+                        if (!this->hidden->OverlayBuffer) {
+                            this->hidden->OverlayBuffer = SDL_malloc(Width * Height * bytespp);
+                            this->hidden->OverlayWidth = Width;
+                            this->hidden->OverlayHeight = Height;
+                        }
+
+                        if (this->hidden->OverlayBuffer) {
+                            /* Copy overlay data */
+                            SDL_memcpy(this->hidden->OverlayBuffer, Buffer, Width * Height * bytespp);
+                        }
+
+                        SDL_WebOsEventOverlayUnlock();
+                    }
+                }
+            }
+        }
+        else {
+            SDL_WebOsEventOffscreenLock(&DstMem, NULL);
+        }
+        
+        while (DstMem && numrects--) {
+			struct FB_VfbBlitSurface Src, Dst;
+
+            //printf( "rect %d: x %d y %d w %d h %d\n", rect++, rects->x, rects->y, rects->w, rects->h);
+			if (scale != 1.0f) {
+				Src.Mem         = vfb->mem;
+                Src.Width       = vfb->width;
+                Src.Height      = vfb->height;
+                Src.Pitch       = vfb->pitch;
+                Src.RectX       = rects->x;
+                Src.RectY       = rects->y;
+                Src.RectWidth   = rects->w;
+                Src.RectHeight  = rects->h;
+                Dst.Mem         = DstMem;
+                Dst.Width       = cache_vinfo.xres;
+                Dst.Height      = cache_vinfo.yres;
+                Dst.Pitch       = dst_pitch;
+                Dst.RectX       = scale * rects->x;
+                Dst.RectY       = scale * rects->y;
+                if (vfb->rotated) {
+                    Dst.RectX   += (float)vfb->dy;
+                    Dst.RectY   += (float)vfb->dx;
+                }
+                else {
+                    Dst.RectX   += (float)vfb->dx;
+                    Dst.RectY   += (float)vfb->dy;
+                }
+                Dst.RectWidth   = scale * rects->w;
+                Dst.RectHeight  = scale * rects->h;
+			}
+			
+            if (vfb->rotated) {
+                
+                if (scale != 1.0f) {
+                    FB_VfbBlit(&Dst, &Src, 1);
+                }
+                else {                    
+                    int   rowbytes = rects->w * bytespp;
+                    char* src = vfb->mem + rects->y * vfb->pitch;
+                    char* dst = DstMem + (rects->y + vfb->dy) * dst_pitch + bytespp * (cache_vinfo.xres - 1 - vfb->dx);               
+                    int   count = rects->w;
+                    int   rows;                
+                    
+                    for (rows = rects->h; rows--; ) {
+                        memcpyrot(dst, src, count, bytespp, dst_pitch);
+                        dst -= bytespp;
+                        src += vfb->pitch;
+                    }
+                }
+            }
+            else {
+                if (vfb->scale != 1.0f) {
+                    FB_VfbBlit(&Dst, &Src, 0);
+                }
+                else {
+                    int   rowbytes = rects->w * bytespp;
+                    char* src = vfb->mem + rects->y * vfb->pitch + rects->x * bytespp;
+                    char* dst = DstMem + (rects->y + vfb->dy) * dst_pitch + (rects->x + vfb->dx) * bytespp;
+                    int   rows;
+                    
+                    for (rows = rects->h; rows--; ) {
+                        memcpy(dst, src, rowbytes);
+                        dst += dst_pitch;
+                        src += vfb->pitch;
+                    }
+                }
+            }
+            rects++;
+        }
+
+        if (Overlay && this->hidden->OverlayBuffer) {
+            struct FB_VfbBlitSurface Src, Dst;
+
+            // Draw the overlay.
+            Src.Mem         = this->hidden->OverlayBuffer;
+            Src.Width       = this->hidden->OverlayWidth;
+            Src.Height      = this->hidden->OverlayHeight;
+            Src.Pitch       = this->hidden->OverlayWidth * bytespp;
+            Src.RectX       = 0;
+            Src.RectY       = 0;
+            Src.RectWidth   = Src.Width;
+            Src.RectHeight  = Src.Height;
+            Dst.Mem         = DstMem;
+            Dst.Width       = cache_vinfo.xres;
+            Dst.Height      = cache_vinfo.yres;
+            Dst.Pitch       = dst_pitch;
+            Dst.RectX       = 0;
+            Dst.RectY       = Dst.Height - Src.Height;
+            Dst.RectWidth   = Src.RectWidth;
+            Dst.RectHeight  = Src.RectHeight;
+
+            FB_VfbBlit(&Dst, &Src, 0);
+        }
+
+        if (!this->hidden->Active && DstMem) {
+            SDL_WebOsEventOffscreenUnlock(SDL_TRUE);
+        }
+    }
+    else {
+        // App is writing directly into the framebuffer.
+    }
+#endif
 	/* The application is already updating the visible video memory */
+
+    //PALM
+    if (this->hidden->Paused) {
+        // Cap our frame rate while inactive.
+        Uint32 Ms = 1000 / SDL_WEBOS_DEACTIVATED_FPS_CAP;
+        if (SDL_DelayWithEventInterrupt(Ms) == 0) {
+#ifdef FBCON_DEBUG
+			fprintf(stderr, "Event interrupted my delay!\n");
+#endif
+        }
+    }
+
 	return;
 }
 
@@ -1636,6 +2432,28 @@ static void FB_VideoQuit(_THIS)
 {
 	int i, j;
 
+	/* PALM */
+	if (this->hidden->MultiLayer) {
+	    /* Don't need to blank here; done in SDL_HighPriorityQuit */
+	    /* FB_Blank(); */
+	}
+	FB_LayerQuit(&this->hidden->UiLayer);
+
+	if (this->hidden->use_vfb && this->hidden->vfb.mem) {
+	    SDL_free(this->hidden->vfb.mem);
+	}
+
+#if SDL_VIDEO_OPENGL_ES
+    if (this->screen && this->screen->flags & SDL_OPENGLES) {
+        Fbcon_GLES_Shutdown(this);
+        Fbcon_GLES_UnloadLibrary(this);
+    }
+    if (this->gles_data) {
+        SDL_free(this->gles_data);
+    }    
+#endif
+    /*/PALM */
+
 	if ( this->screen ) {
 		/* Clear screen and tell SDL not to free the pixels */
 		if ( this->screen->pixels && FB_InGraphicsMode(this) ) {
@@ -1687,15 +2505,24 @@ static void FB_VideoQuit(_THIS)
 		}
 
 		/* Restore the original video mode and palette */
+#ifndef PALM		
 		if ( FB_InGraphicsMode(this) ) {
+#endif		    
 			FB_RestorePalette(this);
 			ioctl(console_fd, FBIOPUT_VSCREENINFO, &saved_vinfo);
+#ifndef PALM			
 		}
-
+#endif
 		/* We're all done with the framebuffer */
 		close(console_fd);
 		console_fd = -1;
 	}
 	FB_CloseMouse(this);
 	FB_CloseKeyboard(this);
+
+#ifdef PALM
+	if (this->hidden->OverlayBuffer) {
+	    SDL_free(this->hidden->OverlayBuffer);
+	}
+#endif
 }
diff -pruN libsdl-1.2/src/video/fbcon/SDL_fbvideo.h libsdl-1.2-palm/src/video/fbcon/SDL_fbvideo.h
--- libsdl-1.2/src/video/fbcon/SDL_fbvideo.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/fbcon/SDL_fbvideo.h	2009-11-24 00:14:18.000000000 -0800
@@ -35,6 +35,25 @@
 #include "tslib.h"
 #endif
 
+#if SDL_VIDEO_OPENGL_ES
+#include "SDL_opengles.h"
+#endif
+
+#ifdef PALM
+#define SDL_INPUT_TSLIB     1
+#include "../src/events/webos/tslib.h"
+#endif
+
+#ifdef PALM
+#define SDL_FBCON_VFB           1
+#define SDL_FBCON_NATIVE_WIDTH  320
+#define SDL_FBCON_NATIVE_HEIGHT 480
+#endif
+
+#ifndef SDL_FBCON_VFB
+#define SDL_FBCON_VFB           0
+#endif
+
 /* Hidden "this" pointer for the video functions */
 #define _THIS	SDL_VideoDevice *this
 
@@ -49,11 +68,43 @@ typedef struct vidmem_bucket {
 	struct vidmem_bucket *next;
 } vidmem_bucket;
 
+#if SDL_FBCON_VFB
+struct SDL_fbvideo_virtualfb
+{
+    char*  mem;
+    int    pitch;
+    int    width;
+    int    height;
+    int    rotated;
+    float  scale;
+    int    scaled_width;
+    int    scaled_height;
+    int    dx;
+    int    dy;
+};
+#endif
+
+/* PALM */
+struct SDL_FbLayer
+{
+    struct fb_var_screeninfo vinfo;
+    struct fb_fix_screeninfo finfo;
+
+    int Fd;
+    char *MappedMem;
+    int MappedMemLen;
+    int MappedOffset;
+};
+/*/PALM */
+
 /* Private display data */
 struct SDL_PrivateVideoData {
 	int console_fd;
 	struct fb_var_screeninfo cache_vinfo;
 	struct fb_var_screeninfo saved_vinfo;
+#if SDL_FBCON_VFB
+	struct fb_fix_screeninfo cache_finfo;
+#endif	
 	int saved_cmaplen;
 	__u16 *saved_cmap;
 
@@ -75,7 +126,23 @@ struct SDL_PrivateVideoData {
 	long mapped_iolen;
 	int flip_page;
 	char *flip_address[2];
-
+	
+#if SDL_FBCON_VFB
+	int use_vfb;
+	struct SDL_fbvideo_virtualfb vfb;
+#endif
+	
+#ifdef PALM
+	SDL_bool   Active;
+	SDL_bool   Paused;
+	SDL_bool   Visible;
+
+	void*  OverlayBuffer;
+	int    OverlayWidth;
+	int    OverlayHeight;
+	SDL_bool   MultiLayer;
+#endif
+	
 #define NUM_MODELISTS	4		/* 8, 16, 24, and 32 bits-per-pixel */
 	int SDL_nummodes[NUM_MODELISTS];
 	SDL_Rect **SDL_modelist[NUM_MODELISTS];
@@ -93,6 +160,10 @@ struct SDL_PrivateVideoData {
 
 	void (*wait_vbl)(_THIS);
 	void (*wait_idle)(_THIS);
+
+	/* PALM */
+	struct SDL_FbLayer     UiLayer;
+	/*/PALM */
 };
 /* Old variable names */
 #define console_fd		(this->hidden->console_fd)
@@ -179,4 +250,12 @@ static __inline__ void FB_dst_to_xy(_THI
 	}
 }
 
+/* PALM */
+void FB_DisplayFps(void);
+void FB_LayerWaitForVsync(struct SDL_FbLayer* Layer);
+void FB_LayerGetBuffer(struct SDL_FbLayer* Layer, void** Buffer, int* SizeInBytes);
+void FB_Blank(void);
+void FB_Unblank(void);
+/*/PALM */
+
 #endif /* _SDL_fbvideo_h */
diff -pruN libsdl-1.2/src/video/SDL_glesfuncs.h libsdl-1.2-palm/src/video/SDL_glesfuncs.h
--- libsdl-1.2/src/video/SDL_glesfuncs.h	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/src/video/SDL_glesfuncs.h	2009-04-02 17:08:38.000000000 -0700
@@ -0,0 +1,341 @@
+/* list of OpenGL functions sorted alphabetically
+   If you need to use a GL function from the SDL video subsystem,
+   change it's entry from SDL_PROC_UNUSED to SDL_PROC and rebuild.
+*/
+#define SDL_PROC_UNUSED(ret,func,params)
+SDL_PROC_UNUSED(void,glAccum,(GLenum,GLfloat))
+SDL_PROC_UNUSED(void,glAlphaFunc,(GLenum,GLclampf))
+SDL_PROC_UNUSED(GLboolean,glAreTexturesResident,(GLsizei,const GLuint*,GLboolean*))
+SDL_PROC_UNUSED(void,glArrayElement,(GLint))
+SDL_PROC_UNUSED(void,glBegin,(GLenum))
+SDL_PROC(void,glBindTexture,(GLenum,GLuint))
+SDL_PROC_UNUSED(void,glBitmap,(GLsizei,GLsizei,GLfloat,GLfloat,GLfloat,GLfloat,const GLubyte*))
+SDL_PROC(void,glBlendFunc,(GLenum,GLenum))
+SDL_PROC_UNUSED(void,glCallList,(GLuint))
+SDL_PROC_UNUSED(void,glCallLists,(GLsizei,GLenum,const GLvoid*))
+SDL_PROC_UNUSED(void,glClear,(GLbitfield))
+SDL_PROC_UNUSED(void,glClearAccum,(GLfloat,GLfloat,GLfloat,GLfloat))
+SDL_PROC_UNUSED(void,glClearColor,(GLclampf,GLclampf,GLclampf,GLclampf))
+SDL_PROC_UNUSED(void,glClearDepth,(GLclampd))
+SDL_PROC_UNUSED(void,glClearIndex,(GLfloat))
+SDL_PROC_UNUSED(void,glClearStencil,(GLint))
+SDL_PROC_UNUSED(void,glClipPlane,(GLenum,const GLfloat*))
+SDL_PROC_UNUSED(void,glColor3b,(GLbyte,GLbyte,GLbyte))
+SDL_PROC_UNUSED(void,glColor3bv,(const GLbyte*))
+SDL_PROC_UNUSED(void,glColor3d,(GLfloat,GLfloat,GLfloat))
+SDL_PROC_UNUSED(void,glColor3dv,(const GLfloat*))
+SDL_PROC_UNUSED(void,glColor3f,(GLfloat,GLfloat,GLfloat))
+SDL_PROC_UNUSED(void,glColor3fv,(const GLfloat*))
+SDL_PROC_UNUSED(void,glColor3i,(GLint,GLint,GLint))
+SDL_PROC_UNUSED(void,glColor3iv,(const GLint*))
+SDL_PROC_UNUSED(void,glColor3s,(GLshort,GLshort,GLshort))
+SDL_PROC_UNUSED(void,glColor3sv,(const GLshort*))
+SDL_PROC_UNUSED(void,glColor3ub,(GLubyte,GLubyte,GLubyte))
+SDL_PROC_UNUSED(void,glColor3ubv,(const GLubyte*))
+SDL_PROC_UNUSED(void,glColor3ui,(GLuint,GLuint,GLuint))
+SDL_PROC_UNUSED(void,glColor3uiv,(const GLuint*))
+SDL_PROC_UNUSED(void,glColor3us,(GLushort,GLushort,GLushort))
+SDL_PROC_UNUSED(void,glColor3usv,(const GLushort*))
+SDL_PROC_UNUSED(void,glColor4b,(GLbyte,GLbyte,GLbyte,GLbyte))
+SDL_PROC_UNUSED(void,glColor4bv,(const GLbyte*))
+SDL_PROC_UNUSED(void,glColor4d,(GLfloat,GLfloat,GLfloat,GLfloat))
+SDL_PROC_UNUSED(void,glColor4dv,(const GLfloat*))
+SDL_PROC(void,glColor4f,(GLfloat,GLfloat,GLfloat,GLfloat))
+SDL_PROC_UNUSED(void,glColor4fv,(const GLfloat*))
+SDL_PROC_UNUSED(void,glColor4i,(GLint,GLint,GLint,GLint))
+SDL_PROC_UNUSED(void,glColor4iv,(const GLint*))
+SDL_PROC_UNUSED(void,glColor4s,(GLshort,GLshort,GLshort,GLshort))
+SDL_PROC_UNUSED(void,glColor4sv,(const GLshort*))
+SDL_PROC_UNUSED(void,glColor4ub,(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha))
+SDL_PROC_UNUSED(void,glColor4ubv,(const GLubyte *v))
+SDL_PROC_UNUSED(void,glColor4ui,(GLuint red, GLuint green, GLuint blue, GLuint alpha))
+SDL_PROC_UNUSED(void,glColor4uiv,(const GLuint *v))
+SDL_PROC_UNUSED(void,glColor4us,(GLushort red, GLushort green, GLushort blue, GLushort alpha))
+SDL_PROC_UNUSED(void,glColor4usv,(const GLushort *v))
+SDL_PROC_UNUSED(void,glColorMask,(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
+SDL_PROC_UNUSED(void,glColorMaterial,(GLenum face, GLenum mode))
+SDL_PROC_UNUSED(void,glColorPointer,(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
+SDL_PROC_UNUSED(void,glCopyPixels,(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type))
+SDL_PROC_UNUSED(void,glCopyTexImage1D,(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border))
+SDL_PROC_UNUSED(void,glCopyTexImage2D,(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
+SDL_PROC_UNUSED(void,glCopyTexSubImage1D,(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
+SDL_PROC_UNUSED(void,glCopyTexSubImage2D,(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
+SDL_PROC_UNUSED(void,glCullFace,(GLenum mode))
+SDL_PROC_UNUSED(void,glDeleteLists,(GLuint list, GLsizei range))
+SDL_PROC_UNUSED(void,glDeleteTextures,(GLsizei n, const GLuint *textures))
+SDL_PROC_UNUSED(void,glDepthFunc,(GLenum func))
+SDL_PROC_UNUSED(void,glDepthMask,(GLboolean flag))
+SDL_PROC_UNUSED(void,glDepthRange,(GLclampd zNear, GLclampd zFar))
+SDL_PROC(void,glDisable,(GLenum cap))
+SDL_PROC(void,glDisableClientState,(GLenum array))
+SDL_PROC_UNUSED(void,glDrawArrays,(GLenum mode, GLint first, GLsizei count))
+SDL_PROC_UNUSED(void,glDrawBuffer,(GLenum mode))
+SDL_PROC(void,glDrawElements,(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices))
+SDL_PROC_UNUSED(void,glDrawPixels,(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels))
+SDL_PROC_UNUSED(void,glEdgeFlag,(GLboolean flag))
+SDL_PROC_UNUSED(void,glEdgeFlagPointer,(GLsizei stride, const GLvoid *pointer))
+SDL_PROC_UNUSED(void,glEdgeFlagv,(const GLboolean *flag))
+SDL_PROC(void,glEnable,(GLenum cap))
+SDL_PROC(void,glEnableClientState,(GLenum array))
+SDL_PROC_UNUSED(void,glEnd,(void))
+SDL_PROC_UNUSED(void,glEndList,(void))
+SDL_PROC_UNUSED(void,glEvalCoord1d,(GLfloat u))
+SDL_PROC_UNUSED(void,glEvalCoord1dv,(const GLfloat *u))
+SDL_PROC_UNUSED(void,glEvalCoord1f,(GLfloat u))
+SDL_PROC_UNUSED(void,glEvalCoord1fv,(const GLfloat *u))
+SDL_PROC_UNUSED(void,glEvalCoord2d,(GLfloat u, GLfloat v))
+SDL_PROC_UNUSED(void,glEvalCoord2dv,(const GLfloat *u))
+SDL_PROC_UNUSED(void,glEvalCoord2f,(GLfloat u, GLfloat v))
+SDL_PROC_UNUSED(void,glEvalCoord2fv,(const GLfloat *u))
+SDL_PROC_UNUSED(void,glEvalMesh1,(GLenum mode, GLint i1, GLint i2))
+SDL_PROC_UNUSED(void,glEvalMesh2,(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2))
+SDL_PROC_UNUSED(void,glEvalPoint1,(GLint i))
+SDL_PROC_UNUSED(void,glEvalPoint2,(GLint i, GLint j))
+SDL_PROC_UNUSED(void,glFeedbackBuffer,(GLsizei size, GLenum type, GLfloat *buffer))
+SDL_PROC_UNUSED(void,glFinish,(void))
+SDL_PROC_UNUSED(void,glFlush,(void))
+SDL_PROC_UNUSED(void,glFogf,(GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glFogfv,(GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glFogi,(GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glFogiv,(GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glFrontFace,(GLenum mode))
+SDL_PROC_UNUSED(void,glFrustum,(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar))
+SDL_PROC_UNUSED(GLuint,glGenLists,(GLsizei range))
+SDL_PROC(void,glGenTextures,(GLsizei n, GLuint *textures))
+SDL_PROC_UNUSED(void,glGetBooleanv,(GLenum pname, GLboolean *params))
+SDL_PROC_UNUSED(void,glGetClipPlane,(GLenum plane, GLfloat *equation))
+SDL_PROC_UNUSED(void,glGetDoublev,(GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(GLenum,glGetError,(void))
+SDL_PROC_UNUSED(void,glGetFloatv,(GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetIntegerv,(GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetLightfv,(GLenum light, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetLightiv,(GLenum light, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetMapdv,(GLenum target, GLenum query, GLfloat *v))
+SDL_PROC_UNUSED(void,glGetMapfv,(GLenum target, GLenum query, GLfloat *v))
+SDL_PROC_UNUSED(void,glGetMapiv,(GLenum target, GLenum query, GLint *v))
+SDL_PROC_UNUSED(void,glGetMaterialfv,(GLenum face, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetMaterialiv,(GLenum face, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetPixelMapfv,(GLenum map, GLfloat *values))
+SDL_PROC_UNUSED(void,glGetPixelMapuiv,(GLenum map, GLuint *values))
+SDL_PROC_UNUSED(void,glGetPixelMapusv,(GLenum map, GLushort *values))
+SDL_PROC_UNUSED(void,glGetPointerv,(GLenum pname, GLvoid* *params))
+SDL_PROC_UNUSED(void,glGetPolygonStipple,(GLubyte *mask))
+SDL_PROC(const GLubyte *,glGetString,(GLenum name))
+SDL_PROC_UNUSED(void,glGetTexEnvfv,(GLenum target, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetTexEnviv,(GLenum target, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetTexGendv,(GLenum coord, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetTexGenfv,(GLenum coord, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetTexGeniv,(GLenum coord, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetTexImage,(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels))
+SDL_PROC_UNUSED(void,glGetTexLevelParameterfv,(GLenum target, GLint level, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetTexLevelParameteriv,(GLenum target, GLint level, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glGetTexParameterfv,(GLenum target, GLenum pname, GLfloat *params))
+SDL_PROC_UNUSED(void,glGetTexParameteriv,(GLenum target, GLenum pname, GLint *params))
+SDL_PROC_UNUSED(void,glHint,(GLenum target, GLenum mode))
+SDL_PROC_UNUSED(void,glIndexMask,(GLuint mask))
+SDL_PROC_UNUSED(void,glIndexPointer,(GLenum type, GLsizei stride, const GLvoid *pointer))
+SDL_PROC_UNUSED(void,glIndexd,(GLfloat c))
+SDL_PROC_UNUSED(void,glIndexdv,(const GLfloat *c))
+SDL_PROC_UNUSED(void,glIndexf,(GLfloat c))
+SDL_PROC_UNUSED(void,glIndexfv,(const GLfloat *c))
+SDL_PROC_UNUSED(void,glIndexi,(GLint c))
+SDL_PROC_UNUSED(void,glIndexiv,(const GLint *c))
+SDL_PROC_UNUSED(void,glIndexs,(GLshort c))
+SDL_PROC_UNUSED(void,glIndexsv,(const GLshort *c))
+SDL_PROC_UNUSED(void,glIndexub,(GLubyte c))
+SDL_PROC_UNUSED(void,glIndexubv,(const GLubyte *c))
+SDL_PROC_UNUSED(void,glInitNames,(void))
+SDL_PROC_UNUSED(void,glInterleavedArrays,(GLenum format, GLsizei stride, const GLvoid *pointer))
+SDL_PROC_UNUSED(GLboolean,glIsEnabled,(GLenum cap))
+SDL_PROC_UNUSED(GLboolean,glIsList,(GLuint list))
+SDL_PROC_UNUSED(GLboolean,glIsTexture,(GLuint texture))
+SDL_PROC_UNUSED(void,glLightModelf,(GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glLightModelfv,(GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glLightModeli,(GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glLightModeliv,(GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glLightf,(GLenum light, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glLightfv,(GLenum light, GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glLighti,(GLenum light, GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glLightiv,(GLenum light, GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glLineStipple,(GLint factor, GLushort pattern))
+SDL_PROC_UNUSED(void,glLineWidth,(GLfloat width))
+SDL_PROC_UNUSED(void,glListBase,(GLuint base))
+SDL_PROC(void,glLoadIdentity,(void))
+SDL_PROC_UNUSED(void,glLoadMatrixd,(const GLfloat *m))
+SDL_PROC_UNUSED(void,glLoadMatrixf,(const GLfloat *m))
+SDL_PROC_UNUSED(void,glLoadName,(GLuint name))
+SDL_PROC_UNUSED(void,glLogicOp,(GLenum opcode))
+SDL_PROC_UNUSED(void,glMap1d,(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points))
+SDL_PROC_UNUSED(void,glMap1f,(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points))
+SDL_PROC_UNUSED(void,glMap2d,(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points))
+SDL_PROC_UNUSED(void,glMap2f,(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points))
+SDL_PROC_UNUSED(void,glMapGrid1d,(GLint un, GLfloat u1, GLfloat u2))
+SDL_PROC_UNUSED(void,glMapGrid1f,(GLint un, GLfloat u1, GLfloat u2))
+SDL_PROC_UNUSED(void,glMapGrid2d,(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2))
+SDL_PROC_UNUSED(void,glMapGrid2f,(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2))
+SDL_PROC_UNUSED(void,glMaterialf,(GLenum face, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glMaterialfv,(GLenum face, GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glMateriali,(GLenum face, GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glMaterialiv,(GLenum face, GLenum pname, const GLint *params))
+SDL_PROC(void,glMatrixMode,(GLenum mode))
+SDL_PROC_UNUSED(void,glMultMatrixd,(const GLfloat *m))
+SDL_PROC_UNUSED(void,glMultMatrixf,(const GLfloat *m))
+SDL_PROC_UNUSED(void,glNewList,(GLuint list, GLenum mode))
+SDL_PROC_UNUSED(void,glNormal3b,(GLbyte nx, GLbyte ny, GLbyte nz))
+SDL_PROC_UNUSED(void,glNormal3bv,(const GLbyte *v))
+SDL_PROC_UNUSED(void,glNormal3d,(GLfloat nx, GLfloat ny, GLfloat nz))
+SDL_PROC_UNUSED(void,glNormal3dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glNormal3f,(GLfloat nx, GLfloat ny, GLfloat nz))
+SDL_PROC_UNUSED(void,glNormal3fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glNormal3i,(GLint nx, GLint ny, GLint nz))
+SDL_PROC_UNUSED(void,glNormal3iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glNormal3s,(GLshort nx, GLshort ny, GLshort nz))
+SDL_PROC_UNUSED(void,glNormal3sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glNormalPointer,(GLenum type, GLsizei stride, const GLvoid *pointer))
+SDL_PROC(void,glOrthof,(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar))
+SDL_PROC_UNUSED(void,glPassThrough,(GLfloat token))
+SDL_PROC_UNUSED(void,glPixelMapfv,(GLenum map, GLsizei mapsize, const GLfloat *values))
+SDL_PROC_UNUSED(void,glPixelMapuiv,(GLenum map, GLsizei mapsize, const GLuint *values))
+SDL_PROC_UNUSED(void,glPixelMapusv,(GLenum map, GLsizei mapsize, const GLushort *values))
+SDL_PROC_UNUSED(void,glPixelStoref,(GLenum pname, GLfloat param))
+SDL_PROC(void,glPixelStorei,(GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glPixelTransferf,(GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glPixelTransferi,(GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glPixelZoom,(GLfloat xfactor, GLfloat yfactor))
+SDL_PROC_UNUSED(void,glPointSize,(GLfloat size))
+SDL_PROC_UNUSED(void,glPolygonMode,(GLenum face, GLenum mode))
+SDL_PROC_UNUSED(void,glPolygonOffset,(GLfloat factor, GLfloat units))
+SDL_PROC_UNUSED(void,glPolygonStipple,(const GLubyte *mask))
+SDL_PROC_UNUSED(void,glPopAttrib,(void))
+SDL_PROC_UNUSED(void,glPopClientAttrib,(void))
+SDL_PROC(void,glPopMatrix,(void))
+SDL_PROC_UNUSED(void,glPopName,(void))
+SDL_PROC_UNUSED(void,glPrioritizeTextures,(GLsizei n, const GLuint *textures, const GLclampf *priorities))
+SDL_PROC_UNUSED(void,glPushAttrib,(GLbitfield mask))
+SDL_PROC_UNUSED(void,glPushClientAttrib,(GLbitfield mask))
+SDL_PROC(void,glPushMatrix,(void))
+SDL_PROC_UNUSED(void,glPushName,(GLuint name))
+SDL_PROC_UNUSED(void,glRasterPos2d,(GLfloat x, GLfloat y))
+SDL_PROC_UNUSED(void,glRasterPos2dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos2f,(GLfloat x, GLfloat y))
+SDL_PROC_UNUSED(void,glRasterPos2fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos2i,(GLint x, GLint y))
+SDL_PROC_UNUSED(void,glRasterPos2iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glRasterPos2s,(GLshort x, GLshort y))
+SDL_PROC_UNUSED(void,glRasterPos2sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glRasterPos3d,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glRasterPos3dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos3f,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glRasterPos3fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos3i,(GLint x, GLint y, GLint z))
+SDL_PROC_UNUSED(void,glRasterPos3iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glRasterPos3s,(GLshort x, GLshort y, GLshort z))
+SDL_PROC_UNUSED(void,glRasterPos3sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glRasterPos4d,(GLfloat x, GLfloat y, GLfloat z, GLfloat w))
+SDL_PROC_UNUSED(void,glRasterPos4dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos4f,(GLfloat x, GLfloat y, GLfloat z, GLfloat w))
+SDL_PROC_UNUSED(void,glRasterPos4fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glRasterPos4i,(GLint x, GLint y, GLint z, GLint w))
+SDL_PROC_UNUSED(void,glRasterPos4iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glRasterPos4s,(GLshort x, GLshort y, GLshort z, GLshort w))
+SDL_PROC_UNUSED(void,glRasterPos4sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glReadBuffer,(GLenum mode))
+SDL_PROC_UNUSED(void,glReadPixels,(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels))
+SDL_PROC_UNUSED(void,glRectd,(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2))
+SDL_PROC_UNUSED(void,glRectdv,(const GLfloat *v1, const GLfloat *v2))
+SDL_PROC_UNUSED(void,glRectf,(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2))
+SDL_PROC_UNUSED(void,glRectfv,(const GLfloat *v1, const GLfloat *v2))
+SDL_PROC_UNUSED(void,glRecti,(GLint x1, GLint y1, GLint x2, GLint y2))
+SDL_PROC_UNUSED(void,glRectiv,(const GLint *v1, const GLint *v2))
+SDL_PROC_UNUSED(void,glRects,(GLshort x1, GLshort y1, GLshort x2, GLshort y2))
+SDL_PROC_UNUSED(void,glRectsv,(const GLshort *v1, const GLshort *v2))
+SDL_PROC_UNUSED(GLint,glRenderMode,(GLenum mode))
+SDL_PROC_UNUSED(void,glRotated,(GLfloat angle, GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glRotatef,(GLfloat angle, GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glScaled,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glScalef,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glScissor,(GLint x, GLint y, GLsizei width, GLsizei height))
+SDL_PROC_UNUSED(void,glSelectBuffer,(GLsizei size, GLuint *buffer))
+SDL_PROC_UNUSED(void,glShadeModel,(GLenum mode))
+SDL_PROC_UNUSED(void,glStencilFunc,(GLenum func, GLint ref, GLuint mask))
+SDL_PROC_UNUSED(void,glStencilMask,(GLuint mask))
+SDL_PROC_UNUSED(void,glStencilOp,(GLenum fail, GLenum zfail, GLenum zpass))
+SDL_PROC_UNUSED(void,glTexCoord1d,(GLfloat s))
+SDL_PROC_UNUSED(void,glTexCoord1dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord1f,(GLfloat s))
+SDL_PROC_UNUSED(void,glTexCoord1fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord1i,(GLint s))
+SDL_PROC_UNUSED(void,glTexCoord1iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glTexCoord1s,(GLshort s))
+SDL_PROC_UNUSED(void,glTexCoord1sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glTexCoord2d,(GLfloat s, GLfloat t))
+SDL_PROC_UNUSED(void,glTexCoord2dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord2f,(GLfloat s, GLfloat t))
+SDL_PROC_UNUSED(void,glTexCoord2fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord2i,(GLint s, GLint t))
+SDL_PROC_UNUSED(void,glTexCoord2iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glTexCoord2s,(GLshort s, GLshort t))
+SDL_PROC_UNUSED(void,glTexCoord2sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glTexCoord3d,(GLfloat s, GLfloat t, GLfloat r))
+SDL_PROC_UNUSED(void,glTexCoord3dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord3f,(GLfloat s, GLfloat t, GLfloat r))
+SDL_PROC_UNUSED(void,glTexCoord3fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord3i,(GLint s, GLint t, GLint r))
+SDL_PROC_UNUSED(void,glTexCoord3iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glTexCoord3s,(GLshort s, GLshort t, GLshort r))
+SDL_PROC_UNUSED(void,glTexCoord3sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glTexCoord4d,(GLfloat s, GLfloat t, GLfloat r, GLfloat q))
+SDL_PROC_UNUSED(void,glTexCoord4dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord4f,(GLfloat s, GLfloat t, GLfloat r, GLfloat q))
+SDL_PROC_UNUSED(void,glTexCoord4fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glTexCoord4i,(GLint s, GLint t, GLint r, GLint q))
+SDL_PROC_UNUSED(void,glTexCoord4iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glTexCoord4s,(GLshort s, GLshort t, GLshort r, GLshort q))
+SDL_PROC_UNUSED(void,glTexCoord4sv,(const GLshort *v))
+SDL_PROC(void,glTexCoordPointer,(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
+SDL_PROC(void,glTexEnvf,(GLenum target, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glTexEnvfv,(GLenum target, GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glTexEnvi,(GLenum target, GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glTexEnviv,(GLenum target, GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glTexGend,(GLenum coord, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glTexGendv,(GLenum coord, GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glTexGenf,(GLenum coord, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glTexGenfv,(GLenum coord, GLenum pname, const GLfloat *params))
+SDL_PROC_UNUSED(void,glTexGeni,(GLenum coord, GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glTexGeniv,(GLenum coord, GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glTexImage1D,(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels))
+SDL_PROC(void,glTexImage2D,(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels))
+SDL_PROC_UNUSED(void,glTexParameterf,(GLenum target, GLenum pname, GLfloat param))
+SDL_PROC_UNUSED(void,glTexParameterfv,(GLenum target, GLenum pname, const GLfloat *params))
+SDL_PROC(void,glTexParameteri,(GLenum target, GLenum pname, GLint param))
+SDL_PROC_UNUSED(void,glTexParameteriv,(GLenum target, GLenum pname, const GLint *params))
+SDL_PROC_UNUSED(void,glTexSubImage1D,(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels))
+SDL_PROC(void,glTexSubImage2D,(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels))
+SDL_PROC_UNUSED(void,glTranslated,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glTranslatef,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glVertex2d,(GLfloat x, GLfloat y))
+SDL_PROC_UNUSED(void,glVertex2dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex2f,(GLfloat x, GLfloat y))
+SDL_PROC_UNUSED(void,glVertex2fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex2i,(GLint x, GLint y))
+SDL_PROC_UNUSED(void,glVertex2iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glVertex2s,(GLshort x, GLshort y))
+SDL_PROC_UNUSED(void,glVertex2sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glVertex3d,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glVertex3dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex3f,(GLfloat x, GLfloat y, GLfloat z))
+SDL_PROC_UNUSED(void,glVertex3fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex3i,(GLint x, GLint y, GLint z))
+SDL_PROC_UNUSED(void,glVertex3iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glVertex3s,(GLshort x, GLshort y, GLshort z))
+SDL_PROC_UNUSED(void,glVertex3sv,(const GLshort *v))
+SDL_PROC_UNUSED(void,glVertex4d,(GLfloat x, GLfloat y, GLfloat z, GLfloat w))
+SDL_PROC_UNUSED(void,glVertex4dv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex4f,(GLfloat x, GLfloat y, GLfloat z, GLfloat w))
+SDL_PROC_UNUSED(void,glVertex4fv,(const GLfloat *v))
+SDL_PROC_UNUSED(void,glVertex4i,(GLint x, GLint y, GLint z, GLint w))
+SDL_PROC_UNUSED(void,glVertex4iv,(const GLint *v))
+SDL_PROC_UNUSED(void,glVertex4s,(GLshort x, GLshort y, GLshort z, GLshort w))
+SDL_PROC_UNUSED(void,glVertex4sv,(const GLshort *v))
+SDL_PROC(void,glVertexPointer,(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
+SDL_PROC(void,glViewport,(GLint x, GLint y, GLsizei width, GLsizei height))
diff -pruN libsdl-1.2/src/video/SDL_sysvideo.h libsdl-1.2-palm/src/video/SDL_sysvideo.h
--- libsdl-1.2/src/video/SDL_sysvideo.h	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/SDL_sysvideo.h	2009-06-25 16:58:09.000000000 -0700
@@ -37,6 +37,10 @@
 #include "SDL_opengl.h"
 #endif /* SDL_VIDEO_OPENGL */
 
+#if SDL_VIDEO_OPENGL_ES
+#include "SDL_opengles.h"
+#endif
+
 /* The SDL video driver */
 typedef struct SDL_VideoDevice SDL_VideoDevice;
 
@@ -182,15 +186,39 @@ struct SDL_VideoDevice {
 	/* Swap the current buffers in double buffer mode. */
 	void (*GL_SwapBuffers)(_THIS);
 
+    /* Sets the dll to use for OpenGL ES and loads it */
+    int (*GLES_LoadLibrary)(_THIS, const char *path);
+
+    /* Retrieves the address of a function in the gl library */
+    void* (*GLES_GetProcAddress)(_THIS, const char *proc);
+
+    /* Get attribute information from the windowing system. */
+    int (*GLES_GetAttribute)(_THIS, SDL_GLattr attrib, int* value);
+
+    /* Make the context associated with this driver current */
+    int (*GLES_MakeCurrent)(_THIS);
+
+    /* Swap the current buffers in double buffer mode. */
+    void (*GLES_SwapBuffers)(_THIS);
+
   	/* OpenGL functions for SDL_OPENGLBLIT */
-#if SDL_VIDEO_OPENGL
 #if !defined(__WIN32__)
 #define WINAPI
 #endif
+
+#if SDL_VIDEO_OPENGL
 #define SDL_PROC(ret,func,params) ret (WINAPI *func) params;
 #include "SDL_glfuncs.h"
 #undef SDL_PROC
+#endif
+
+#if SDL_VIDEO_OPENGL_ES
+#define SDL_PROC(ret,func,params) ret (WINAPI *(GLES_##func)) params;
+#include "SDL_glesfuncs.h"
+#undef SDL_PROC
+#endif
 
+#if SDL_VIDEO_OPENGL | SDL_VIDEO_OPENGL_ES
 	/* Texture id */
 	GLuint texture;
 #endif
@@ -293,6 +321,9 @@ struct SDL_VideoDevice {
 		int multisamplebuffers;
 		int multisamplesamples;
 		int accelerated;
+        int major_version;
+        int minor_version;
+        int retained_backing;
 		int swap_control;
 		int driver_loaded;
 		char driver_path[256];
@@ -303,6 +334,7 @@ struct SDL_VideoDevice {
 	/* Data private to this driver */
 	struct SDL_PrivateVideoData *hidden;
 	struct SDL_PrivateGLData *gl_data;
+    struct SDL_PrivateGLESData *gles_data;
 
 	/* * * */
 	/* The function used to dispose of this structure */
diff -pruN libsdl-1.2/src/video/SDL_video.c libsdl-1.2-palm/src/video/SDL_video.c
--- libsdl-1.2/src/video/SDL_video.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/src/video/SDL_video.c	2009-11-16 15:26:59.000000000 -0800
@@ -31,6 +31,11 @@
 #include "../events/SDL_sysevents.h"
 #include "../events/SDL_events_c.h"
 
+/* PALM */
+#include "../events/webos/SDL_WebOsEvent.h"
+/*#define DEBUG_VIDEO*/
+/* /PALM */
+
 /* Available video drivers */
 static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_QUARTZ
@@ -134,7 +139,7 @@ void SDL_VideoQuit(void);
 void SDL_GL_UpdateRectsLock(SDL_VideoDevice* this, int numrects, SDL_Rect* rects);
 
 static SDL_GrabMode SDL_WM_GrabInputOff(void);
-#if SDL_VIDEO_OPENGL
+#if SDL_VIDEO_OPENGL || SDL_VIDEO_OPENGL_ES
 static int lock_count = 0;
 #endif
 
@@ -149,8 +154,15 @@ int SDL_VideoInit (const char *driver_na
 	int i;
 	SDL_PixelFormat vformat;
 	Uint32 video_flags;
-
+	int showingCursor;
+	
 	/* Toggle the event thread flags, based on OS requirements */
+#ifdef PALM
+	if (SDL_WebOsEventUseThread()) {
+	    flags |= SDL_INIT_EVENTTHREAD;
+	}
+#endif
+
 #if defined(MUST_THREAD_EVENTS)
 	flags |= SDL_INIT_EVENTTHREAD;
 #elif defined(CANT_THREAD_EVENTS)
@@ -224,7 +236,12 @@ int SDL_VideoInit (const char *driver_na
 	video->gl_config.buffer_size = 0;
 	video->gl_config.depth_size = 16;
 	video->gl_config.stencil_size = 0;
+#ifdef PALM
+	/* We default to triple buffering */
+	video->gl_config.double_buffer = 0;
+#else
 	video->gl_config.double_buffer = 1;
+#endif
 	video->gl_config.accum_red_size = 0;
 	video->gl_config.accum_green_size = 0;
 	video->gl_config.accum_blue_size = 0;
@@ -233,8 +250,10 @@ int SDL_VideoInit (const char *driver_na
 	video->gl_config.multisamplebuffers = 0;
 	video->gl_config.multisamplesamples = 0;
 	video->gl_config.accelerated = -1; /* not known, don't set */
+    video->gl_config.major_version = 2;
+    video->gl_config.minor_version = 0;
 	video->gl_config.swap_control = -1; /* not known, don't set */
-	
+
 	/* Initialize the video subsystem */
 	SDL_memset(&vformat, 0, sizeof(vformat));
 	if ( video->VideoInit(video, &vformat) < 0 ) {
@@ -274,6 +293,18 @@ int SDL_VideoInit (const char *driver_na
 	}
 	SDL_CursorInit(flags & SDL_INIT_EVENTTHREAD);
 
+#ifdef PALM
+	// turn off the mouse cursor. The cursor is supposed
+	// to start of "on". But we won't count on that. Hence
+	// the check before toggling.
+	showingCursor = SDL_ShowCursor(-1);
+	if ( showingCursor )
+	{
+		// anything 0 or better toggles it.
+		SDL_ShowCursor(0);
+	}
+#endif
+	
 	/* We're ready to go! */
 	return(0);
 }
@@ -578,6 +609,14 @@ SDL_Surface * SDL_SetVideoMode (int widt
 	int is_opengl;
 	SDL_GrabMode saved_grab;
 
+#ifdef PALM
+    // OpenGL maps to OpenGL-ES
+    if (flags & SDL_OPENGL) {
+        flags &= ~SDL_OPENGL;
+        flags = SDL_OPENGLES;
+    }
+#endif
+
 	/* Start up the video driver, if necessary..
 	   WARNING: This is the only function protected this way!
 	 */
@@ -625,7 +664,7 @@ SDL_Surface * SDL_SetVideoMode (int widt
 		flags |= SDL_HWSURFACE;
 	}
 
-	is_opengl = ( ( flags & SDL_OPENGL ) == SDL_OPENGL );
+	is_opengl = ( ( flags & (SDL_OPENGL | SDL_OPENGLES ) ) );
 	if ( is_opengl ) {
 		/* These flags are for 2D video modes only */
 		flags &= ~(SDL_HWSURFACE|SDL_DOUBLEBUF);
@@ -671,10 +710,10 @@ SDL_Surface * SDL_SetVideoMode (int widt
 #endif
 
 	    /* Sam - If we asked for OpenGL mode, and didn't get it, fail */
-	    if ( is_opengl && !(mode->flags & SDL_OPENGL) ) {
-		mode = NULL;
-		SDL_SetError("OpenGL not available");
-	    }
+        if ( is_opengl && !(mode->flags & ( SDL_OPENGL | SDL_OPENGLES ) ) ) {
+            mode = NULL;
+            SDL_SetError("OpenGL not available");
+        }
 	}
 	/*
 	 * rcg11292000
@@ -770,6 +809,29 @@ SDL_Surface * SDL_SetVideoMode (int widt
 
 #endif /* __SDL_NOGETPROCADDR__ */
 
+#if SDL_VIDEO_OPENGLES
+	/* Load GL symbols (before MakeCurrent, where we need glGetString). */
+	if ( flags & (SDL_OPENGLES | SDL_OPENGLBLIT) ) {
+
+#ifdef __SDL_NOGETPROCADDR__
+    #define SDL_PROC(ret,func,params) video->GLES_##func=func;
+#else
+    #define SDL_PROC(ret,func,params) \
+    do { \
+        video->GLES_##func = SDL_GLES_GetProcAddress(#func); \
+        if ( ! video->GLES_##func ) { \
+            SDL_SetError("Couldn't load GL function %s: %s\n", #func, SDL_GetError()); \
+        return(NULL); \
+        } \
+    } while ( 0 );
+
+#endif /* __SDL_NOGETPROCADDR__ */
+
+#include "SDL_glfuncs.h"
+#undef SDL_PROC	
+	}
+#endif /* SDL_VIDEO_OPENGL */
+
 #include "SDL_glfuncs.h"
 #undef SDL_PROC	
 	}
@@ -783,6 +845,14 @@ SDL_Surface * SDL_SetVideoMode (int widt
 		}
 	}
 
+	/* If we're running OpenGL, make the context current */
+	if ( (video->screen->flags & SDL_OPENGLES) &&
+	      video->GLES_MakeCurrent ) {
+		if ( video->GLES_MakeCurrent(this) < 0 ) {
+			return(NULL);
+		}
+	}
+
 	/* Set up a fake SDL surface for OpenGL "blitting" */
 	if ( (flags & SDL_OPENGLBLIT) == SDL_OPENGLBLIT ) {
 		/* Load GL functions for performing the texture updates */
@@ -872,7 +942,7 @@ SDL_Surface * SDL_SetVideoMode (int widt
 		2.  We need a hardware palette and didn't get one.
 		3.  We need a software surface and got a hardware surface.
 	*/
-	if ( !(SDL_VideoSurface->flags & SDL_OPENGL) &&
+	if ( !(SDL_VideoSurface->flags & (SDL_OPENGL | SDL_OPENGLES)) &&
 	     (
 	     (  !(flags&SDL_ANYFORMAT) &&
 			(SDL_VideoSurface->format->BitsPerPixel != bpp)) ||
@@ -887,6 +957,13 @@ SDL_Surface * SDL_SetVideoMode (int widt
 				(SDL_VideoSurface->flags&SDL_HWSURFACE) &&
 				!(SDL_VideoSurface->flags&SDL_DOUBLEBUF))
 	     ) ) {
+	    /* PALM */
+#ifdef DEBUG_VIDEO	    
+	    fprintf(stderr, "FB video: creating a shadow surface inflags %x outflags %x  bpp %d BitsPerPixel %d\n", 
+		    flags, SDL_VideoSurface->flags, bpp, SDL_VideoSurface->format->BitsPerPixel);
+#endif
+		/* /PALM */
+	    
 		SDL_CreateShadowSurface(bpp);
 		if ( SDL_ShadowSurface == NULL ) {
 			SDL_SetError("Couldn't create shadow surface");
@@ -1018,7 +1095,7 @@ void SDL_UpdateRects (SDL_Surface *scree
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
 
-	if ( (screen->flags & (SDL_OPENGL | SDL_OPENGLBLIT)) == SDL_OPENGL ) {
+	if ( (screen->flags & (SDL_OPENGL | SDL_OPENGLBLIT | SDL_OPENGLES)) ) {
 		SDL_SetError("OpenGL active, use SDL_GL_SwapBuffers()");
 		return;
 	}
@@ -1403,6 +1480,26 @@ int SDL_GL_LoadLibrary(const char *path)
 	return(retval);
 }
 
+/* Load the GLES driver library */
+int SDL_GLES_LoadLibrary(const char *path)
+{
+    SDL_VideoDevice *video = current_video;
+    SDL_VideoDevice *this = current_video;
+    int retval;
+
+    retval = -1;
+    if ( video == NULL ) {
+        SDL_SetError("Video subsystem has not been initialized");
+    } else {
+        if ( video->GLES_LoadLibrary ) {
+            retval = video->GLES_LoadLibrary(this, path);
+        } else {
+            SDL_SetError("No dynamic GLES support in video driver");
+        }
+    }
+    return(retval);
+}
+
 void *SDL_GL_GetProcAddress(const char* proc)
 {
 	SDL_VideoDevice *video = current_video;
@@ -1422,6 +1519,25 @@ void *SDL_GL_GetProcAddress(const char* 
 	return func;
 }
 
+void *SDL_GLES_GetProcAddress(const char* proc)
+{
+    SDL_VideoDevice *video = current_video;
+    SDL_VideoDevice *this = current_video;
+    void *func;
+
+    func = NULL;
+    if ( video->GLES_GetProcAddress ) {
+        if ( video->gl_config.driver_loaded ) {
+            func = video->GLES_GetProcAddress(this, proc);
+        } else {
+            SDL_SetError("No GLES driver has been loaded");
+        }
+    } else {
+        SDL_SetError("No dynamic GLES support in video driver");
+    }
+    return func;
+}
+
 /* Set the specified GL attribute for setting up a GL video mode */
 int SDL_GL_SetAttribute( SDL_GLattr attr, int value )
 {
@@ -1478,6 +1594,15 @@ int SDL_GL_SetAttribute( SDL_GLattr attr
 		case SDL_GL_ACCELERATED_VISUAL:
 			video->gl_config.accelerated = value;
 			break;
+        case SDL_GL_RETAINED_BACKING:
+            video->gl_config.retained_backing = value;
+            break;
+        case SDL_GL_CONTEXT_MAJOR_VERSION:
+            video->gl_config.major_version = value;
+            break;
+        case SDL_GL_CONTEXT_MINOR_VERSION:
+            video->gl_config.minor_version = value;
+            break;
 		case SDL_GL_SWAP_CONTROL:
 			video->gl_config.swap_control = value;
 			break;
@@ -1496,8 +1621,10 @@ int SDL_GL_GetAttribute(SDL_GLattr attr,
 	SDL_VideoDevice* video = current_video;
 	SDL_VideoDevice* this = current_video;
 
-	if ( video->GL_GetAttribute ) {
-		retval = this->GL_GetAttribute(this, attr, value);
+	if ( (this->screen->flags & SDL_OPENGLES) && video->GL_GetAttribute ) {
+		retval = this->GLES_GetAttribute(this, attr, value);
+    } else if ( this->screen->flags & SDL_OPENGL && this->GL_GetAttribute ) {
+        retval = this->GL_GetAttribute(this, attr, value);
 	} else {
 		*value = 0;
 		SDL_SetError("GL_GetAttribute not supported");
@@ -1511,9 +1638,11 @@ void SDL_GL_SwapBuffers(void)
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
 
-	if ( video->screen->flags & SDL_OPENGL ) {
-		video->GL_SwapBuffers(this);
-	} else {
+    if ( video->screen->flags & SDL_OPENGLES ) {
+        video->GLES_SwapBuffers(this);
+    } else if ( video->screen->flags & SDL_OPENGL ) {
+        video->GL_SwapBuffers(this);
+    } else {
 		SDL_SetError("OpenGL video mode has not been set");
 	}
 }
@@ -1603,70 +1732,126 @@ void SDL_GL_UpdateRects(int numrects, SD
 /* Lock == save current state */
 void SDL_GL_Lock()
 {
-#if SDL_VIDEO_OPENGL
+#if SDL_VIDEO_OPENGL | SDL_VIDEO_OPENGL_ES
 	lock_count--;
 	if (lock_count==-1)
 	{
 		SDL_VideoDevice *this = current_video;
 
-		this->glPushAttrib( GL_ALL_ATTRIB_BITS );	/* TODO: narrow range of what is saved */
+#if defined(SDL_VIDEO_OPENGL_ES)
+        if (this->screen->flags & SDL_OPENGLES)
+        {
+            this->GLES_glEnable(GL_TEXTURE_2D);
+            this->GLES_glEnable(GL_BLEND);
+            this->GLES_glDisable(GL_FOG);
+            this->GLES_glDisable(GL_ALPHA_TEST);
+            this->GLES_glDisable(GL_DEPTH_TEST);
+            this->GLES_glDisable(GL_SCISSOR_TEST);
+            this->GLES_glDisable(GL_STENCIL_TEST);
+            this->GLES_glDisable(GL_CULL_FACE);
+
+            this->GLES_glBindTexture( GL_TEXTURE_2D, this->texture );
+            this->GLES_glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
+            this->GLES_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+            this->GLES_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+            this->GLES_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
+            this->GLES_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+
+            this->GLES_glPixelStorei( GL_UNPACK_ALIGNMENT, 4 );
+            this->GLES_glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            (this->GLES_glColor4f)(1.0, 1.0, 1.0, 1.0);               /* Solaris workaround */
+
+            this->GLES_glViewport(0, 0, this->screen->w, this->screen->h);
+            this->GLES_glMatrixMode(GL_PROJECTION);
+            this->GLES_glPushMatrix();
+            this->GLES_glLoadIdentity();
+
+            this->GLES_glOrthof(0.0, this->screen->w, this->screen->h, 0.0, 0.0, 1.0);
+        }
+        else
+#endif /* SDL_VIDEO_OPENGL_ES */
+        {
+#if SDL_VIDEO_OPENGL
+            this->glPushAttrib( GL_ALL_ATTRIB_BITS );	/* TODO: narrow range of what is saved */
 #ifdef GL_CLIENT_PIXEL_STORE_BIT
-		this->glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT );
+            this->glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT );
 #endif
 
-		this->glEnable(GL_TEXTURE_2D);
-		this->glEnable(GL_BLEND);
-		this->glDisable(GL_FOG);
-		this->glDisable(GL_ALPHA_TEST);
-		this->glDisable(GL_DEPTH_TEST);
-		this->glDisable(GL_SCISSOR_TEST);	
-		this->glDisable(GL_STENCIL_TEST);
-		this->glDisable(GL_CULL_FACE);
-
-		this->glBindTexture( GL_TEXTURE_2D, this->texture );
-		this->glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
-		this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-		this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-		this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
-		this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
-
-		this->glPixelStorei( GL_UNPACK_ROW_LENGTH, this->screen->pitch / this->screen->format->BytesPerPixel );
-		this->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-		(this->glColor4f)(1.0, 1.0, 1.0, 1.0);		/* Solaris workaround */
-
-		this->glViewport(0, 0, this->screen->w, this->screen->h);
-		this->glMatrixMode(GL_PROJECTION);
-		this->glPushMatrix();
-		this->glLoadIdentity();
-
-		this->glOrtho(0.0, (GLdouble) this->screen->w, (GLdouble) this->screen->h, 0.0, 0.0, 1.0);
-
-		this->glMatrixMode(GL_MODELVIEW);
-		this->glPushMatrix();
-		this->glLoadIdentity();
+            this->glEnable(GL_TEXTURE_2D);
+            this->glEnable(GL_BLEND);
+            this->glDisable(GL_FOG);
+            this->glDisable(GL_ALPHA_TEST);
+            this->glDisable(GL_DEPTH_TEST);
+            this->glDisable(GL_SCISSOR_TEST);	
+            this->glDisable(GL_STENCIL_TEST);
+            this->glDisable(GL_CULL_FACE);
+
+            this->glBindTexture( GL_TEXTURE_2D, this->texture );
+            this->glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
+            this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+            this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+            this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
+            this->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+
+            this->glPixelStorei( GL_UNPACK_ROW_LENGTH, this->screen->pitch / this->screen->format->BytesPerPixel );
+            this->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            (this->glColor4f)(1.0, 1.0, 1.0, 1.0);		/* Solaris workaround */
+
+            this->glViewport(0, 0, this->screen->w, this->screen->h);
+            this->glMatrixMode(GL_PROJECTION);
+            this->glPushMatrix();
+            this->glLoadIdentity();
+
+            this->glOrtho(0.0, (GLdouble) this->screen->w, (GLdouble) this->screen->h, 0.0, 0.0, 1.0);
+
+            this->glMatrixMode(GL_MODELVIEW);
+            this->glPushMatrix();
+            this->glLoadIdentity();
+#endif
+        }
 	}
 #endif
 }
 
+
 /* Unlock == restore saved state */
 void SDL_GL_Unlock()
 {
-#if SDL_VIDEO_OPENGL
+#if SDL_VIDEO_OPENGL | SDL_VIDEO_OPENGLES
 	lock_count++;
 	if (lock_count==0)
 	{
 		SDL_VideoDevice *this = current_video;
 
-		this->glPopMatrix();
-		this->glMatrixMode(GL_PROJECTION);
-		this->glPopMatrix();
+#if SDL_VIDEO_OPENGLES
+        if (this->screen->flags & SDL_OPENGLES)
+        {
+            this->GLES_glPopMatrix();
+            this->GLES_glMatrixMode(GL_PROJECTION);
+            this->GLES_glPopMatrix();
+
+            this->GLES_glDisable(GL_TEXTURE_2D);
+            this->GLES_glDisable(GL_BLEND);
+            this->GLES_glEnable(GL_DEPTH_TEST);
+            this->GLES_glEnable(GL_CULL_FACE);
+        }
+        else
+#endif /* SDL_VIDEO_OPENGL_ES */
+        {
+#if SDL_VIDEO_OPENGL
+            this->glPopMatrix();
+            this->glMatrixMode(GL_PROJECTION);
+            this->glPopMatrix();
 
-		this->glPopClientAttrib();
-		this->glPopAttrib();
+            this->glPopClientAttrib();
+            this->glPopAttrib();
+#endif
+		}
 	}
 #endif
 }
 
+
 /*
  * Sets/Gets the title and icon text of the display window, if any.
  */
diff -pruN libsdl-1.2/test/c libsdl-1.2-palm/test/c
--- libsdl-1.2/test/c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/c	2009-03-25 17:24:17.000000000 -0700
@@ -0,0 +1,33 @@
+#!/bin/bash
+
+PATH=$PATH:/opt/nova/piranha/
+source c.sh
+
+InternalCFlags="-Iinclude -I$STAGING_INCDIR -I$STAGING_INCDIR/SDL -D_GNU_SOURCE=1 -D_REENTRANT"
+InternalLFlags="-lSDL -Wl,--rpath -Wl,$STAGING_LIBDIR/Castle"
+
+
+
+# Include feature flag definitions
+source c.Feature
+
+ParseArgs $@
+GXX=$(echo -n $GXX | sed 's=g++=gcc=')
+
+# support for GCov builds in OE
+InternalCFlags="$InternalCFlags $GCOV_COPTS";
+InternalLFlags="$InternalLFlags $GCOV_LOPTS";
+
+
+
+
+#Generics
+for i in `ls *.c -S`; do
+    FileList="$i"
+
+    if [ "$DO_CLEAN" = "1" ]; then
+        rm `basename $i .c`
+    else
+        CompileApp `basename $i .c` $Args
+    fi
+done;
diff -pruN libsdl-1.2/test/checkkeys.c libsdl-1.2-palm/test/checkkeys.c
--- libsdl-1.2/test/checkkeys.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/checkkeys.c	2009-03-23 16:54:28.000000000 -0700
@@ -106,8 +106,8 @@ int main(int argc, char *argv[])
 	}
 
 	/* Set 640x480 video mode */
-	if ( SDL_SetVideoMode(640, 480, 0, videoflags) == NULL ) {
-		fprintf(stderr, "Couldn't set 640x480 video mode: %s\n",
+	if ( SDL_SetVideoMode(320, 480, 0, videoflags) == NULL ) {
+		fprintf(stderr, "Couldn't set 320x480 video mode: %s\n",
 							SDL_GetError());
 		quit(2);
 	}
diff -pruN libsdl-1.2/test/configure libsdl-1.2-palm/test/configure
--- libsdl-1.2/test/configure	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/configure	2009-04-02 17:08:38.000000000 -0700
@@ -1562,7 +1562,7 @@ _ACEOF
 # Let the site file select an alternate cache file if it wants to.
 # Prefer explicitly selected file to automatically selected ones.
 if test -n "$CONFIG_SITE"; then
-  set x "$CONFIG_SITE"
+  set x $CONFIG_SITE
 elif test "x$prefix" != xNONE; then
   set x "$prefix/share/config.site" "$prefix/etc/config.site"
 else
diff -pruN libsdl-1.2/test/configure.in libsdl-1.2-palm/test/configure.in
--- libsdl-1.2/test/configure.in	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/configure.in	2009-04-21 11:05:58.000000000 -0700
@@ -49,11 +49,18 @@ case "$host" in
         else
             SYS_GL_LIBS="-lOSMesa"
         fi
-		;;
+	;;
+    arm-*-linux-*)
+	EXE=""
+        MATHLIB="-lm"
+        SYS_GL_LIBS="-ldogless -lGLES_CM"
+        SYS_GLES_LIBS="-lGLES_CM"
+        ;;	
     *)
         EXE=""
         MATHLIB="-lm"
         SYS_GL_LIBS="-lGL"
+        SYS_GLES_LIBS="-lGLES_CM"
         ;;
 esac
 AC_SUBST(EXE)
@@ -101,5 +108,24 @@ else
 fi
 AC_SUBST(GLLIB)
 
+#PALM
+AC_MSG_CHECKING(for OpenGL-ES support)
+have_opengles=no
+AC_TRY_COMPILE([
+ #include <GLES/gl.h>
+],[
+],[
+have_opengles=yes
+])
+AC_MSG_RESULT($have_opengles)
+if test x$have_opengles = xyes; then
+    CFLAGS="$CFLAGS -DHAVE_OPENGL_ES"
+    GLESLIB="$XPATH $SYS_GLES_LIBS"
+else
+    GLESLIB=""
+fi
+AC_SUBST(GLESLIB)
+#/PALM
+
 dnl Finally create all the generated files
 AC_OUTPUT([Makefile])
diff -pruN libsdl-1.2/test/graywin.c libsdl-1.2-palm/test/graywin.c
--- libsdl-1.2/test/graywin.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/graywin.c	2009-03-23 16:54:28.000000000 -0700
@@ -146,7 +146,7 @@ int main(int argc, char *argv[])
 	}
 
 	/* See if we try to get a hardware colormap */
-	width = 640;
+	width = 320;
 	height = 480;
 	bpp = 8;
 	videoflags = SDL_SWSURFACE;
diff -pruN libsdl-1.2/test/Makefile.in libsdl-1.2-palm/test/Makefile.in
--- libsdl-1.2/test/Makefile.in	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/Makefile.in	2009-12-10 22:44:55.000000000 -0800
@@ -7,10 +7,14 @@ EXE	= @EXE@
 CFLAGS  = @CFLAGS@
 LIBS	= @LIBS@
 
-TARGETS = checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
+# PALM - added testmouse. testmixer
+TARGETS = testmixer$(EXE) checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testmouse$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
 
 all: $(TARGETS)
 
+testmixer$(EXE): $(srcdir)/testmixer.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
 checkkeys$(EXE): $(srcdir)/checkkeys.c
 	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
 
@@ -35,6 +39,11 @@ testcdrom$(EXE): $(srcdir)/testcdrom.c
 testcursor$(EXE): $(srcdir)/testcursor.c
 	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
 
+#PALM
+testmouse$(EXE): $(srcdir)/testmouse.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+#/PALM
+
 testdyngl$(EXE): $(srcdir)/testdyngl.c
 	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
 
diff -pruN libsdl-1.2/test/testalpha.c libsdl-1.2-palm/test/testalpha.c
--- libsdl-1.2/test/testalpha.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testalpha.c	2009-03-23 16:54:28.000000000 -0700
@@ -345,7 +345,7 @@ int main(int argc, char *argv[])
 	w = 240;
 	h = 320;
 #else
-	w = 640;
+	w = 320;
 	h = 480;
 #endif
 	info = SDL_GetVideoInfo();
diff -pruN libsdl-1.2/test/testbitmap.c libsdl-1.2-palm/test/testbitmap.c
--- libsdl-1.2/test/testbitmap.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testbitmap.c	2009-03-23 16:54:28.000000000 -0700
@@ -96,8 +96,8 @@ int main(int argc, char *argv[])
 	}
 
 	/* Set 640x480 video mode */
-	if ( (screen=SDL_SetVideoMode(640,480,video_bpp,videoflags)) == NULL ) {
-		fprintf(stderr, "Couldn't set 640x480x%d video mode: %s\n",
+	if ( (screen=SDL_SetVideoMode(320,480,video_bpp,videoflags)) == NULL ) {
+		fprintf(stderr, "Couldn't set 320x480x%d video mode: %s\n",
 						video_bpp, SDL_GetError());
 		quit(2);
 	}
diff -pruN libsdl-1.2/test/testblitspeed.c libsdl-1.2-palm/test/testblitspeed.c
--- libsdl-1.2/test/testblitspeed.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testblitspeed.c	2009-03-23 16:54:28.000000000 -0700
@@ -194,7 +194,7 @@ static int setup_test(int argc, char **a
     Uint32 dstbmask = 0x000000FF;
     Uint32 dstamask = 0x00000000;
     Uint32 dstflags = 0;
-    int dstw = 640;
+    int dstw = 320;
     int dsth = 480;
     Uint32 srcbpp = 32;
     Uint32 srcrmask = 0x00FF0000;
@@ -202,7 +202,7 @@ static int setup_test(int argc, char **a
     Uint32 srcbmask = 0x000000FF;
     Uint32 srcamask = 0x00000000;
     Uint32 srcflags = 0;
-    int srcw = 640;
+    int srcw = 320;
     int srch = 480;
     Uint32 origsrcalphaflags = 0;
     Uint32 origdstalphaflags = 0;
diff -pruN libsdl-1.2/test/testdyngl.c libsdl-1.2-palm/test/testdyngl.c
--- libsdl-1.2/test/testdyngl.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testdyngl.c	2009-03-23 16:54:28.000000000 -0700
@@ -125,7 +125,7 @@ int main(int argc,char *argv[])
 		quit(1);
 	}
 
-	if (SDL_SetVideoMode(640,480,0,SDL_OPENGL)==NULL)
+	if (SDL_SetVideoMode(320,480,0,SDL_OPENGL)==NULL)
 	{
 		printf("Unable to open video mode : %s\n",SDL_GetError());
 		quit(1);
@@ -143,7 +143,7 @@ int main(int argc,char *argv[])
 		pixels[3*i+2]=rand()%250-125;
 	}
 	
-	f.glViewport(0,0,640,480);
+	f.glViewport(0,0,320,480);
 	
 	f.glMatrixMode(GL_PROJECTION);
 	f.glLoadIdentity();
diff -pruN libsdl-1.2/test/testfb.c libsdl-1.2-palm/test/testfb.c
--- libsdl-1.2/test/testfb.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/testfb.c	2009-03-23 16:54:28.000000000 -0700
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include "SDL.h"
+
+
+int main(int ArgC, char *ArgS[])
+{
+    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
+        return 1;
+    }
+
+    SDL_Event    Event;
+    SDL_Surface *Surface = SDL_SetVideoMode(320, 480, 32, SDL_FULLSCREEN | SDL_SWSURFACE);
+
+    if (!Surface) {
+        fprintf(stderr, "Couldn't set video mode: %s\n", SDL_GetError());
+        return 2;
+    }
+
+printf("Starting the loop");
+
+    do {
+        SDL_PollEvent(&Event);
+
+        memset(Surface->pixels, rand() % 255, 320 * 480 * 4);
+
+        switch(Event.type) {
+            case SDL_KEYDOWN:
+                switch (Event.key.keysym.sym) {
+                    case SDLK_ESCAPE:
+                        Event.type = SDL_QUIT;
+                        break;
+
+                }
+            break;
+
+        }
+
+        SDL_Flip(Surface);
+    } while (Event.type != SDL_QUIT);
+
+    return 0;
+}
diff -pruN libsdl-1.2/test/testgamma.c libsdl-1.2-palm/test/testgamma.c
--- libsdl-1.2/test/testgamma.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testgamma.c	2009-03-23 16:54:28.000000000 -0700
@@ -35,7 +35,7 @@ int get_video_args(char *argv[], int *w,
 {
 	int i;
 
-	*w = 640;
+	*w = 320;
 	*h = 480;
 	*bpp = 0;
 	*flags = SDL_SWSURFACE;
diff -pruN libsdl-1.2/test/testgl.c libsdl-1.2-palm/test/testgl.c
--- libsdl-1.2/test/testgl.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testgl.c	2009-03-23 16:54:28.000000000 -0700
@@ -453,7 +453,7 @@ int RunGLTest( int argc, char* argv[],
 {
 	int i;
 	int rgb_size[3];
-	int w = 640;
+	int w = 320;
 	int h = 480;
 	int done = 0;
 	int frames;
diff -pruN libsdl-1.2/test/testjoystick.c libsdl-1.2-palm/test/testjoystick.c
--- libsdl-1.2/test/testjoystick.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testjoystick.c	2009-10-31 13:24:59.000000000 -0700
@@ -7,8 +7,20 @@
 
 #include "SDL.h"
 
-#define SCREEN_WIDTH	640
+// PALM
+//#define SCREEN_WIDTH  640
+#define SCREEN_WIDTH	320
+///PALM
 #define SCREEN_HEIGHT	480
+#define SCREEN_DEPTH    32
+
+#if SCREEN_DEPTH == 32
+#define ERASE_COLOR     0xFF000000
+#define DRAW_COLOR      0xFFFFFFFF
+#else
+#define ERASE_COLOR     0x0000
+#define DRAW_COLOR      0xFFFF
+#endif
 
 void WatchJoystick(SDL_Joystick *joystick)
 {
@@ -20,7 +32,7 @@ void WatchJoystick(SDL_Joystick *joystic
 	SDL_Rect axis_area[2];
 
 	/* Set a video mode to display joystick axis position */
-	screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 16, 0);
+	screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_DEPTH, 0);
 	if ( screen == NULL ) {
 		fprintf(stderr, "Couldn't set video mode: %s\n",SDL_GetError());
 		return;
@@ -38,16 +50,21 @@ void WatchJoystick(SDL_Joystick *joystic
 	memset(axis_area, 0, (sizeof axis_area));
 	draw = 0;
 
+	int Start = SDL_GetTicks();
+	int Events = 0;
+
 	/* Loop, getting joystick events! */
 	done = 0;
 	while ( ! done ) {
 		while ( SDL_PollEvent(&event) ) {
+
 			switch (event.type) {
 			    case SDL_JOYAXISMOTION:
 				printf("Joystick %d axis %d value: %d\n",
 				       event.jaxis.which,
 				       event.jaxis.axis,
 				       event.jaxis.value);
+                Events++;
 				break;
 			    case SDL_JOYHATMOTION:
 				printf("Joystick %d hat %d value:",
@@ -83,9 +100,9 @@ void WatchJoystick(SDL_Joystick *joystic
 				       event.jbutton.button);
 				break;
 			    case SDL_KEYDOWN:
-				if ( event.key.keysym.sym != SDLK_ESCAPE ) {
+					//if ( event.key.keysym.sym != SDLK_ESCAPE ) {
 					break;
-				}
+					//}
 				/* Fall through to signal quit */
 			    case SDL_QUIT:
 				done = 1;
@@ -93,7 +110,15 @@ void WatchJoystick(SDL_Joystick *joystic
 			    default:
 				break;
 			}
+
+			int Time = SDL_GetTicks();
+            if (Time - Start > 1000) {
+                printf( "Joystick event rate: %.2f\n", (float)Events / 3 * 1000 / (Time - Start));
+                Start = Time;
+                Events = 0;
+            }
 		}
+
 		/* Update visual joystick state */
 		for ( i=0; i<SDL_JoystickNumButtons(joystick); ++i ) {
 			SDL_Rect area;
@@ -111,8 +136,10 @@ void WatchJoystick(SDL_Joystick *joystic
 		}
 
 		/* Erase previous axes */
-		SDL_FillRect(screen, &axis_area[draw], 0x0000);
-
+/* PALM */
+		SDL_FillRect(screen, &axis_area[draw], ERASE_COLOR);
+/*/PALM */
+		
 		/* Draw the X/Y axis */
 		draw = !draw;
 		x = (((int)SDL_JoystickGetAxis(joystick, 0))+32768);
@@ -137,8 +164,10 @@ void WatchJoystick(SDL_Joystick *joystic
 		axis_area[draw].y = (Sint16)y;
 		axis_area[draw].w = 16;
 		axis_area[draw].h = 16;
-		SDL_FillRect(screen, &axis_area[draw], 0xFFFF);
 
+/* PALM */
+		SDL_FillRect(screen, &axis_area[draw], DRAW_COLOR);
+/* /PALM */
 		SDL_UpdateRects(screen, 2, axis_area);
 	}
 }
diff -pruN libsdl-1.2/test/testmixer.c libsdl-1.2-palm/test/testmixer.c
--- libsdl-1.2/test/testmixer.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/testmixer.c	2009-12-02 23:32:33.000000000 -0800
@@ -0,0 +1,57 @@
+/*
+ * testmixer.c
+ *
+ *  Created on: Dec 2, 2009
+ *      Author: cstout
+ */
+
+#include "SDL.h"
+
+const SDL_bool DoAlign = SDL_FALSE;
+
+int main()
+{
+    if ( SDL_Init(SDL_INIT_AUDIO) < 0 ) {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
+        return -1;
+    }
+
+    SDL_AudioSpec desired, obtained;
+    memset(&desired, 0, sizeof(desired));
+    desired.callback = 0xdeadbeef;
+    desired.format = AUDIO_S16LSB;
+
+    if (SDL_OpenAudio(&desired, &obtained) < 0) {
+        fprintf(stderr, "SDL_OpenAudio failed\n");
+        return -1;
+    }
+
+    // Size should be bigger than the L2 cache
+    int Size = 256 * 1024 * 4;
+    Sint16* OutBuffer = (Sint16*)malloc(Size + 16);
+    Sint16* InBuffer = (Sint16*)malloc(Size + 16);
+
+    Sint16* OutPtr = DoAlign ? (Sint16*)(((int)OutBuffer + 15) & ~0xF) : OutBuffer;
+    Sint16* InPtr  = DoAlign ? (Sint16*)(((int)OutBuffer + 15) & ~0xF) : InBuffer;
+
+    printf( "OutPtr %p InPtr %p Size %d\n", OutPtr, InPtr, Size);
+
+    Uint32 Start = SDL_GetTicks();
+    Uint32 Time = Start;
+    Uint32 Bytes = 0;
+
+    while (Time - Start < 3000) {
+        SDL_MixAudio((Uint8*)OutPtr, (const Uint8 *)InPtr, Size, 100);
+        Bytes += Size;
+
+        Time = SDL_GetTicks();
+    }
+
+    float Rate = (float)Bytes / (float)(Time - Start);
+
+    printf( "Bytes: %d Time: %d ms Rate: %.2f MB/s\n", Bytes, Time - Start, Rate);
+
+    SDL_Quit();
+
+    return 0;
+}
diff -pruN libsdl-1.2/test/testmouse.c libsdl-1.2-palm/test/testmouse.c
--- libsdl-1.2/test/testmouse.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/testmouse.c	2009-11-09 12:16:03.000000000 -0800
@@ -0,0 +1,79 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL.h"
+
+int OldX[5];
+int OldY[5];
+
+int main(int argc, char *argv[])
+{
+	SDL_Surface *screen;
+	SDL_bool quit = SDL_FALSE, first_time = SDL_TRUE;
+
+	/* Load the SDL library */
+	if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {
+		fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
+		return(1);
+	}
+
+	screen = SDL_SetVideoMode(320,480,32,SDL_ANYFORMAT);
+	if (screen==NULL) {
+		fprintf(stderr, "Couldn't initialize video mode: %s\n",SDL_GetError());
+		return(1);
+	}
+
+	// PALM
+	Uint32 BgColor = 0xff664422;
+	SDL_FillRect(screen, NULL, BgColor);
+	
+#define MARKER_WIDTH        100
+#define MARKER_RECT         { OldX[event.button.which] - MARKER_WIDTH/2, OldY[event.button.which] - MARKER_WIDTH/2, MARKER_WIDTH, MARKER_WIDTH }
+	
+	while (!quit) {
+		SDL_Event	event;
+		while (SDL_PollEvent(&event)) {
+			switch(event.type) {
+				case SDL_MOUSEBUTTONDOWN:
+					printf( "SDL_MOUSEBUTTONDOWN which %d button %d state %d x %d y %d\n",
+					        event.button.which, event.button.button, event.button.state, event.button.x, event.button.y);
+					break;
+				case SDL_MOUSEBUTTONUP:
+				    printf( "SDL_MOUSEBUTTONUP which %d button %d state %d x %d y %d\n",
+				             event.button.which, event.button.button, event.button.state, event.button.x, event.button.y);
+				    // Undraw
+				    {
+				        SDL_Rect Rect = MARKER_RECT;
+				        SDL_FillRect(screen, &Rect, BgColor);                    
+				    }
+                    break;
+				case SDL_MOUSEMOTION:
+				    printf( "SDL_MOUSEMOTION which %d state %d x %d y %d\n",
+				            event.motion.which, event.motion.state, event.motion.x, event.motion.y);
+				    // Undraw
+				    {
+				        SDL_Rect Rect = MARKER_RECT;
+				        SDL_FillRect(screen, &Rect, BgColor);
+				    }				    
+				    OldX[event.button.which] = event.motion.x;
+				    OldY[event.button.which] = event.motion.y;
+				    // Draw
+				    {
+				        SDL_Rect Rect = MARKER_RECT;
+				        // PALM
+				        SDL_FillRect(screen, &Rect, 0xffffffff);
+				    }				    
+				    break;
+				case SDL_QUIT:
+				    printf( "SDL_QUIT received\n");
+					quit = SDL_TRUE;
+					break;
+			}
+		}	
+		SDL_Flip(screen);
+		SDL_Delay(1);
+	}
+
+	SDL_Quit();
+	return(0);
+}
diff -pruN libsdl-1.2/test/testoverlay.c libsdl-1.2-palm/test/testoverlay.c
--- libsdl-1.2/test/testoverlay.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testoverlay.c	2009-03-23 16:54:28.000000000 -0700
@@ -9,7 +9,7 @@
 
 #define NOTICE(X)	printf("%s", X);
 
-#define WINDOW_WIDTH  640
+#define WINDOW_WIDTH  320
 #define WINDOW_HEIGHT 480
 
 #include "SDL.h"
diff -pruN libsdl-1.2/test/testpalette.c libsdl-1.2-palm/test/testpalette.c
--- libsdl-1.2/test/testpalette.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testpalette.c	2009-03-23 16:54:28.000000000 -0700
@@ -18,7 +18,7 @@
 #include "SDL.h"
 
 /* screen size */
-#define SCRW 640
+#define SCRW 320
 #define SCRH 480
 
 #define NBOATS 5
diff -pruN libsdl-1.2/test/testsem.c libsdl-1.2-palm/test/testsem.c
--- libsdl-1.2/test/testsem.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testsem.c	2009-11-12 11:33:06.000000000 -0800
@@ -33,6 +33,12 @@ static void killed(int sig)
 	alive = 0;
 }
 
+/* PALM */
+static void Alarm(int sig)
+{
+}
+/*/PALM */
+
 int main(int argc, char **argv)
 {
 	SDL_Thread *threads[NUM_THREADS];
@@ -55,6 +61,16 @@ int main(int argc, char **argv)
 	init_sem = atoi(argv[1]);
 	sem = SDL_CreateSemaphore(init_sem);
 	
+	/* PALM: timed wait test */
+	if (SDL_FALSE) {
+        signal(SIGALRM, Alarm);
+
+        Uint32 Time = SDL_GetTicks();
+        int Rc = SDL_SemWaitTimeout(sem, 3000);
+        printf( "SDL_SemWaitTimeout returned %d after %d ms\n", Rc, SDL_GetTicks() - Time);
+        return;
+	}
+
 	printf("Running %d threads, semaphore value = %d\n", NUM_THREADS, init_sem);
 	/* Create all the threads */
 	for( i = 0; i < NUM_THREADS; ++i ) {
diff -pruN libsdl-1.2/test/testsprite.c libsdl-1.2-palm/test/testsprite.c
--- libsdl-1.2/test/testsprite.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testsprite.c	2009-03-23 16:54:28.000000000 -0700
@@ -168,7 +168,7 @@ int main(int argc, char *argv[])
 
 	numsprites = NUM_SPRITES;
 	videoflags = SDL_SWSURFACE|SDL_ANYFORMAT;
-	width = 640;
+	width = 320;
 	height = 480;
 	video_bpp = 8;
 	debug_flip = 0;
diff -pruN libsdl-1.2/test/testwin.c libsdl-1.2-palm/test/testwin.c
--- libsdl-1.2/test/testwin.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testwin.c	2009-03-23 16:54:28.000000000 -0700
@@ -255,7 +255,7 @@ int main(int argc, char *argv[])
 	desired_bpp = 8;
 	video_flags = SDL_FULLSCREEN;
 #else
-	w = 640;
+	w = 320;
 	h = 480;
 	desired_bpp = 0;
 	video_flags = 0;
diff -pruN libsdl-1.2/test/testwm.c libsdl-1.2-palm/test/testwm.c
--- libsdl-1.2/test/testwm.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/testwm.c	2009-03-23 16:54:28.000000000 -0700
@@ -276,7 +276,7 @@ int main(int argc, char *argv[])
 	}
 
 	/* Check command line arguments */
-	w = 640;
+	w = 320;
 	h = 480;
 	video_bpp = 8;
 	video_flags = SDL_SWSURFACE;
diff -pruN libsdl-1.2/test/threadwin.c libsdl-1.2-palm/test/threadwin.c
--- libsdl-1.2/test/threadwin.c	2009-02-02 16:24:40.000000000 -0800
+++ libsdl-1.2-palm/test/threadwin.c	2009-03-23 16:54:28.000000000 -0700
@@ -280,9 +280,9 @@ int main(int argc, char *argv[])
 		free(icon_mask);
 
 	/* Initialize the display */
-	screen = SDL_SetVideoMode(640, 480, video_bpp, video_flags);
+	screen = SDL_SetVideoMode(320, 480, video_bpp, video_flags);
 	if (  screen == NULL ) {
-		fprintf(stderr, "Couldn't set 640x480x%d video mode: %s\n",
+		fprintf(stderr, "Couldn't set 320x480x%d video mode: %s\n",
 						video_bpp, SDL_GetError());
 		quit(1);
 	}
diff -pruN libsdl-1.2/test/wbkeys.c libsdl-1.2-palm/test/wbkeys.c
--- libsdl-1.2/test/wbkeys.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/wbkeys.c	2009-11-09 15:52:21.000000000 -0800
@@ -0,0 +1,305 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "SDL.h"
+
+
+#define FAILED_STR  "  FAILED!"
+
+
+/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */
+static void quit(int rc)
+{
+	SDL_Quit();
+	exit(rc);
+}
+
+
+void printTestHeader(int index)
+{
+    printf( "****************************************\n");
+    printf( "*               Test %-10d        *\n", index);
+    printf( "****************************************\n");
+}
+
+
+void displayStats(int tested, int failed)
+{
+    if (tested == 0)
+    {
+        printf("\nNot tested\n\n");
+    }
+    else
+    {
+        float failedPercentage = failed * 100.0 / tested;
+        printf("\nCases:   %3d\n", tested);
+        printf("Correct: %3d (%6.2f%%)\n", (tested - failed), 100.0 - failedPercentage);
+        printf("Failed:  %3d (%6.2f%%)\n\n", failed, failedPercentage);
+    }
+}
+
+
+void testChar(int index, char* charset, SDL_bool isSym)
+{
+	SDL_bool done = SDL_FALSE;
+    int tested = 0;
+    int failed = 0;
+    char* symStr = (isSym ? "Sym+" : "");
+    
+    printTestHeader(index);
+    printf("Test set = %s[%s]\n", symStr, charset);
+    if (isSym  &&  charset[0] == '1')
+    {
+        printf("Sym+2 is excluded since it is the Reboot command\n", symStr, charset);
+    }
+    printf("\nEnter: %s%c\n", symStr, *charset);
+    
+	while (! done)
+    {
+        SDL_Event event;
+    	SDL_bool symOK;
+        
+        symOK = SDL_TRUE;
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+            {
+                int c = *charset;
+                int inputc = event.key.keysym.unicode;
+                if (inputc  &&  isSym)
+                {
+                    // NOTE: Not sure what the <Sym> key does.
+                    //       Probably need to change the following code.
+                    inputc = event.key.keysym.sym;
+	                if (! (SDL_GetModState() & KMOD_RCTRL))
+                    {
+                        symOK = SDL_FALSE;
+                    }
+                }
+                if (inputc)
+                {                
+                    printf("------ %c", inputc);
+                    if (inputc != c  ||  ! symOK)
+                    {
+                        printf(FAILED_STR);
+                        failed++;
+                    }
+                    tested++;
+                    printf("\n");
+                    c = *(++charset);
+                    if (c == '\0')
+                    {
+                        done = SDL_TRUE;
+                    }
+                    else
+                    {
+                        printf("Enter: %s%c\n", symStr, c);
+                    }
+                }
+            }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+
+    displayStats(tested, failed);
+}
+
+
+void testNonChar(int index)
+{
+    char* charset[] = { "space", "backspace", "return", "" };
+	SDL_bool done = SDL_FALSE;
+    int tested = 0;
+    int failed = 0;
+    int i = 0;
+    
+    printTestHeader(index);
+    printf("Test set = [%s, %s, %s]\n\n", charset[0], charset[1], charset[2]);
+    printf("Enter: %s\n", charset[i]);
+    
+	while (! done)
+    {
+        SDL_Event event;
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+            {
+                char* s = charset[i];
+                char* inputs = SDL_GetKeyName(event.key.keysym.sym);
+                if (inputs)
+                {                
+                    printf("------ %s", inputs);
+                    if (strcmp(inputs, s) != 0)
+                    {
+                        printf(FAILED_STR);
+                        failed++;
+                    }
+                    tested++;
+                    printf("\n");
+                    s = charset[++i];
+                    if (*s == '\0')
+                    {
+                        done = SDL_TRUE;
+                    }
+                    else
+                    {
+                        printf("Enter: %s\n", charset[i]);
+                    }
+                }
+            }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+
+    displayStats(tested, failed);
+}
+
+
+void testRepeat(int index, float factor)
+{
+	SDL_bool done = SDL_FALSE;
+    Uint32 time;
+    int count = 0;
+    int delay = (int)(SDL_DEFAULT_REPEAT_DELAY * factor);
+    int interval = (int)(SDL_DEFAULT_REPEAT_INTERVAL * factor);
+    
+    SDL_EnableKeyRepeat(delay, interval);
+
+    printTestHeader(index);
+    printf("Test Key Repeat: ");
+    if (factor == 0.0)
+    {
+        printf("Disabled");
+    }
+    else
+    {
+        printf("Delay = %d, Interval = %d (default", delay, interval);
+        if (factor != 1.0)
+        {
+            printf(" x %.1f", factor);
+        }
+        printf(")");
+    }
+    printf("\n\nPress and hold a letter or number key for a few seconds and release\n");
+
+	while (! done)
+    {
+        SDL_Event event;
+        int expected;
+        
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+                if (count == 0)
+                {
+                    time = SDL_GetTicks();
+                    printf("%3d: Key pressed!\n", 0);
+                    expected = delay;
+                }
+                else
+                {
+                    Uint32 newTime = SDL_GetTicks();
+                    int elapsed = (newTime - time);
+                    printf("%3d: Expected = %4ld  Elapsed = %4ld", count, expected, elapsed);
+                    // An event must not come before the expected time
+                    if (elapsed < expected)
+                    {
+                        printf(FAILED_STR);
+                    }
+                    // An event should come within 150% of the expected time
+                    else if ((float)elapsed > expected * 1.5)
+                    {
+                        printf("  Took Too Long!");
+                    }
+                    printf("\n");
+                    time = newTime;
+                    expected = interval;
+                }
+                count++;
+            break;
+            
+            case SDL_KEYUP:
+                if (count > 0)
+                {
+                    done = SDL_TRUE;
+                }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+    
+    if (delay == 0)
+    {
+        printf("\nKey Repeat is disabled!\n");
+    }
+    
+    printf("\n");
+}
+
+
+int main(int argc, char *argv[])
+{
+	Uint32 videoflags;
+
+    if (SDL_Init(SDL_INIT_VIDEO) < 0)
+    {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
+        return(1);
+    }
+
+    videoflags = SDL_SWSURFACE;
+    if ( SDL_SetVideoMode(320, 480, 0, videoflags) == NULL )
+    {
+        fprintf(stderr, "Couldn't set 320x480 video mode: %s\n", SDL_GetError());
+        quit(2);
+    }
+
+    SDL_EnableUNICODE(1);
+    
+    printf("\n----- START OF KEYBOARD TEST -----\n");
+    printf("Click the screen to skip a test.\n\n");
+
+    testChar(1, "abcdefghijklmnopqrstuvwxyz", SDL_FALSE);
+    testChar(2, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", SDL_FALSE);
+    testChar(3, "1234567890", SDL_FALSE);
+    testChar(4, "/+()%\"=&-$!:'*#?;_,@.", SDL_FALSE);
+    testChar(5, "abcdefghijklmnopqrstuvwxyz", SDL_TRUE);
+    testChar(6, "134567890", SDL_TRUE);
+    testNonChar(7);
+    testRepeat(8, 0.0);
+    testRepeat(9, 1.0);
+    testRepeat(10, 0.5);
+    testRepeat(11, 2.0);
+
+    printf("-----  END OF KEYBOARD TEST -----\n\n");
+    
+	SDL_Quit();
+	return(0);
+}
diff -pruN libsdl-1.2/test/wbmouse.c libsdl-1.2-palm/test/wbmouse.c
--- libsdl-1.2/test/wbmouse.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/wbmouse.c	2009-11-19 19:18:25.000000000 -0800
@@ -0,0 +1,154 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL.h"
+
+#define BKGD_COLOR  0x00000000
+
+SDL_Surface* spot;
+SDL_Surface* screen;
+
+
+/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */
+void terminate(int rc)
+{
+	SDL_Quit();
+	exit(rc);
+}
+
+
+void ClearScreen()
+{
+    SDL_FillRect(screen, NULL, BKGD_COLOR);
+}
+
+
+int LoadBmp(char* file)
+{
+    SDL_Surface* temp;
+
+    spot = SDL_LoadBMP(file);
+    if (spot == NULL)
+    {
+        fprintf(stderr, "Couldn't load %s: %s", file, SDL_GetError());
+        return(-1);
+    }
+
+//	/* Set transparent pixel as the pixel at (0,0) */
+//	if ( spot->format->palette ) {
+//		SDL_SetColorKey(spot, (SDL_SRCCOLORKEY|SDL_RLEACCEL),
+//						*(Uint8 *)spot->pixels);
+//	}
+
+    temp = SDL_DisplayFormat(spot);
+    SDL_FreeSurface(spot);
+    if (temp == NULL)
+    {
+        fprintf(stderr, "Couldn't convert background: %s\n", SDL_GetError());
+        return(-1);
+    }
+    spot = temp;
+    return(0);
+}
+
+
+void DrawBmp(int xCenter, int yCenter)
+{
+	SDL_Rect area;
+
+    area.x = xCenter - (spot->w / 2);
+    area.y = yCenter - (spot->h / 2);
+    area.w = spot->w;
+    area.h = spot->h;
+    
+    SDL_BlitSurface(spot, NULL, screen, &area);
+    if ((screen->flags & SDL_DOUBLEBUF) == SDL_DOUBLEBUF)
+    {
+printf("DOUBLEBUF");
+        SDL_Flip(screen);
+    }
+    else
+    {
+printf("SINGLEBUF");
+//        SDL_UpdateRect(spot, area.x, area.y, area.w, area.h);
+        SDL_UpdateRects(screen, 1, &area);
+    }    
+printf(" ***** Center (%d, %d) -> Rect (%d, %d)  %d, %d\n", xCenter, yCenter, area.x, area.y, area.w, area.h);
+}
+
+
+void printTestHeader(int index)
+{
+    printf( "****************************************\n");
+    printf( "*               Test %-10d        *\n", index);
+    printf( "****************************************\n");
+
+    ClearScreen();
+}
+
+
+void test1(void)
+{
+    SDL_bool quit = SDL_FALSE;
+
+    printTestHeader(1);
+    
+    while (!quit)
+    {
+        SDL_Event	event;
+        while (SDL_PollEvent(&event))
+        {
+            switch(event.type)
+            {
+                case SDL_MOUSEBUTTONDOWN:
+                    printf( "SDL_MOUSEBUTTONDOWN which %d button %d state %d x %d y %d\n",
+                        event.button.which, event.button.button, event.button.state, event.button.x, event.button.y);
+                    DrawBmp(event.button.x, event.button.y);
+                break;
+
+                case SDL_MOUSEBUTTONUP:
+                    printf( "SDL_MOUSEBUTTONUP which %d button %d state %d x %d y %d\n",
+                        event.button.which, event.button.button, event.button.state, event.button.x, event.button.y);
+                break;
+				
+                case SDL_MOUSEMOTION:
+                    printf( "SDL_MOUSEMOTION which %d state %d x %d y %d\n",
+                        event.motion.which, event.motion.state, event.motion.x, event.motion.y);
+                    DrawBmp(event.button.x, event.button.y);
+                break;
+
+                case SDL_KEYDOWN:
+                case SDL_QUIT:
+//                    printf( "SDL_QUIT received\n");
+                    quit = SDL_TRUE;
+                break;
+            }
+        }	
+    }
+}
+
+
+int main(int argc, char *argv[])
+{
+    if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
+    {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n", SDL_GetError());
+        terminate(1);
+	}
+
+    if ((screen = SDL_SetVideoMode(320, 480, 32, SDL_ANYFORMAT)) == NULL)
+    {
+        fprintf(stderr, "Couldn't initialize video mode: %s\n", SDL_GetError());
+        terminate(2);
+    }
+    
+    if (LoadBmp("spot.bmp") < 0)
+    {
+        terminate(3);
+    }
+
+    test1();
+
+    SDL_FreeSurface(spot);
+    terminate(0);
+}
diff -pruN libsdl-1.2/test/whitebox/Makefile.in libsdl-1.2-palm/test/whitebox/Makefile.in
--- libsdl-1.2/test/whitebox/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/whitebox/Makefile.in	2009-11-20 16:04:36.000000000 -0800
@@ -0,0 +1,29 @@
+# Makefile to build the SDL tests
+
+srcdir  = @srcdir@
+
+CC      = @CC@
+EXE	= @EXE@
+CFLAGS  = @CFLAGS@
+LIBS	= @LIBS@
+
+TARGETS = wbkeys$(EXE) wbmouse$(EXE) wbbmp$(EXE)
+ 
+all: $(TARGETS)
+
+wbkeys$(EXE): $(srcdir)/whitebox/wbkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+wbmouse$(EXE): $(srcdir)/whitebox/wbmouse.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+wbbmp$(EXE): $(srcdir)/whitebox/wbbmp.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+clean:
+	rm -f $(TARGETS)
+
+distclean: clean
+	rm -f Makefile
+	rm -f config.status config.cache config.log
+	rm -rf $(srcdir)/autom4te*
diff -pruN libsdl-1.2/test/whitebox/wbkeys.c libsdl-1.2-palm/test/whitebox/wbkeys.c
--- libsdl-1.2/test/whitebox/wbkeys.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/whitebox/wbkeys.c	2009-11-20 16:04:36.000000000 -0800
@@ -0,0 +1,305 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "SDL.h"
+
+
+#define FAILED_STR  "  FAILED!"
+
+
+/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */
+static void quit(int rc)
+{
+	SDL_Quit();
+	exit(rc);
+}
+
+
+void printTestHeader(int index)
+{
+    printf( "****************************************\n");
+    printf( "*               Test %-10d        *\n", index);
+    printf( "****************************************\n");
+}
+
+
+void displayStats(int tested, int failed)
+{
+    if (tested == 0)
+    {
+        printf("\nNot tested\n\n");
+    }
+    else
+    {
+        float failedPercentage = failed * 100.0 / tested;
+        printf("\nCases:   %3d\n", tested);
+        printf("Correct: %3d (%6.2f%%)\n", (tested - failed), 100.0 - failedPercentage);
+        printf("Failed:  %3d (%6.2f%%)\n\n", failed, failedPercentage);
+    }
+}
+
+
+void testChar(int index, char* charset, SDL_bool isSym)
+{
+	SDL_bool done = SDL_FALSE;
+    int tested = 0;
+    int failed = 0;
+    char* symStr = (isSym ? "Sym+" : "");
+    
+    printTestHeader(index);
+    printf("Test set = %s[%s]\n", symStr, charset);
+    if (isSym  &&  charset[0] == '1')
+    {
+        printf("Sym+2 is excluded since it is the Reboot command\n", symStr, charset);
+    }
+    printf("\nEnter: %s%c\n", symStr, *charset);
+    
+	while (! done)
+    {
+        SDL_Event event;
+    	SDL_bool symOK;
+        
+        symOK = SDL_TRUE;
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+            {
+                int c = *charset;
+                int inputc = event.key.keysym.unicode;
+                if (inputc  &&  isSym)
+                {
+                    // NOTE: Not sure what the <Sym> key does.
+                    //       Probably need to change the following code.
+                    inputc = event.key.keysym.sym;
+	                if (! (SDL_GetModState() & KMOD_RCTRL))
+                    {
+                        symOK = SDL_FALSE;
+                    }
+                }
+                if (inputc)
+                {                
+                    printf("------ %c", inputc);
+                    if (inputc != c  ||  ! symOK)
+                    {
+                        printf(FAILED_STR);
+                        failed++;
+                    }
+                    tested++;
+                    printf("\n");
+                    c = *(++charset);
+                    if (c == '\0')
+                    {
+                        done = SDL_TRUE;
+                    }
+                    else
+                    {
+                        printf("Enter: %s%c\n", symStr, c);
+                    }
+                }
+            }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+
+    displayStats(tested, failed);
+}
+
+
+void testNonChar(int index)
+{
+    char* charset[] = { "space", "backspace", "return", "" };
+	SDL_bool done = SDL_FALSE;
+    int tested = 0;
+    int failed = 0;
+    int i = 0;
+    
+    printTestHeader(index);
+    printf("Test set = [%s, %s, %s]\n\n", charset[0], charset[1], charset[2]);
+    printf("Enter: %s\n", charset[i]);
+    
+	while (! done)
+    {
+        SDL_Event event;
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+            {
+                char* s = charset[i];
+                char* inputs = SDL_GetKeyName(event.key.keysym.sym);
+                if (inputs)
+                {                
+                    printf("------ %s", inputs);
+                    if (strcmp(inputs, s) != 0)
+                    {
+                        printf(FAILED_STR);
+                        failed++;
+                    }
+                    tested++;
+                    printf("\n");
+                    s = charset[++i];
+                    if (*s == '\0')
+                    {
+                        done = SDL_TRUE;
+                    }
+                    else
+                    {
+                        printf("Enter: %s\n", charset[i]);
+                    }
+                }
+            }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+
+    displayStats(tested, failed);
+}
+
+
+void testRepeat(int index, float factor)
+{
+	SDL_bool done = SDL_FALSE;
+    Uint32 time;
+    int count = 0;
+    int delay = (int)(SDL_DEFAULT_REPEAT_DELAY * factor);
+    int interval = (int)(SDL_DEFAULT_REPEAT_INTERVAL * factor);
+    
+    SDL_EnableKeyRepeat(delay, interval);
+
+    printTestHeader(index);
+    printf("Test Key Repeat: ");
+    if (factor == 0.0)
+    {
+        printf("Disabled");
+    }
+    else
+    {
+        printf("Delay = %d, Interval = %d (default", delay, interval);
+        if (factor != 1.0)
+        {
+            printf(" x %.1f", factor);
+        }
+        printf(")");
+    }
+    printf("\n\nPress and hold a letter or number key for a few seconds and release\n");
+
+	while (! done)
+    {
+        SDL_Event event;
+        int expected;
+        
+        SDL_WaitEvent(&event);
+        switch (event.type)
+        {
+            case SDL_KEYDOWN:
+                if (count == 0)
+                {
+                    time = SDL_GetTicks();
+                    printf("%3d: Key pressed!\n", 0);
+                    expected = delay;
+                }
+                else
+                {
+                    Uint32 newTime = SDL_GetTicks();
+                    int elapsed = (newTime - time);
+                    printf("%3d: Expected = %4ld  Elapsed = %4ld", count, expected, elapsed);
+                    // An event must not come before the expected time
+                    if (elapsed < expected)
+                    {
+                        printf(FAILED_STR);
+                    }
+                    // An event should come within 150% of the expected time
+                    else if ((float)elapsed > expected * 1.5)
+                    {
+                        printf("  Took Too Long!");
+                    }
+                    printf("\n");
+                    time = newTime;
+                    expected = interval;
+                }
+                count++;
+            break;
+            
+            case SDL_KEYUP:
+                if (count > 0)
+                {
+                    done = SDL_TRUE;
+                }
+            break;
+            
+			case SDL_MOUSEBUTTONDOWN:
+            case SDL_QUIT:
+                done = SDL_TRUE;
+			break;
+
+            default:
+            break;
+		} // switch //
+	} // while //
+    
+    if (delay == 0)
+    {
+        printf("\nKey Repeat is disabled!\n");
+    }
+    
+    printf("\n");
+}
+
+
+int main(int argc, char *argv[])
+{
+	Uint32 videoflags;
+
+    if (SDL_Init(SDL_INIT_VIDEO) < 0)
+    {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
+        return(1);
+    }
+
+    videoflags = SDL_SWSURFACE;
+    if ( SDL_SetVideoMode(320, 480, 0, videoflags) == NULL )
+    {
+        fprintf(stderr, "Couldn't set 320x480 video mode: %s\n", SDL_GetError());
+        quit(2);
+    }
+
+    SDL_EnableUNICODE(1);
+    
+    printf("\n----- START OF KEYBOARD TEST -----\n");
+    printf("Click the screen to skip a test.\n\n");
+
+    testChar(1, "abcdefghijklmnopqrstuvwxyz", SDL_FALSE);
+    testChar(2, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", SDL_FALSE);
+    testChar(3, "1234567890", SDL_FALSE);
+    testChar(4, "/+()%\"=&-$!:'*#?;_,@.", SDL_FALSE);
+    testChar(5, "abcdefghijklmnopqrstuvwxyz", SDL_TRUE);
+    testChar(6, "134567890", SDL_TRUE);
+    testNonChar(7);
+    testRepeat(8, 0.0);
+    testRepeat(9, 1.0);
+    testRepeat(10, 0.5);
+    testRepeat(11, 2.0);
+
+    printf("-----  END OF KEYBOARD TEST -----\n\n");
+    
+	SDL_Quit();
+	return(0);
+}
diff -pruN libsdl-1.2/test/whitebox/wbmouse.c libsdl-1.2-palm/test/whitebox/wbmouse.c
--- libsdl-1.2/test/whitebox/wbmouse.c	1969-12-31 16:00:00.000000000 -0800
+++ libsdl-1.2-palm/test/whitebox/wbmouse.c	2009-11-30 20:00:40.000000000 -0800
@@ -0,0 +1,235 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "SDL.h"
+
+#define BKGD_COLOR              0x00000000
+
+#define RES_X                   320
+#define RES_Y                   480
+
+#define CENTER_X                (RES_X / 2)
+#define CENTER_Y                (RES_Y / 2)
+
+#define MAX_FINGERS             5
+
+typedef struct
+{
+    Sint16      x, y;
+    SDL_bool    tapped;
+} Point;
+
+
+static SDL_Surface* screen;
+static Uint32 yellow;
+static Uint32 green;
+static Uint32 red;
+
+
+/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */
+void terminate(int rc)
+{
+	SDL_Quit();
+	exit(rc);
+}
+
+
+void ClearScreen()
+{
+    SDL_FillRect(screen, NULL, BKGD_COLOR);
+}
+
+
+void GetRect(SDL_Rect* rc, int x, int y, int size)
+{
+    const HALF_SIZE = size / 2;
+    rc->x = x - HALF_SIZE;
+    rc->y = y - HALF_SIZE;
+    rc->w = size;
+    rc->h = size;
+}
+
+
+Uint32 GetColor(Uint8 r, Uint8 g, Uint8 b)
+{
+    return SDL_MapRGB(screen->format, r, g, b);
+}
+
+
+SDL_bool IsInRange(int value, int initial, int range)
+{
+    return (initial <= value  &&  value <= initial + range);
+}
+
+
+SDL_bool IsInRect(int x, int y, SDL_Rect* rc)
+{
+    return IsInRange(x, rc->x, rc->w)  &&  IsInRange(y, rc->y, rc->h);
+}
+
+
+void DrawRect(SDL_Rect* rc, Uint32 color)
+{
+    SDL_FillRect(screen, rc, color);
+    SDL_UpdateRect(screen, 0, 0, 0, 0);
+}
+
+
+int Square(int n)
+{
+    return n*n;
+}
+
+
+int FindDistance(Point* pt1, Point* pt2)
+{
+    double d = Square(pt2->x - pt1->x) + Square(pt2->y - pt1->y);
+    return (int)sqrt(d);
+}
+
+
+void printTestHeader(int index)
+{
+    printf( "\n****************************************\n");
+    printf( "*               Test %-10d        *\n", index);
+    printf( "****************************************\n");
+
+    ClearScreen();
+}
+
+
+void printResult(Point* pts, int index)
+{
+#define INIT_MIN    9999
+    int i;
+    int min = INIT_MIN;
+    Point* pt1 = &pts[ index ];
+
+    for (i = 0; i < MAX_FINGERS; i++)
+    {
+        if (i == index)
+        {
+            continue;
+        }
+        Point*  pt2 = &pts[ i ];
+        if (pt2->tapped)
+        {
+            int dist = FindDistance(pt1, pt2);
+            printf("--- Distance to Finger %d is %3d pixels\n", i, dist);
+            if (min > dist)
+            {
+                min = dist;
+            }
+        }
+    }
+    if (min < INIT_MIN)
+    {
+        printf("+++ The closes distance is %d\n", min);
+    }
+#undef INIT_MIN
+}
+ 
+
+void singleTap(int testIndex, int count)
+{
+    SDL_bool    quit = SDL_FALSE;
+    Point       pts[ MAX_FINGERS ];
+	SDL_Rect    rc;
+    int         numTapped = 0;
+    const int   size = 300;
+    
+    memset(pts, 0, sizeof(pts));    
+    printTestHeader(testIndex);
+//    printf( "Tap %d finger%s on the yellow square\n\n", count, (count > 1 ? "s" : ""));
+//    GetRect(&rc, CENTER_X, CENTER_Y, size);
+//    DrawRect(&rc, yellow);
+    printf( "Tap %d finger%s on the screen\n\n", count, (count > 1 ? "s" : ""));
+    DrawRect(NULL, yellow);
+    
+    while (!quit)
+    {
+        SDL_bool    firstTime = SDL_TRUE;
+        SDL_Event	event;
+        
+        while (SDL_PollEvent(&event))
+        {
+            switch(event.type)
+            {
+                case SDL_MOUSEBUTTONDOWN:
+                    printf( "BUTTONDOWN: Finger %d at (%d, %d)\n", event.button.which, event.button.x, event.button.y);
+                    if (event.button.which < MAX_FINGERS)
+                    {
+                        Point* pt = &pts[ event.button.which ];
+                        pt->x = event.button.x;
+                        pt->y = event.button.y;
+                        if (! pt->tapped)
+                        {
+                            pt->tapped = SDL_TRUE;
+                            numTapped++;
+                        }
+
+                        if (numTapped >= count)
+                        {
+                            int i;
+                            Point* pt1 = pts;
+
+                            for (i = 0; i < MAX_FINGERS; i++, pt1++)
+                            {
+                                if (! pt1->tapped)
+                                {
+                                    continue;
+                                }
+//                                char* s = (IsInRect(pt1->x, pt1->y, &rc) ? "Hit" : "Missed");
+//                                printf("=== Finger %d: (%3d, %3d) -- %s!\n", i, pt1->x, pt1->y, s);
+                                printf("=== Finger %d: (%3d, %3d)\n", i, pt1->x, pt1->y);
+                                printResult(pts, i);
+                            } // for i //
+                            quit = SDL_TRUE;
+                        }
+                    }
+                    else
+                    {
+                        // This should not happen...
+                        printf("***** More than %d fingers!\n", MAX_FINGERS);
+                    }
+                break;
+                
+                case SDL_KEYDOWN:
+                case SDL_QUIT:
+                    quit = SDL_TRUE;
+                break;
+            }
+        }	
+    }
+}
+
+
+int main(int argc, char *argv[])
+{
+    if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
+    {
+        fprintf(stderr, "Couldn't initialize SDL: %s\n", SDL_GetError());
+        terminate(1);
+	}
+
+    if ((screen = SDL_SetVideoMode(RES_X, RES_Y, 32, SDL_ANYFORMAT)) == NULL)
+    {
+        fprintf(stderr, "Couldn't initialize video mode: %s\n", SDL_GetError());
+        terminate(2);
+    }
+    
+    yellow = GetColor(255, 255, 0);
+    green = GetColor(0, 255, 0);
+    red = GetColor(255, 0, 0);
+    
+    printf( "\n\n");
+    singleTap(1, 1);
+    singleTap(2, 2);
+    singleTap(3, 3);
+    singleTap(4, 4);
+    singleTap(5, 5);
+    printf( "\n\n");
+
+    terminate(0);
+}
Binary files libsdl-1.2/VisualC.zip and libsdl-1.2-palm/VisualC.zip differ
