diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/boot/compressed/head-xscale.S linux-ixp425/arch/arm/boot/compressed/head-xscale.S
--- linux-2.6.18/arch/arm/boot/compressed/head-xscale.S	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/boot/compressed/head-xscale.S	2006-09-22 06:30:53.000000000 +0930
@@ -53,3 +53,8 @@
 		str	r1, [r0, #0x18]
 #endif
 
+#ifdef CONFIG_ARCH_FSG3
+		mov r7, #MACH_TYPE_FREECOM_FSG3 & 0xff
+		orr r7, r7, #MACH_TYPE_FREECOM_FSG3 & 0xff00
+#endif
+
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/boot/compressed/little-endian.S linux-ixp425/arch/arm/boot/compressed/little-endian.S
--- linux-2.6.18/arch/arm/boot/compressed/little-endian.S	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/arch/arm/boot/compressed/little-endian.S	2006-09-22 11:33:17.000000000 +0930
@@ -0,0 +1,13 @@
+/*
+ *  linux/arch/arm/boot/compressed/little-endian.S
+ *
+ *  Switch CPU into little endian mode.
+ *  Author: Nicolas Pitre
+*/
+
+	.section ".start", #alloc, #execinstr
+
+	mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+	bic	r0, r0, #(1 << 7)	@ enable little endian mode
+	mcr	p15, 0, r0, c1, c0, 0	@ write control reg
+
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/boot/compressed/Makefile linux-ixp425/arch/arm/boot/compressed/Makefile
--- linux-2.6.18/arch/arm/boot/compressed/Makefile	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/boot/compressed/Makefile	2006-09-22 11:32:16.000000000 +0930
@@ -52,6 +52,8 @@
 
 ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
 OBJS		+= big-endian.o
+else
+OBJS		+= little-endian.o
 endif
 
 #
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/configs/fsg3_defconfig linux-ixp425/arch/arm/configs/fsg3_defconfig
--- linux-2.6.18/arch/arm/configs/fsg3_defconfig	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/arch/arm/configs/fsg3_defconfig	2006-09-22 06:30:53.000000000 +0930
@@ -0,0 +1,1297 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17-rc1-git4
+# Sat Apr 15 11:56:06 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_VECTORS_BASE=0xffff0000
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_UID16=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+CONFIG_ARCH_IXP4XX=y
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_AT91RM9200 is not set
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+
+#
+# Intel IXP4xx Implementation Options
+#
+
+#
+# IXP4xx Platforms
+#
+# CONFIG_MACH_NSLU2 is not set
+# CONFIG_ARCH_AVILA is not set
+# CONFIG_ARCH_ADI_COYOTE is not set
+# CONFIG_ARCH_IXDP425 is not set
+# CONFIG_MACH_IXDPG425 is not set
+# CONFIG_MACH_IXDP465 is not set
+# CONFIG_ARCH_PRPMC1100 is not set
+# CONFIG_MACH_NAS100D is not set
+CONFIG_ARCH_FSG3=y
+# CONFIG_MACH_GTWX5715 is not set
+
+#
+# IXP4xx Options
+#
+# CONFIG_IXP4XX_INDIRECT_PCI is not set
+
+#
+# IXP4xx specials
+#
+CONFIG_IXP400_CSR=y
+CONFIG_IXP400_ETH=y
+CONFIG_IXP400_ETH_ALL=y
+# CONFIG_IXP400_ETH_NPEB_ONLY is not set
+# CONFIG_IXP400_ETH_NPEC_ONLY is not set
+# CONFIG_IXP400_ETH_SKB_RECYCLE is not set
+# CONFIG_IXP400_ETH_QDISC_ENABLED is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_XSCALE_PMU=y
+CONFIG_DMABOUNCE=y
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+# CONFIG_PCI_DEBUG is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/nfs ip=bootp mem=64M@0x00000000"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+# CONFIG_APM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_IXP4XX=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+CONFIG_SCSI_SATA=y
+# CONFIG_SCSI_SATA_AHCI is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_MV is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_PDC_ADMA is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIL24 is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+CONFIG_SCSI_SATA_VIA=y
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MACLIST=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=1024
+CONFIG_INPUT_TSDEV_SCREEN_Y=768
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_IOP3XX is not set
+CONFIG_I2C_ISA=y
+CONFIG_I2C_IXP4XX=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=y
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT8231 is not set
+CONFIG_SENSORS_W83781D=y
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# LED devices
+#
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_IXP4XX=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ANYDATA is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=y
+# CONFIG_REISERFS_CHECK is not set
+CONFIG_REISERFS_PROC_INFO=y
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_STATS2 is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_UNWIND_INFO is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/kernel/process.c linux-ixp425/arch/arm/kernel/process.c
--- linux-2.6.18/arch/arm/kernel/process.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/kernel/process.c	2006-10-25 19:52:45.000000000 +0930
@@ -173,8 +173,16 @@
 
 __setup("reboot=", reboot_setup);
 
+
+// by Freecom Technologies GmbH, Berlin
+extern void ixp4xxgpioled_all_off(void);
+
 void machine_halt(void)
 {
+	leds_event(led_halted);
+	/* actually halted */
+
+	ixp4xxgpioled_all_off();   // LEDS and EL ring off
 }
 
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/kernel/setup.c linux-ixp425/arch/arm/kernel/setup.c
--- linux-2.6.18/arch/arm/kernel/setup.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/kernel/setup.c	2006-10-04 22:55:45.000000000 +0930
@@ -698,7 +698,37 @@
 
 static int __init parse_tag_cmdline(const struct tag *tag)
 {
-	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
+	const char *cmdline = tag->u.cmdline.cmdline;
+	u32 size = tag->hdr.size;
+
+	/* Swap command line because redboot is big endian.
+	   By Freecom Technologies GmbH, Berlin */
+	if (--size > 0) {
+		char *p;
+		const u32 *from = (const u32*)cmdline;
+		u32 *to = (u32*)default_command_line;
+
+		if (size > COMMAND_LINE_SIZE/4)
+			size = COMMAND_LINE_SIZE/4;
+
+		while (size-- > 0)
+#ifdef CONFIG_CPU_BIG_ENDIAN
+			to[size] = from[size];
+#else
+			to[size] = swab32(from[size]);
+#endif
+
+		default_command_line[COMMAND_LINE_SIZE-1] = 0;
+
+		/* Boot always from sda.
+		   By Freecom Technologies GmbH, Berlin */
+		p = strstr(default_command_line, "root=/dev/");
+		if(p)  *(p+10) = 's';
+
+		return 0;
+	}
+
+	strlcpy(default_command_line, cmdline, COMMAND_LINE_SIZE);
 	return 0;
 }
 
@@ -877,7 +907,7 @@
 {
 	int i;
 
-	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
+	seq_printf(m, "Processor\t\t: %s rev %d (%s)\n",
 		   cpu_name, (int)processor_id & 15, elf_platform);
 
 #if defined(CONFIG_SMP)
@@ -887,26 +917,26 @@
 		 * online processors, looking for lines beginning with
 		 * "processor".  Give glibc what it expects.
 		 */
-		seq_printf(m, "processor\t: %d\n", i);
-		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n\n",
+		seq_printf(m, "processor\t\t: %d\n", i);
+		seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n\n",
 			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
 			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
 	}
 #else /* CONFIG_SMP */
-	seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 		   loops_per_jiffy / (500000/HZ),
 		   (loops_per_jiffy / (5000/HZ)) % 100);
 #endif
 
 	/* dump out the processor features */
-	seq_puts(m, "Features\t: ");
+	seq_puts(m, "Features\t\t: ");
 
 	for (i = 0; hwcap_str[i]; i++)
 		if (elf_hwcap & (1 << i))
 			seq_printf(m, "%s ", hwcap_str[i]);
 
 	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", processor_id >> 24);
-	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
+	seq_printf(m, "CPU architecture\t: %s\n", proc_arch[cpu_architecture()]);
 
 	if ((processor_id & 0x0008f000) == 0x00000000) {
 		/* pre-ARM7 */
@@ -921,7 +951,7 @@
 			seq_printf(m, "CPU variant\t: 0x%x\n",
 				   (processor_id >> 20) & 15);
 		}
-		seq_printf(m, "CPU part\t: 0x%03x\n",
+		seq_printf(m, "CPU part\t\t: 0x%03x\n",
 			   (processor_id >> 4) & 0xfff);
 	}
 	seq_printf(m, "CPU revision\t: %d\n", processor_id & 15);
@@ -949,8 +979,8 @@
 
 	seq_puts(m, "\n");
 
-	seq_printf(m, "Hardware\t: %s\n", machine_name);
-	seq_printf(m, "Revision\t: %04x\n", system_rev);
+	seq_printf(m, "Hardware\t\t: %s\n", machine_name);
+	seq_printf(m, "Revision\t\t: %04x\n", system_rev);
 	seq_printf(m, "Serial\t\t: %08x%08x\n",
 		   system_serial_high, system_serial_low);
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/common-pci.c linux-ixp425/arch/arm/mach-ixp4xx/common-pci.c
--- linux-2.6.18/arch/arm/mach-ixp4xx/common-pci.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/common-pci.c	2006-11-08 21:52:37.000000000 +1030
@@ -532,6 +532,7 @@
 	return -EIO;
 }
 
+EXPORT_SYMBOL(pci_set_dma_mask);
 EXPORT_SYMBOL(ixp4xx_pci_read);
 EXPORT_SYMBOL(ixp4xx_pci_write);
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-pci.c linux-ixp425/arch/arm/mach-ixp4xx/fsg3-pci.c
--- linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-pci.c	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/fsg3-pci.c	2006-09-22 06:30:53.000000000 +0930
@@ -0,0 +1,77 @@
+/*
+ * arch/arch/mach-ixp4xx/fhd3lan-pci.c
+ *
+ * PCI setup routines for Freecom-Storage-Gateway FSG3 Platform
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2006 Freecom Technologies GmbH.
+ *
+ * Maintainer: Freecom Technologies <support@freecom.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/pci.h>
+
+extern void ixp4xx_pci_preinit(void);
+extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
+extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
+
+void __init fsg3_pci_preinit(void)
+{
+        set_irq_type(FSG3_PCI_INTA_IRQ, IRQT_LOW);
+        set_irq_type(FSG3_PCI_INTB_IRQ, IRQT_LOW);
+        set_irq_type(FSG3_PCI_INTC_IRQ, IRQT_LOW);
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init fsg3_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+        static int pci_irq_table[FSG3_PCI_IRQ_LINES] = {
+                FSG3_PCI_INTC_IRQ,
+                FSG3_PCI_INTB_IRQ,
+                FSG3_PCI_INTA_IRQ,
+        };
+
+        int irq = -1;
+	slot = slot-11;
+
+        if (slot >= 1 && slot <= FSG3_PCI_MAX_DEV &&
+                pin >= 1 && pin <= FSG3_PCI_IRQ_LINES) {
+                irq = pci_irq_table[(slot-1)];
+        }
+        printk("%s: Mapped slot %d pin %d to IRQ %d\n", __FUNCTION__,slot, pin, irq);
+
+        return irq;
+}
+
+struct hw_pci fsg3_pci __initdata = {
+	.nr_controllers = 1,
+	.preinit =        fsg3_pci_preinit,
+	.swizzle =        pci_std_swizzle,
+	.setup =          ixp4xx_setup,
+	.scan =           ixp4xx_scan_bus,
+	.map_irq =        fsg3_map_irq,
+};
+
+int __init fsg3_pci_init(void)
+{
+	if (machine_is_freecom_fsg3())
+		pci_common_init(&fsg3_pci);
+	return 0;
+}
+
+subsys_initcall(fsg3_pci_init);
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-power.c linux-ixp425/arch/arm/mach-ixp4xx/fsg3-power.c
--- linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-power.c	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/fsg3-power.c	2006-09-22 06:30:53.000000000 +0930
@@ -0,0 +1,92 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-power.c
+ *
+ * NSLU2 Power/Reset driver
+ *
+ * Copyright (C) 2005 Tower Technologies
+ *
+ * based on nslu2-io.c
+ *  Copyright (C) 2004 Karen Spearel
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-types.h>
+
+extern void ctrl_alt_del(void);
+
+static irqreturn_t nslu2_power_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* Signal init to do the ctrlaltdel action, this will bypass init if
+	 * it hasn't started and do a kernel_restart.
+	 */
+	ctrl_alt_del();
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t nslu2_reset_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* This is the paper-clip reset, it shuts the machine down directly.
+	 */
+	machine_power_off();
+
+	return IRQ_HANDLED;
+}
+
+static int __init nslu2_power_init(void)
+{
+	if (!(machine_is_nslu2()))
+		return 0;
+
+	*IXP4XX_GPIO_GPISR = 0x20400000;	/* read the 2 irqs to clr */
+
+	set_irq_type(NSLU2_RB_IRQ, IRQT_LOW);
+	set_irq_type(NSLU2_PB_IRQ, IRQT_HIGH);
+
+	if (request_irq(NSLU2_RB_IRQ, &nslu2_reset_handler,
+		SA_INTERRUPT, "NSLU2 reset button", NULL) < 0) {
+
+		printk(KERN_DEBUG "Reset Button IRQ %d not available\n",
+			NSLU2_RB_IRQ);
+
+		return -EIO;
+	}
+
+	if (request_irq(NSLU2_PB_IRQ, &nslu2_power_handler,
+		SA_INTERRUPT, "NSLU2 power button", NULL) < 0) {
+
+		printk(KERN_DEBUG "Power Button IRQ %d not available\n",
+			NSLU2_PB_IRQ);
+
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit nslu2_power_exit(void)
+{
+	if (!(machine_is_nslu2()))
+		return;
+
+	free_irq(NSLU2_RB_IRQ, NULL);
+	free_irq(NSLU2_PB_IRQ, NULL);
+}
+
+module_init(nslu2_power_init);
+module_exit(nslu2_power_exit);
+
+MODULE_AUTHOR("Alessandro Zummo <a.zummo@towertech.it>");
+MODULE_DESCRIPTION("NSLU2 Power/Reset driver");
+MODULE_LICENSE("GPL");
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-setup.c linux-ixp425/arch/arm/mach-ixp4xx/fsg3-setup.c
--- linux-2.6.18/arch/arm/mach-ixp4xx/fsg3-setup.c	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/fsg3-setup.c	2006-10-25 16:29:31.000000000 +0930
@@ -0,0 +1,270 @@
+/*
+ * arch/arm/mach-ixp4xx/fsg3-setup.c
+ *
+ * FSG3/FHD3WLAN board-setup 
+ *
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ * Copyright (C) 2004-2006 Freecom Technologies GmbH.
+ *
+ * Author: Freecom - CR
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_8250.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/leds.h>
+
+#include <asm/types.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+
+#include <net/maclist.h>
+
+
+/*
+ * Xscale UART registers are 32 bits wide with only the least
+ * significant 8 bits having any meaning.  From a configuration
+ * perspective, this means 2 things...
+ *
+ *   Setting .regshift = 2 so that the standard 16550 registers
+ *   line up on every 4th byte.
+ *
+ *   Shifting the register start virtual address +3 bytes when
+ *   compiled big-endian.  Since register writes are done on a
+ *   single byte basis, if the shift isn't done the driver will
+ *   write the value into the most significant byte of the register,
+ *   which is ignored, instead of the least significant.
+ */
+
+#ifdef  __ARMEB__
+#define REG_OFFSET      3
+#else
+#define REG_OFFSET      0
+#endif
+
+/*
+ * FSG3 offers both chipset serial ports
+ */
+static struct flash_platform_data fsg3_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= 2,
+};
+
+static struct resource fsg3_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device fsg3_flash = {
+	.name		= "IXP4XX-Flash",
+	.id		= 0,
+	.dev.platform_data = &fsg3_flash_data,
+	.num_resources	= 1,
+	.resource	= &fsg3_flash_resource,
+};
+
+static struct ixp4xx_i2c_pins fsg3_i2c_gpio_pins = {
+	.sda_pin	= FSG3_SDA_PIN,
+	.scl_pin	= FSG3_SCL_PIN,
+};
+
+#ifdef CONFIG_LEDS_IXP4XX
+static struct resource fsg3_led_resources[] = {
+	{
+		.name		= "sync",
+		.start		= FSG3_LED_STARTUP,
+		.end		= FSG3_LED_STARTUP,
+		.flags		= 0x80,   // bit 7
+	},
+	{
+		.name		= "ring",
+		.start		= FSG3_LED_RING,
+		.end		= FSG3_LED_RING,
+		.flags		= 0x20,   // bit 5
+	},
+	{
+		.name		= "USB",
+		.start		= FSG3_LED_USB,
+		.end		= FSG3_LED_USB,
+		.flags		= 0x10,   // bit 4
+	},
+	{
+		.name		= "SATA",
+		.start		= FSG3_LED_SATA,
+		.end		= FSG3_LED_SATA,
+		.flags		= 0x04,   // bit 2
+	},
+	{
+		.name		= "WAN",
+		.start		= FSG3_LED_WAN,
+		.end		= FSG3_LED_WAN,
+		.flags		= 0x02,   // bit 1
+	},
+	{
+		.name		= "WLAN",
+		.start		= FSG3_LED_WLAN,
+		.end		= FSG3_LED_WLAN,
+		.flags		= 0x01,   // bit 0
+	},
+};
+
+static struct platform_device fsg3_leds = {
+	.name			= "IXP4XX-GPIO-LED",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(fsg3_led_resources),
+	.resource		= fsg3_led_resources,
+};
+#endif
+
+static struct platform_device fsg3_i2c_controller = {
+	.name		= "IXP4XX-I2C",
+	.id		= 0,
+	.dev.platform_data = &fsg3_i2c_gpio_pins,
+	.num_resources	= 0,
+};
+
+static struct resource fsg3_uart_resources[] = {
+        {
+                .start          = IXP4XX_UART1_BASE_PHYS,
+                .end            = IXP4XX_UART1_BASE_PHYS + 0x0fff,
+                .flags          = IORESOURCE_MEM,
+        },
+        {
+                .start          = IXP4XX_UART2_BASE_PHYS,
+                .end            = IXP4XX_UART2_BASE_PHYS + 0x0fff,
+                .flags          = IORESOURCE_MEM,
+        }
+};
+
+static struct plat_serial8250_port fsg3_uart_data[] = {
+        {
+                .mapbase        = IXP4XX_UART1_BASE_PHYS,
+                .membase        = (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+                .irq            = IRQ_IXP4XX_UART1,
+                .flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+                .iotype         = UPIO_MEM,
+                .regshift       = 2,
+                .uartclk        = IXP4XX_UART_XTAL,
+/*		.line		= 0,
+		.type		= PORT_XSCALE,
+		.fifosize	= 32
+*/
+        },
+        {
+                .mapbase        = IXP4XX_UART2_BASE_PHYS,
+                .membase        = (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+                .irq            = IRQ_IXP4XX_UART2,
+                .flags          = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+                .iotype         = UPIO_MEM,
+                .regshift       = 2,
+                .uartclk        = IXP4XX_UART_XTAL,
+/*		.line		= 1,
+		.type		= PORT_XSCALE,
+		.fifosize	= 32
+*/
+        },
+        { }
+};
+
+static struct platform_device fsg3_uart = {
+        .name                   = "serial8250",
+        .id                     = PLAT8250_DEV_PLATFORM,
+        .dev.platform_data      = fsg3_uart_data,
+        .num_resources          = 2,
+        .resource               = fsg3_uart_resources,
+};
+
+static struct platform_device *fsg3_devices[] __initdata = {
+	&fsg3_i2c_controller,
+	&fsg3_flash,
+	&fsg3_uart,
+#ifdef CONFIG_LEDS_IXP4XX
+	&fsg3_leds,
+#endif
+};
+
+#ifdef CONFIG_MACLIST
+static void fsg3_flash_add(struct mtd_info *mtd)
+{
+	/* When the RedBoot partition is added the MAC address is read from it. */
+	if (strcmp(mtd->name, "RedBoot config") == 0) {
+		size_t retlen;
+		u_char mac[6];
+
+		/* The MAC is at a known offset... */
+		/* TODO --> find npe_eth0 and ..1 instead of hardcoded offset and inc) */
+		if (mtd->read(mtd, 0x0422, 6, &retlen, mac) == 0 && retlen == 6) {
+			printk(KERN_INFO "FSG3-MAC for eth0: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			maclist_add(mac);
+			mac[5]++;
+			printk(KERN_INFO "FSG3-MAC for eth1: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			maclist_add(mac);
+		} else {
+			printk(KERN_ERR "FGS3-MAC: read failed\n");
+		}
+	}
+}
+
+static void fsg3_flash_remove(struct mtd_info *mtd)
+{
+	/* Nothing to do on remove at present. */
+}
+
+static struct mtd_notifier fsg3_flash_notifier = {
+	.add = fsg3_flash_add,
+	.remove = fsg3_flash_remove,
+};
+#endif
+
+static void fsg3_power_off(void)
+{
+	/* EL-Ring and LED's can be switched off here. */
+        printk(KERN_INFO "EL-Ring and LED's can be switched off here.\n");
+}
+
+static void __init fsg3_init(void)
+{
+	/* The flash has an ethernet MAC embedded in it which we need,
+	 * that is all this notifier does. */
+
+	ixp4xx_sys_init();
+
+	fsg3_flash_resource.start = FSG3_FLASH_BASE;
+	fsg3_flash_resource.end = FSG3_FLASH_BASE + FSG3_FLASH_SIZE;
+
+        *IXP4XX_EXP_CS0 |= IXP4XX_FLASH_WRITABLE;
+        *IXP4XX_EXP_CS1 = *IXP4XX_EXP_CS0;
+
+	/* Configure CS2 for operation, 8bit and writable will do */
+	*IXP4XX_EXP_CS2 = 0xbfff0002;
+
+	pm_power_off = fsg3_power_off;
+
+	platform_add_devices(fsg3_devices, ARRAY_SIZE(fsg3_devices));
+
+#ifdef CONFIG_MACLIST
+	register_mtd_user(&fsg3_flash_notifier);
+#endif
+}
+
+MACHINE_START(FREECOM_FSG3, "FSG3 - Freecom Storage Gateway")
+        /* Maintainer: Freecom Technologies GmbH */
+        .phys_io        = IXP4XX_PERIPHERAL_BASE_PHYS,
+        .io_pg_offst    = ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
+        .boot_params    = 0x00000100,
+        .map_io         = ixp4xx_map_io,
+        .init_irq       = ixp4xx_init_irq,
+        .timer          = &ixp4xx_timer,
+        .init_machine   = fsg3_init,
+MACHINE_END
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/Kconfig linux-ixp425/arch/arm/mach-ixp4xx/Kconfig
--- linux-2.6.18/arch/arm/mach-ixp4xx/Kconfig	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/Kconfig	2006-09-22 06:30:53.000000000 +0930
@@ -97,6 +97,15 @@
 	depends on MACH_IXDP465
 	default y
 
+config ARCH_FSG3
+	bool "FSG3"
+	select PCI
+	select MACLIST
+	help
+	  Say 'Y' here if you want your kernel to support
+	  Freecom Storage Gateway Device (Also known as FSG3).
+	  For more information on this device, see <http://www.openfsg.org>.
+
 config MACH_GTWX5715
 	bool "Gemtek WX5715 (Linksys WRV54G)"
 	depends on ARCH_IXP4XX
@@ -150,4 +159,6 @@
 
 endmenu
 
+source "drivers/ixp4xx/Kconfig"
+
 endif
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mach-ixp4xx/Makefile linux-ixp425/arch/arm/mach-ixp4xx/Makefile
--- linux-2.6.18/arch/arm/mach-ixp4xx/Makefile	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/mach-ixp4xx/Makefile	2006-09-22 06:31:30.000000000 +0930
@@ -11,6 +11,7 @@
 obj-pci-$(CONFIG_MACH_GTWX5715)		+= gtwx5715-pci.o
 obj-pci-$(CONFIG_MACH_NSLU2)		+= nslu2-pci.o
 obj-pci-$(CONFIG_MACH_NAS100D)		+= nas100d-pci.o
+obj-pci-$(CONFIG_ARCH_FSG3)		+= fsg3-pci.o
 
 obj-y	+= common.o
 
@@ -20,5 +21,6 @@
 obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-setup.o
 obj-$(CONFIG_MACH_NSLU2)	+= nslu2-setup.o nslu2-power.o
 obj-$(CONFIG_MACH_NAS100D)	+= nas100d-setup.o nas100d-power.o
+obj-$(CONFIG_ARCH_FSG3) 	+= fsg3-setup.o #fsg3-power.o
 
 obj-$(CONFIG_PCI)		+= $(obj-pci-$(CONFIG_PCI)) common-pci.o
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/arch/arm/mm/alignment.c linux-ixp425/arch/arm/mm/alignment.c
--- linux-2.6.18/arch/arm/mm/alignment.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/mm/alignment.c	2006-11-14 18:50:16.000000000 +1030
@@ -726,6 +726,14 @@
 	if (type == TYPE_LDST)
 		do_alignment_finish_ldst(addr, instr, regs, offset);
 
+	// show system alignment traps, by Freecom Technologies GmbH, Berlin
+	printk("Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*lx "
+	       "Address=0x%08lx FSR 0x%03x TYPE:%d\n", current->comm,
+		current->pid, instrptr,
+	        thumb_mode(regs) ? 4 : 8,
+	        thumb_mode(regs) ? tinstr : instr,
+	        addr, fsr, type);
+
 	return 0;
 
  bad_or_fault:
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/i2c/algos/i2c-algo-bit.c linux-ixp425/drivers/i2c/algos/i2c-algo-bit.c
--- linux-2.6.18/drivers/i2c/algos/i2c-algo-bit.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/i2c/algos/i2c-algo-bit.c	2006-11-02 20:07:00.000000000 +1030
@@ -157,7 +157,7 @@
 	for ( i=7 ; i>=0 ; i-- ) {
 		sb = c & ( 1 << i );
 		setsda(adap,sb);
-		udelay(adap->udelay);
+		udelay((adap->udelay+1)>>1);  // half time, by Freecom
 		DEBPROTO(printk(KERN_DEBUG "%d",sb!=0));
 		if (sclhi(adap)<0) { /* timed out */
 			sdahi(adap); /* we don't want to block the net */
@@ -168,7 +168,7 @@
 		 * if ( sb && ! getsda(adap) ) -> ouch! Get out of here.
 		 */
 		setscl(adap, 0 );
-		udelay(adap->udelay);
+		udelay((adap->udelay+1)>>1);  // half time, by Freecom
 	}
 	sdahi(adap);
 	if (sclhi(adap)<0){ /* timeout */
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/i2c/busses/i2c-ixp4xx.c linux-ixp425/drivers/i2c/busses/i2c-ixp4xx.c
--- linux-2.6.18/drivers/i2c/busses/i2c-ixp4xx.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/i2c/busses/i2c-ixp4xx.c	2006-11-02 20:54:34.000000000 +1030
@@ -121,7 +121,7 @@
 	drv_data->algo_data.setscl = ixp4xx_bit_setscl;
 	drv_data->algo_data.getsda = ixp4xx_bit_getsda;
 	drv_data->algo_data.getscl = ixp4xx_bit_getscl;
-	drv_data->algo_data.udelay = 10;
+	drv_data->algo_data.udelay = 5,  // set from 10 to 5, by Freecom
 	drv_data->algo_data.mdelay = 10;
 	drv_data->algo_data.timeout = 100;
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/ide/pci/via82cxxx.c linux-ixp425/drivers/ide/pci/via82cxxx.c
--- linux-2.6.18/drivers/ide/pci/via82cxxx.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/ide/pci/via82cxxx.c	2006-09-22 06:30:53.000000000 +0930
@@ -79,6 +79,7 @@
 	u16 flags;
 } via_isa_bridges[] = {
 	{ "vt6410",	PCI_DEVICE_ID_VIA_6410,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
+	{ "vt6421",	PCI_DEVICE_ID_VIA_6421,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8251",	PCI_DEVICE_ID_VIA_8251,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8237",	PCI_DEVICE_ID_VIA_8237,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8237a",	PCI_DEVICE_ID_VIA_8237A,    0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
@@ -498,6 +499,7 @@
 	{ PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C576_1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{ PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{ PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_6410,     PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+	{ PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_6421,     PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, via_pci_tbl);
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/ixp4xx/Kconfig linux-ixp425/drivers/ixp4xx/Kconfig
--- linux-2.6.18/drivers/ixp4xx/Kconfig	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/drivers/ixp4xx/Kconfig	2006-09-22 06:30:53.000000000 +0930
@@ -0,0 +1,27 @@
+#
+# Intel-IXP4xx Access-Layer-CSR
+#
+#	depends on ARCH_IXP4XX
+#	default m
+
+menu "IXP4xx specials"
+
+config IXP400_CSR
+	tristate "Intel-IXP4xx Access-Layer-CSR"
+#	depends on "m"
+	default m
+	help
+	  This option enables basic support
+	  for the Intel-IXP4xx Access-Layer-CSR
+
+source "drivers/ixp4xx/net/Kconfig"
+
+config IXP400_OCF
+	tristate "Intel-IXP4xx OCF"
+	depends on "n"
+	default m
+	help
+	  This option enables basic support
+	  for the Intel-IXP4xx OCF
+
+endmenu
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/ixp4xx/net/Kconfig linux-ixp425/drivers/ixp4xx/net/Kconfig
--- linux-2.6.18/drivers/ixp4xx/net/Kconfig	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/drivers/ixp4xx/net/Kconfig	2006-09-22 06:30:55.000000000 +0930
@@ -0,0 +1,86 @@
+
+
+config IXP400_ETH
+	tristate 'Intel IXP4xx Ethernet Device support'
+	depends on NETDEVICES && ARCH_IXP4XX && IXP400_CSR
+	---help---
+	  If you select M here, the Intel IXP4xx Ethernet driver will be
+	  compiled as part of the build.
+
+	  To enable this option you must enable 'IXP4xx Access Library' in the
+	  'System Type' section.
+
+	  In order for the driver to build correctly you must set up some
+	  environment variables before building the kernel. See the README
+	  files that accompany the IXP400 software or Linux Ethernet Driver
+	  distribution for details.
+
+	  Note that this driver is Intel proprietary code and must be obtained
+	  from Intel Corp. See the README files that accompany the IXP400
+	  software or Linux Ethernet Driver distribution for details.
+
+	  The driver can be compiled only as a module, as linking it
+	  statically into the kernel would violate the GPL. The module will be
+	  called ixp4xx_eth.o
+
+	  Select M if you have the IXP4xx ethernet driver source code and wish
+	  to include it in your build.
+
+choice 
+	depends on IXP400_ETH
+	prompt "Intel IXP4xx Ethernet Device Driver NPE support"
+	default IXP400_ETH_ALL
+	---help---
+	 If you select 'All NPEs' option here, the Intel IXP4xx Ethernet driver
+	 will be compiled to configure all Ethernet NPEs and map "ixp0" device
+	 to Ethernet NPE B and "ixp1" device to Ethernet NPE C
+
+	 If you select 'NPEB-only' option here, the Intel IXP4xx Ethernet driver
+	 will be compiled to map "ixp0" device to Ethernet NPE B.
+
+	 If you select 'NPEC-only' option here, the Intel IXP4xx Ethernet driver
+	 will be compiled to map "ixp0" device to Ethernet NPE C.
+
+	 See the README files that accompany the IXP400
+	 software or Linux Ethernet Driver distribution for details.
+
+config IXP400_ETH_ALL
+	bool "All_NPEs"
+
+config IXP400_ETH_NPEB_ONLY
+	bool "NPEB-only"
+
+config IXP400_ETH_NPEC_ONLY
+	bool "NPEC-only"
+
+endchoice
+
+config IXP400_ETH_SKB_RECYCLE
+	bool "Intel IXP4xx Ethernet Device Driver Fast Skb Recycling support"
+	depends on IXP400_ETH
+	---help---
+	 If you select Y here, the Intel IXP4xx Ethernet driver will be
+	 compiled to internally recycle skbufs.
+
+	 IMPORTANT: This option, if enabled, may NOT work with some
+	 patched kernels.
+
+	 If unsure select N here.
+
+	 See the README files that accompany the IXP400
+	 software or Linux Ethernet Driver distribution for details.
+
+config IXP400_ETH_QDISC_ENABLED
+	bool "Intel IXP4xx Ethernet Device Driver Fast QDisc support"
+	depends on IXP400_ETH
+	---help---
+	 If you select Y here, the Intel IXP4xx Ethernet driver will be
+	 compiled to internally use its own queueing discipline (qdisc).
+
+	 IMPORTANT: This option may NOT work with some debug tools or
+	 some kernel features.
+
+	 If unsure select N here.
+
+	 See the README files that accompany the IXP400
+	 software or Linux Ethernet Driver distribution for details.
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/leds/leds-ixp4xx-gpio.c linux-ixp425/drivers/leds/leds-ixp4xx-gpio.c
--- linux-2.6.18/drivers/leds/leds-ixp4xx-gpio.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/leds/leds-ixp4xx-gpio.c	2006-10-27 23:44:00.000000000 +0930
@@ -31,12 +31,23 @@
  *
  */
 
+/*
+ * reworked for FSG3 LEDS and buttons
+ * by Freecom Technologies GmbH, Berlin
+ */
+ 
+ 
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
 #include <linux/leds.h>
 #include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
 
 extern spinlock_t gpio_lock;
 
@@ -47,26 +58,198 @@
 	int               flags;
 } ixp4xxgpioled_devices[GPIO_MAX];
 
+static int key;
+static int pressSyncJiffies, pressResetJiffies, pressUnplugJiffies;
+static volatile unsigned short *ledmem_cs2, led_latch, led_blink_latch;
+
+struct work_struct  hotplug_work;
+static struct timer_list  leds_timerlist, keys_timerlist;
+
+
+#ifdef CONFIG_HOTPLUG
+
+/* Notify userspace when a key-event occurs,
+ * by running '/sbin/hotplug key' with certain
+ * environment variables set.
+ */
+
+static void key_run_sbin_hotplug(char *Action)
+{
+	char *argv[3], *envp[5], action_str[32];
+	int i;
+
+	sprintf(action_str, "ACTION=%s", Action);
+
+        i = 0;
+        argv[i++] = "/sbin/hotplug";
+        argv[i++] = "key";
+        argv[i] = 0;
+
+	i = 0;
+	/* minimal command environment */
+	envp [i++] = "HOME=/";
+	envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	envp [i++] = "INTERFACE=";
+	envp [i++] = action_str;
+	envp [i] = 0;
+
+        if (in_interrupt ()) {
+                printk ("LEDMAN-hotplug: -- In_interrupt\n");
+                return;
+        }
+        if (!current->fs->root) {
+                printk ("LEDMAN-hotplug: -- no FS yet\n");
+                return;
+        }
+
+	call_usermodehelper (argv[0], argv, envp, 0);
+}
+
+static void leds_poll(unsigned long arg)
+{
+	if(led_blink_latch == 0)
+		return;
+	  
+	*ledmem_cs2 = led_latch = led_latch ^ led_blink_latch;
+
+	/* Re-arm timer */
+	leds_timerlist.expires = jiffies + HZ/2;
+	add_timer(&leds_timerlist);
+}
+
+static void keys_poll(unsigned long arg)
+{
+	if(pressSyncJiffies == 0)
+		if(pressResetJiffies == 0)
+			return;
+
+	if(pressSyncJiffies != 0) if(abs(jiffies - pressSyncJiffies) >= 4*HZ) {
+		INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "SHUTDOWN");
+		schedule_work(&hotplug_work);
+		pressSyncJiffies = 0;
+		return;
+	}
+
+	if(pressResetJiffies != 0) if(abs(jiffies - pressResetJiffies) >= 4*HZ) {
+		INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "DEFAULTS");
+		schedule_work(&hotplug_work);
+		pressResetJiffies = 0;
+		return;
+	}
+
+	/* Re-arm timer */
+	keys_timerlist.expires = jiffies + HZ/10;
+	add_timer(&keys_timerlist);
+}
+
+static irqreturn_t leds_sync_key_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int holdkey;
+
+	gpio_line_get(FSG3_SYNC_KEY_PIN, &holdkey);
+	if(holdkey == 0) {  // key pressed ?
+
+		if(key == 0) {  // no other key still pressed ?
+			keys_timerlist.expires = jiffies + HZ/10;
+			add_timer(&keys_timerlist);
+		}
+
+		key = 1;
+		pressSyncJiffies = jiffies;
+	}
+	else {              // key released
+		key = 0;
+		if(pressSyncJiffies == 0)
+			return IRQ_HANDLED;
+
+		if(abs(jiffies - pressSyncJiffies) < 4*HZ) {
+			INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "SYNC");
+			schedule_work(&hotplug_work);
+		}
+
+		pressSyncJiffies = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t leds_reset_key_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int holdkey;
+
+	gpio_line_get(FSG3_RESET_KEY_PIN, &holdkey);
+	if(holdkey == 0) {  // key pressed ?
+
+		if(key == 0) {  // no other key still pressed ?
+			keys_timerlist.expires = jiffies + HZ/10;
+			add_timer(&keys_timerlist);
+		}
+
+		key = 1;
+		pressResetJiffies = jiffies;
+	}
+	else {              // key released
+		key = 0;
+		if(pressResetJiffies == 0)
+			return IRQ_HANDLED;
+
+		if(abs(jiffies - pressResetJiffies) < 4*HZ) {
+			INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "REBOOT");
+			schedule_work(&hotplug_work);
+		}
+
+		pressResetJiffies = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t leds_unplug_key_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	// Mechanical key are nasty, so do some pre-cautions.
+	if(abs(jiffies - pressUnplugJiffies) < HZ/2) {
+		pressUnplugJiffies = jiffies;
+		return IRQ_HANDLED;
+	}
+	pressResetJiffies = jiffies;
+
+	if(led_latch & 0x10)   // test USB LED
+		INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "UNPLUG");
+	else
+		INIT_WORK(&hotplug_work, key_run_sbin_hotplug, "COLDPLUG");
+	schedule_work(&hotplug_work);
+	return IRQ_HANDLED;
+}
+#endif   /* CONFIG_HOTPLUG */
+
+void ixp4xxgpioled_all_off(void)
+{
+	// all LEDs off and EL ring always off
+	*ledmem_cs2 = led_latch = 0xff9f;
+}
+
 void ixp4xxgpioled_brightness_set(struct led_classdev *pled,
 				enum led_brightness value)
 {
 	const struct ixp4xxgpioled_device *const ixp4xx_dev =
 		container_of(pled, struct ixp4xxgpioled_device, ancestor);
-	const u32 gpio_pin = ixp4xx_dev - ixp4xxgpioled_devices;
+	const u32 led_no = ixp4xx_dev - ixp4xxgpioled_devices;
 
-	if (gpio_pin < GPIO_MAX && ixp4xx_dev->ancestor.name != 0) {
-		/* Set or clear the 'gpio_pin' bit according to the style
-		 * and the required setting (value > 0 == on)
-		 */
-		const int gpio_value =
-			(value > 0) == (ixp4xx_dev->flags != IXP4XX_GPIO_LOW) ?
-				IXP4XX_GPIO_HIGH : IXP4XX_GPIO_LOW;
-
-		{
-			unsigned long flags;
-			spin_lock_irqsave(&gpio_lock, flags);
-			gpio_line_set(gpio_pin, gpio_value);
-			spin_unlock_irqrestore(&gpio_lock, flags);
+	if (led_no < GPIO_MAX && ixp4xx_dev->ancestor.name != 0) {
+		if(value == 2) {
+			if(led_blink_latch == 0) {
+				leds_timerlist.expires = jiffies + HZ/2;
+				add_timer(&leds_timerlist);
+			}
+			led_blink_latch |= ixp4xx_dev->flags;
+			*ledmem_cs2 = led_latch = led_latch & (~ixp4xx_dev->flags);
+		}
+		else {
+			led_blink_latch &= (~ixp4xx_dev->flags);
+			if(value == 0)
+				*ledmem_cs2 = led_latch = led_latch | ixp4xx_dev->flags;
+			else
+				*ledmem_cs2 = led_latch = led_latch & (~ixp4xx_dev->flags);
 		}
 	}
 }
@@ -130,24 +313,59 @@
 	 */
 	int i;
 
+	/* Map the LED chip select address space */
+	ledmem_cs2 = (volatile unsigned short *) ioremap(IXP425_EXP_BUS_CS2_BASE_PHYS, 512);
+	*ledmem_cs2 = led_latch = 0xffff;
+	led_blink_latch = 0x80;    // sync LED blinking
+
+#ifdef CONFIG_HOTPLUG
+	/* Configure interrupt input for SYNC switch */
+	set_irq_type(IRQ_IXP4XX_GPIO4, IRQT_BOTHEDGE);
+	if (request_irq(IRQ_IXP4XX_GPIO4, leds_sync_key_interrupt, IRQF_DISABLED, "Sync", NULL) < 0)
+		printk("LEDs: failed to register IRQ%d for SYNC switch\n", IRQ_IXP4XX_GPIO4);
+	else
+		printk("LEDs: registered SYNC switch on IRQ%d\n", IRQ_IXP4XX_GPIO4);
+
+	/* Configure interrupt input for RESET switch */
+	set_irq_type(IRQ_IXP4XX_GPIO9, IRQT_BOTHEDGE);
+	if (request_irq(IRQ_IXP4XX_GPIO9, leds_reset_key_interrupt, IRQF_DISABLED, "Reset", NULL) < 0)
+		printk("LEDs: failed to register IRQ%d for RESET switch\n", IRQ_IXP4XX_GPIO9);
+	else
+		printk("LEDs: registered RESET switch on IRQ%d\n", IRQ_IXP4XX_GPIO9);
+
+	/* Configure interrupt input for UNPLUG switch */
+	set_irq_type(IRQ_IXP4XX_GPIO10, IRQT_FALLING);
+	if (request_irq(IRQ_IXP4XX_GPIO10, leds_unplug_key_interrupt, IRQF_DISABLED, "Unplug", NULL) < 0)
+		printk("LEDs: failed to register IRQ%d for UNPLUG switch\n", IRQ_IXP4XX_GPIO10);
+	else
+		printk("LEDs: registered UNPLUG switch on IRQ%d\n", IRQ_IXP4XX_GPIO10);
+#endif
+
+
+	init_timer(&leds_timerlist);
+	leds_timerlist.expires = jiffies + HZ/2;
+	leds_timerlist.function = leds_poll;
+	leds_timerlist.data = 0;
+	add_timer(&leds_timerlist);
+
+#ifdef CONFIG_HOTPLUG
+	init_timer(&keys_timerlist);
+	keys_timerlist.expires = jiffies + HZ/2;
+	keys_timerlist.function = keys_poll;
+	keys_timerlist.data = 0;
+	add_timer(&keys_timerlist);
+
+	// at start-up one IRQ is released !?! So reset everything.
+	key = 0;
+	pressSyncJiffies = pressResetJiffies = pressUnplugJiffies = 0;
+#endif
+
+
 	for_all_leds(i, pdev) {
 		const u8 gpio_pin = pdev->resource[i].start;
 		int      rc;
 
 		if (ixp4xxgpioled_devices[gpio_pin].ancestor.name == 0) {
-			unsigned long flags;
-
-			spin_lock_irqsave(&gpio_lock, flags);
-			gpio_line_config(gpio_pin, IXP4XX_GPIO_OUT);
-			/* The config can, apparently, reset the state,
-			 * I suspect the gpio line may be an input and
-			 * the config may cause the line to be latched,
-			 * so the setting depends on how the LED is
-			 * connected to the line (which affects how it
-			 * floats if not driven).
-			 */
-			gpio_line_set(gpio_pin, IXP4XX_GPIO_HIGH);
-			spin_unlock_irqrestore(&gpio_lock, flags);
 
 			ixp4xxgpioled_devices[gpio_pin].flags =
 				pdev->resource[i].flags & IORESOURCE_BITS;
@@ -203,6 +421,10 @@
 
 static void __exit ixp4xxgpioled_exit(void)
 {
+	free_irq(FSG3_SYNC_KEY_PIN, NULL);
+	free_irq(FSG3_RESET_KEY_PIN, NULL);
+	free_irq(FSG3_UNPLUG_KEY_PIN, NULL);
+
 	platform_driver_unregister(&ixp4xxgpioled_driver);
 }
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/Makefile linux-ixp425/drivers/Makefile
--- linux-2.6.18/drivers/Makefile	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/Makefile	2006-09-22 06:30:53.000000000 +0930
@@ -47,6 +47,7 @@
 obj-$(CONFIG_ATA_OVER_ETH)	+= block/aoe/
 obj-$(CONFIG_PARIDE) 		+= block/paride/
 obj-$(CONFIG_TC)		+= tc/
+obj-$(CONFIG_ARCH_IXP4XX)	+= ixp4xx/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_PCI)		+= usb/
 obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/mtd/redboot.c linux-ixp425/drivers/mtd/redboot.c
--- linux-2.6.18/drivers/mtd/redboot.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/mtd/redboot.c	2006-09-22 06:24:27.000000000 +0930
@@ -87,14 +87,41 @@
 	for (i = 0; i < numslots; i++) {
 		if (!memcmp(buf[i].name, "FIS directory", 14)) {
 			/* This is apparently the FIS directory entry for the
-			 * FIS directory itself.  The FIS directory size is
-			 * one erase block; if the buf[i].size field is
-			 * swab32(erasesize) then we know we are looking at
-			 * a byte swapped FIS directory - swap all the entries!
-			 * (NOTE: this is 'size' not 'data_length'; size is
-			 * the full size of the entry.)
+			 * FIS directory itself.  To discover whether the entries
+			 * in this are native byte sex or byte swapped look at
+			 * the flash_base field - we know the FIS directory is
+			 * at 'offset' within the flash.
 			 */
-			if (swab32(buf[i].size) == master->erasesize) {
+			int maybe_native, maybe_swapped;
+			if (fis_origin != 0) {
+				maybe_native =
+					buf[i].flash_base == fis_origin + offset;
+				maybe_swapped =
+					swab32(buf[i].flash_base) == fis_origin + offset;
+			} else if (offset != 0 || buf[i].flash_base != 0) {
+				maybe_native =
+					(buf[i].flash_base & (master->size-1)) == offset;
+				maybe_swapped =
+					(swab32(buf[i].flash_base) & (master->size-1)) == offset;
+			} else {
+				/* The FIS directory is at the start of the flash and
+				 * the 'flash_base' field is 0.  The critical case is when
+				 * we are booting off this flash, but then we don't expect
+				 * this because the boot loader is pretty much always at
+				 * the start!  Since the FIS directory is always less than
+				 * or equal to one erase block do the following:
+				 */
+				maybe_native = buf[i].size <= master->erasesize;
+				maybe_swapped = swab32(buf[i].size) <= master->erasesize;
+			}
+
+			if (maybe_native && maybe_swapped)
+				printk(KERN_WARNING "RedBoot directory 0x%lx(0x%lx) assumed native\n",
+					buf[i].flash_base, buf[i].size);
+			else if (!maybe_native && !maybe_swapped)
+				printk(KERN_ERR "RedBoot directory 0x%lx(0x%lx) forced native\n",
+					buf[i].flash_base, buf[i].size);
+			else if (maybe_swapped) {
 				int j;
 				for (j = 0; j < numslots && buf[j].name[0] != 0xff; ++j) {
 					/* The unsigned long fields were written with the
@@ -108,7 +135,11 @@
 					swab32s(&buf[j].desc_cksum);
 					swab32s(&buf[j].file_cksum);
 				}
-			}
+				printk(KERN_NOTICE "RedBoot directory 0x%lx(0x%lx) swapped\n",
+					buf[i].flash_base, buf[i].size);
+			} else
+				printk(KERN_NOTICE "RedBoot directory 0x%lx(0x%lx) native\n",
+					buf[i].flash_base, buf[i].size);
 			break;
 		}
 	}
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/net/Kconfig linux-ixp425/drivers/net/Kconfig
--- linux-2.6.18/drivers/net/Kconfig	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/net/Kconfig	2006-09-22 06:30:55.000000000 +0930
@@ -177,6 +177,21 @@
 	  kernel: saying N will just cause the configurator to skip all
 	  the questions about Ethernet network cards. If unsure, say N.
 
+config MACLIST
+	tristate "Ethernet MAC repository"
+	depends on NET_ETHERNET
+	help
+	  Some ethernet controllers have no built-in way of obtaining an
+	  appropriate Ethernet MAC address.  Such controllers have to be
+	  initialised in a board-specific way, depending on how the allocated
+	  MAC is stored.  The MAC repository provides a set of APIs and a
+	  proc entry (/proc/net/maclist) to store MAC values from the board
+	  so that such drivers can obtain a MAC address without board-specific
+	  code.  You do not need to enable this device - it will be selected
+	  automatically by any device which requires it.  It is only useful
+	  to enable it manually when building a device driver independently
+	  of the kernel build.
+
 config MII
 	tristate "Generic Media Independent Interface device support"
 	depends on NET_ETHERNET
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/net/maclist.c linux-ixp425/drivers/net/maclist.c
--- linux-2.6.18/drivers/net/maclist.c	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/drivers/net/maclist.c	2006-09-22 06:30:55.000000000 +0930
@@ -0,0 +1,465 @@
+/*
+ * drivers/net/maclist.c
+ *
+ * a simple driver to remember ethernet MAC values
+ *
+ * Some Ethernet hardware implementations have no built-in
+ * storage for allocated MAC values - an example is the Intel
+ * IXP420 chip which has support for Ethernet but no defined
+ * way of storing allocated MAC values.  With such hardware
+ * different board level implementations store the allocated
+ * MAC (or MACs) in different ways.  Rather than put board
+ * level code into a specific Ethernet driver this driver
+ * provides a generally accessible repository for the MACs
+ * which can be written by board level code and read by the
+ * driver.
+ *
+ * The implementation also allows user level programs to
+ * access the MAC information in /proc/net/maclist.  This is
+ * useful as it allows user space code to use the MAC if it
+ * is not used by a built-in driver.
+ *
+ * Copyright (C) 2005 John Bowler
+ * Author: John Bowler <jbowler@acm.org>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * External interfaces:
+ *  Interfaces to linux kernel (and modules)
+ *   maclist_add:   add a single MAC, sequenced with a single
+ *                  writer lock (reads may happen simultaneously
+ *                  because of the way the list is built)
+ *   maclist_count: total number of MACs stored
+ *   maclist_read:  read a MAC 0..(maclist_count-1).  Call this
+ *                  to get a specific MAC.  If the argument is
+ *                  a new key and all the allocaed MACs have been
+ *                  assigned a random but valid MAC will be return
+ *                  (and this will be stored for later retrieval
+ *                  under the given key.)
+ *
+ * Sequencing:
+ *  The MAC ids must be added before any driver tries to use them
+ *  (this is obvious isn't it?)  This can be made to happen by
+ *  sequencing the initcalls correctly.  The module or kernel
+ *  parameters have been handled before any init call happens.
+ *  The important trick here is to ensure that the platform
+ *  initialises any devices with MAC ids *before* any devices
+ *  which might use them.
+ *
+ *  When this code is a module any other module which adds a
+ *  MAC should be modprobed before modules for ethernet
+ *  devices.
+ *
+ *  The failure case is 'soft' - the device will get a valid, but
+ *  random, MAC and the real allocated MACs will never get used.
+ *  This can be seen by looking at the list of ids in sysfs (there
+ *  will be extra, random, ones after the allocated ones).
+ *
+ * Recommendations:
+ *  For ethernet drivers which are known to be the sole driver on
+ *  the board (without a built in MAC) and where the number of
+ *  devices driven is known simply use an index 0..(n-1) as a
+ *  key for each of the n devices.
+ *
+ *  This is the common case, it works where one driver handles
+ *  multiple devices so long as the total number of devices can
+ *  be determined reliably.  It is sufficient merely to maintain
+ *  a global count of the number of devices initialised so far,
+ *  just so long as the initialisation order is consistent.
+ *
+ *  When the driver is generic and the board may be populated with
+ *  other devices which allocate MACs from the maclist pool and
+ *  use different drivers create a random key and compile this into
+ *  the code.  Use this as the base for all devices from the driver
+ *  (using a global device count for this driver if necessary).
+ *
+ *  With the second strategy the assignment of MACs will depend on
+ *  the order of initialisation of the different drivers.  To avoid
+ *  this provide a kernel (or module) command line parameter to
+ *  specify a base index and (optional) count for each driver or
+ *  pass in a (struct resource) with the start and end of the keys
+ *  to pass to maclist_read.  Either method allows the higher levels
+ *  (boot loader or machine description) to specify which MACs in
+ *  the list to assign to each device.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/spinlock.h>
+#include <linux/etherdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+
+#include <net/maclist.h>
+
+#define MACLIST_NAME "maclist"
+
+MODULE_AUTHOR("John Bowler <jbowler@acm.org>");
+MODULE_DESCRIPTION("MAC list repository");
+MODULE_LICENSE("GPL");
+
+typedef struct maclist_entry {
+	struct maclist_entry *next;  /* Linked list, first first */
+	u32                   key;   /* count or key for this entry */
+	u16                   flags;
+	u8                    id[6]; /* 6 byte Ethernet MAC */
+} maclist_entry_t;
+
+/*
+ * flag definitions
+ */
+#define MACLIST_ALLOCATED 1
+#define MACLIST_RANDOM    2
+
+/* Access to this list is protected by a standard rwlock_t. */
+static maclist_entry_t *maclist_list = 0;
+
+static DEFINE_RWLOCK(maclist_lock);
+
+/*
+ * External interfaces.
+ *
+ * Add a single entry, returns 0 on success else an error
+ * code.  Checks for invalid addresses.
+ */
+int maclist_add(const u8 new_id[6]) {
+	maclist_entry_t *new_entry, **tail;
+
+	if (new_id == 0 || !is_valid_ether_addr(new_id)) {
+		printk(KERN_ERR MACLIST_NAME ": invalid ethernet address\n");
+		return -EINVAL;
+	}
+	new_entry = kmalloc(sizeof *new_entry, GFP_KERNEL);
+	if (new_entry == 0)
+		return -ENOMEM;
+	new_entry->next  = 0;
+	new_entry->key   = 0;
+	new_entry->flags = 0;
+	memcpy(new_entry->id, new_id, sizeof new_entry->id);
+
+	tail = &maclist_list;
+
+	write_lock(&maclist_lock);
+	while (*tail != 0)
+		tail = &(*tail)->next;
+	*tail = new_entry;
+	write_unlock(&maclist_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(maclist_add);
+
+/*
+ * Return the current entry count.
+ */
+static int maclist_count_unlocked(void) {
+	maclist_entry_t *tail = maclist_list;
+	int count = 0;
+
+	while (tail != 0) {
+		tail = tail->next;
+		++count;
+	}
+
+	return count;
+}
+
+int maclist_count(void) {
+	int count;
+
+	read_lock(&maclist_lock);
+		count = maclist_count_unlocked();
+	read_unlock(&maclist_lock);
+
+	return count;
+}
+EXPORT_SYMBOL(maclist_count);
+
+/*
+ * Return the ID with the given key (the key is allocated
+ * to an entry if not found).
+ */
+void maclist_read(u8 (*id)[6], u32 key) {
+	int              count, index;
+	maclist_entry_t *entry, *entry_to_allocate;
+	
+	/* Do this under a write lock to avoid the SMP race
+	 * where we find the key isn't assigned, drop the lock,
+	 * have another CPU assign it, then assign it on this
+	 * CPU too - very bad...
+	 */
+	write_lock(&maclist_lock);
+		count             = maclist_count_unlocked();
+		index             = key % count; /* index of entry to allocate */
+		entry_to_allocate = 0;
+
+		entry = maclist_list;
+		while (entry != 0) {
+			if ((entry->flags & MACLIST_ALLOCATED) != 0) {
+				if (entry->key == key) {
+					/* Found it, use this entry. */
+					entry_to_allocate = entry;
+					break;
+				}
+			} else if (entry_to_allocate == 0 || count <= index) {
+				/* The algorithm is to try for entry
+				 * (key % count), but if this isn't possible
+				 * return the prior unallocated entry.
+				 */
+				entry_to_allocate = entry;
+			}
+
+			++count;
+			entry = entry->next;
+		}
+
+		/* Use entry_to_allocate, allocating it if necessary. */
+		if (entry_to_allocate != 0) {
+			if ((entry_to_allocate->flags & MACLIST_ALLOCATED) == 0) {
+				entry_to_allocate->key = key;
+				entry_to_allocate->flags |= MACLIST_ALLOCATED;
+			}
+			memcpy(id, entry_to_allocate->id, sizeof *id);
+		}
+	write_unlock(&maclist_lock);
+
+	if (entry_to_allocate == 0) {
+		/* No unallocated entries.  Make a new one and return it. */
+		printk(KERN_INFO MACLIST_NAME ": adding random MAC for key 0x%x\n", key);
+		random_ether_addr(*id);
+		if (maclist_add(*id) == 0)
+			maclist_read(id, key);
+	}
+}
+EXPORT_SYMBOL(maclist_read);
+
+/*
+ * Parameter parsing.  The option string is a list of MAC
+ * addresses, comma separated.  (The parsing really should
+ * be somewhere central...)
+ */
+static int __init maclist_setup(const char *param) {
+	int bytes = 0, seen_a_digit = 0;
+	u8 id[6];
+
+	memset(id, 0, sizeof id);
+
+	if (param) do {
+		int digit = -1;
+		switch (*param) {
+		case '0': digit = 0; break;
+		case '1': digit = 1; break;
+		case '2': digit = 2; break;
+		case '3': digit = 3; break;
+		case '4': digit = 4; break;
+		case '5': digit = 5; break;
+		case '6': digit = 6; break;
+		case '7': digit = 7; break;
+		case '8': digit = 8; break;
+		case '9': digit = 9; break;
+		case 'a': case 'A': digit = 10; break;
+		case 'b': case 'B': digit = 11; break;
+		case 'c': case 'C': digit = 12; break;
+		case 'd': case 'D': digit = 13; break;
+		case 'e': case 'E': digit = 14; break;
+		case 'f': case 'F': digit = 15; break;
+		case ':':
+			if (seen_a_digit)
+				bytes = (bytes+1) & ~1;
+			else
+				bytes += 2; /* i.e. ff::ff is ff:00:ff */
+			seen_a_digit = 0;
+			break;
+		case 0:
+			if (bytes == 0) /* nothing new seen so far */
+				return 0;
+			/*fall through*/
+		case ',': case ';':
+			if (bytes > 0)
+				bytes = 12; /* i.e. all trailing bytes 0 */
+			break;
+		default:
+			printk(KERN_ERR MACLIST_NAME ": invalid character <%c[%d]>\n",
+					*param, *param);
+			return -EINVAL;
+		}
+
+		if (digit >= 0) {
+			id[bytes>>1] = (id[bytes>>1] << 4) + digit; break;
+			++bytes;
+			seen_a_digit = 1;
+		}
+
+		if (bytes >= 12) {
+			int rc = maclist_add(id);
+			if (unlikely(rc))
+				return rc;
+			bytes = 0;
+			seen_a_digit = 0;
+			memset(id, 0, sizeof id);
+			if (*param == 0)
+				return 0;
+		}
+		++param;
+	} while (1);
+
+	return 0;
+}
+
+#if (defined CONFIG_PROC_FS) || (defined MODULE)
+/*
+ * Character device read
+ */
+static int maclist_getchar(off_t n) {
+	static char xdigit[16] = "0123456789abcdef";
+	maclist_entry_t *head = maclist_list;
+	int b;
+
+	do {
+		if (head == 0)
+			return -1;
+		if (n < 18)
+			break;
+		head = head->next;
+		n -= 18;
+	} while (1);
+
+	if (n == 17)
+		return '\n';
+
+	b = n/3;
+	switch (n - b*3) {
+	case 0: return xdigit[head->id[b] >> 4];
+	case 1: return xdigit[head->id[b] & 0xf];
+	default: return ':';
+	}
+}
+#endif
+
+/*
+ * procfs support, if compiled in.
+ */
+#ifdef CONFIG_PROC_FS
+/*
+ * The extensively undocumented proc_read_t callback is implemented here.
+ * Go look in fs/proc/generic.c:
+ *
+ * Prototype:
+ *    int f(char *buffer, char **start, off_t offset,
+ *          int count, int *peof, void *dat)
+ *
+ * Assume that the buffer is "count" bytes in size.
+ *
+ * 2) Set *start = an address within the buffer.
+ *    Put the data of the requested offset at *start.
+ *    Return the number of bytes of data placed there.
+ *    If this number is greater than zero and you
+ *    didn't signal eof and the reader is prepared to
+ *    take more data you will be called again with the
+ *    requested offset advanced by the number of bytes
+ *    absorbed.
+ */
+static int maclist_proc_read(char *buffer, char **start, off_t offset,
+		int count, int *peof, void *dat) {
+	int total;
+
+	*start = buffer;
+	total = 0;
+
+	while (total < count) {
+		int ch = maclist_getchar(offset++);
+		if (ch == -1) {
+			*peof = 1;
+			break;
+		}
+		*buffer++ = ch;
+		++total;
+	}
+
+	return total;
+}
+#endif
+
+/*
+ * set works once, at init time (the param is set to 0444 below),
+ * get works any time.
+ */
+static int param_set_maclist(const char *val, struct kernel_param *kp)
+{
+	if (maclist_list == 0)
+		return maclist_setup(val);
+
+	printk(KERN_ERR MACLIST_NAME ": call to set parameters too late\n");
+	return -EINVAL;
+}
+
+static int param_get_maclist(char *buffer, struct kernel_param *kp)
+{
+#ifdef MODULE
+	off_t offset = 0;
+
+	/* buffer is only 4k! */
+	while (offset < 4096) {
+		int ch = maclist_getchar(offset++);
+		if (ch < 0) {
+			*buffer = 0;
+			return 0;
+		}
+		*buffer++ = ch;
+	}
+
+	*--buffer = 0;
+	return -ENOMEM;
+#else
+	return -EINVAL;
+#endif
+}
+
+/*
+ * module: the argument is ids=mac,mac,mac
+ * kernel command line: maclist.ids=mac,mac,mac
+ */
+#define param_check_maclist(name, p) __param_check(name, p, maclist_entry_t*)
+module_param_named(ids, maclist_list, maclist, 0444);
+MODULE_PARM_DESC(ids, "comma separated list of MAC ids\n");
+
+/*
+ * Finally, the init/exit functions.
+ */
+static void __exit maclist_exit(void)
+{
+	maclist_entry_t *list;
+
+	remove_proc_entry(MACLIST_NAME, proc_net);
+
+	write_lock(&maclist_lock);
+		list = maclist_list;
+		maclist_list = 0;
+	write_unlock(&maclist_lock);
+
+	while (list != 0) {
+		maclist_entry_t *head = list;
+		list = head->next;
+		kfree(head);
+	}
+}
+
+static int __init maclist_init(void)
+{
+#	ifdef MODULE
+		if (ids[0])
+			maclist_setup(ids);
+#	endif
+
+	/* Ignore failure, the module will still work. */
+	(void)create_proc_read_entry(MACLIST_NAME, S_IRUGO, proc_net, maclist_proc_read, NULL);
+
+	return 0;
+}
+
+module_init(maclist_init);
+module_exit(maclist_exit);
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/net/Makefile linux-ixp425/drivers/net/Makefile
--- linux-2.6.18/drivers/net/Makefile	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/net/Makefile	2006-09-22 06:30:55.000000000 +0930
@@ -77,6 +77,7 @@
 # end link order section
 #
 
+obj-$(CONFIG_MACLIST) += maclist.o
 obj-$(CONFIG_MII) += mii.o
 obj-$(CONFIG_PHYLIB) += phy/
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/pci/pci.c linux-ixp425/drivers/pci/pci.c
--- linux-2.6.18/drivers/pci/pci.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/pci/pci.c	2006-09-22 06:30:55.000000000 +0930
@@ -925,6 +925,8 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(pci_set_dma_mask);
+EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 #endif
      
 static int __devinit pci_init(void)
@@ -980,8 +982,6 @@
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
 EXPORT_SYMBOL_GPL(pci_intx);
-EXPORT_SYMBOL(pci_set_dma_mask);
-EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 EXPORT_SYMBOL(pci_assign_resource);
 EXPORT_SYMBOL(pci_find_parent_resource);
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/scsi/libata-core.c linux-ixp425/drivers/scsi/libata-core.c
--- linux-2.6.18/drivers/scsi/libata-core.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/scsi/libata-core.c	2006-11-28 01:08:34.000000000 +1030
@@ -3627,9 +3627,9 @@
 
 	/* Transfer multiple of 2 bytes */
 	if (write_data)
-		outsw(ap->ioaddr.data_addr, buf, words);
+		outsw(ap->ioaddr.data_addr, (const u16*)buf, words);
 	else
-		insw(ap->ioaddr.data_addr, buf, words);
+		insw(ap->ioaddr.data_addr, (u16*)buf, words);
 
 	/* Transfer trailing 1 byte, if any. */
 	if (unlikely(buflen & 0x01)) {
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/drivers/scsi/sata_via.c linux-ixp425/drivers/scsi/sata_via.c
--- linux-2.6.18/drivers/scsi/sata_via.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/drivers/scsi/sata_via.c	2006-11-22 18:27:39.000000000 +1030
@@ -63,7 +63,7 @@
 	PORT0			= (1 << 1),
 	PORT1			= (1 << 0),
 	ALL_PORTS		= PORT0 | PORT1,
-	N_PORTS			= 2,
+	N_PORTS			= 3,
 
 	NATIVE_MODE_ALL		= (1 << 7) | (1 << 6) | (1 << 5) | (1 << 4),
 
@@ -75,9 +75,11 @@
 static u32 svia_scr_read (struct ata_port *ap, unsigned int sc_reg);
 static void svia_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val);
 static void vt6420_error_handler(struct ata_port *ap);
+static void via_pata_phy_reset(struct ata_port *ap);
+static void via_pata_set_piomode (struct ata_port *ap, struct ata_device *adev);
+static void via_pata_set_dmamode (struct ata_port *ap, struct ata_device *adev);
 
 static const struct pci_device_id svia_pci_tbl[] = {
-	{ 0x1106, 0x0591, PCI_ANY_ID, PCI_ANY_ID, 0, 0, vt6420 },
 	{ 0x1106, 0x3149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, vt6420 },
 	{ 0x1106, 0x3249, PCI_ANY_ID, PCI_ANY_ID, 0, 0, vt6421 },
 
@@ -143,12 +145,17 @@
 static const struct ata_port_operations vt6421_sata_ops = {
 	.port_disable		= ata_port_disable,
 
+ 	.set_piomode 		= via_pata_set_piomode,
+	.set_dmamode 		= via_pata_set_dmamode,
+
 	.tf_load		= ata_tf_load,
 	.tf_read		= ata_tf_read,
 	.check_status		= ata_check_status,
 	.exec_command		= ata_exec_command,
 	.dev_select		= ata_std_dev_select,
 
+	.phy_reset 		= via_pata_phy_reset, //new LAWI
+
 	.bmdma_setup            = ata_bmdma_setup,
 	.bmdma_start            = ata_bmdma_start,
 	.bmdma_stop		= ata_bmdma_stop,
@@ -166,8 +173,8 @@
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
 
-	.scr_read		= svia_scr_read,
-	.scr_write		= svia_scr_write,
+//	.scr_read		= svia_scr_read,
+//	.scr_write		= svia_scr_write,
 
 	.port_start		= ata_port_start,
 	.port_stop		= ata_port_stop,
@@ -290,27 +297,33 @@
 {
 	return addr + (port * 128);
 }
-
+/*
 static unsigned long vt6421_scr_addr(unsigned long addr, unsigned int port)
 {
 	return addr + (port * 64);
 }
-
+*/
 static void vt6421_init_addrs(struct ata_probe_ent *probe_ent,
 			      struct pci_dev *pdev,
 			      unsigned int port)
 {
-	unsigned long reg_addr = pci_resource_start(pdev, port);
-	unsigned long bmdma_addr = pci_resource_start(pdev, 4) + (port * 8);
-	unsigned long scr_addr;
+	// by Freecom Technologies GmbH, Berlin
+	// Change port priority:  highest -> SATA0 (internal SATA)
+	//                        middle  -> ATA
+	//                        lowest  -> SATA1 (external SATA)
+	unsigned int hPort = (port ? port ^ 3 : 0);
+
+	unsigned long reg_addr = pci_resource_start(pdev, hPort);
+	unsigned long bmdma_addr = pci_resource_start(pdev, 4) + (hPort * 8);
+//	unsigned long scr_addr;
 
 	probe_ent->port[port].cmd_addr = reg_addr;
 	probe_ent->port[port].altstatus_addr =
 	probe_ent->port[port].ctl_addr = (reg_addr + 8) | ATA_PCI_CTL_OFS;
 	probe_ent->port[port].bmdma_addr = bmdma_addr;
 
-	scr_addr = vt6421_scr_addr(pci_resource_start(pdev, 5), port);
-	probe_ent->port[port].scr_addr = scr_addr;
+//	scr_addr = vt6421_scr_addr(pci_resource_start(pdev, 5), port);
+//	probe_ent->port[port].scr_addr = scr_addr;
 
 	ata_std_ports(&probe_ent->port[port]);
 }
@@ -346,7 +359,8 @@
 	INIT_LIST_HEAD(&probe_ent->node);
 
 	probe_ent->sht		= &svia_sht;
-	probe_ent->host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY;
+	//probe_ent->host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY;
+	probe_ent->host_flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST | ATA_FLAG_NO_LEGACY;
 	probe_ent->port_ops	= &vt6421_sata_ops;
 	probe_ent->n_ports	= N_PORTS;
 	probe_ent->irq		= pdev->irq;
@@ -361,6 +375,175 @@
 	return probe_ent;
 }
 
+//PATA CHANGES
+/* add functions for pata */
+
+
+/**
+ * via_pata_cbl_detect - Probe host controller cable detect info
+ * @ap: Port for which cable detect info is desired
+ *
+ * Read 80c cable indicator from ATA PCI device's PCI config
+ * register. This register is normally set by firmware (BIOS).
+ *
+ * LOCKING:
+ * None (inherited from caller).
+ */
+static void via_pata_cbl_detect(struct ata_port *ap)
+{
+  struct pci_dev *pdev = to_pci_dev(ap->host_set->dev);
+  int cfg_addr;
+  u8 tmp;
+
+
+  if (ap->port_no == 2) { /* PATA channel in VT6421 */
+    ap->cbl = ATA_CBL_PATA80;
+    cfg_addr = 0xB3;
+    pci_read_config_byte(pdev, cfg_addr, &tmp);
+    if (tmp & 0x10) { /* 40pin cable */
+      ap->cbl = ATA_CBL_PATA40;
+    }
+    else { /* 80pin cable */
+      ap->cbl = ATA_CBL_PATA80;
+    }
+  }
+  else { /* channel 0 and 1 are SATA channels */
+    ap->cbl = ATA_CBL_SATA;
+  }
+
+  return;
+}
+
+/**
+ * via_pata_phy_reset - Probe specified port on PATA host controller
+ * @ap: Port to probe
+ *
+ * Probe PATA phy.
+ *
+ * LOCKING:
+ * None (inherited from caller).
+ */
+
+static void via_pata_phy_reset(struct ata_port *ap)
+{
+// struct pci_dev *pdev = to_pci_dev(ap->host_set->dev);
+
+ via_pata_cbl_detect(ap);
+
+ ata_port_probe(ap);
+
+ ata_bus_reset(ap);
+}
+
+
+/**
+ * via_pata_set_piomode - Initialize host controller PATA PIO timings
+ * @ap: Port whose timings we are configuring
+ * @adev: um
+ * @pio: PIO mode, 0 - 4
+ *
+ * Set PIO mode for device, in host controller PCI config space.
+ *
+ * LOCKING:
+ * None (inherited from caller).
+ */
+
+static void via_pata_set_piomode (struct ata_port *ap, struct ata_device *adev)
+{
+ struct pci_dev *dev = to_pci_dev(ap->host_set->dev);
+
+ u8 cfg_byte;
+ int cfg_addr;
+
+ if (ap->port_no != 2) { /* SATA channel in VT6421 */
+ /* no need to set */
+ return;
+ }
+
+
+ cfg_addr = 0xAB;
+ switch (adev->pio_mode & 0x07) {
+ case 0:
+ cfg_byte = 0xa8;
+ break;
+ case 1:
+ cfg_byte = 0x65;
+ break;
+ case 2:
+ cfg_byte = 0x65;
+ break;
+ case 3:
+ cfg_byte = 0x31;
+ break;
+ case 4:
+ cfg_byte = 0x20;
+ break;
+ default:
+ cfg_byte = 0x20;
+ }
+
+ pci_write_config_byte (dev, cfg_addr, cfg_byte);
+}
+
+/**
+ * via_pata_set_dmamode - Initialize host controller PATA PIO timings
+ * @ap: Port whose timings we are configuring
+ * @adev: um
+ * @udma: udma mode, 0 - 6
+ *
+ * Set UDMA mode for device, in host controller PCI config space.
+ *
+ * LOCKING:
+ * None (inherited from caller).
+ */
+
+static void via_pata_set_dmamode (struct ata_port *ap, struct ata_device *adev)
+{
+ struct pci_dev *dev = to_pci_dev(ap->host_set->dev);
+
+ u8 cfg_byte;
+ int cfg_addr;
+
+ if (ap->port_no != 2) { /* SATA channel in VT6421 */
+ /* no need to set */
+ return;
+ }
+
+ cfg_addr = 0xB3;
+ switch (adev->dma_mode & 0x07) {
+ case 0:
+ cfg_byte = 0xee;
+ break;
+ case 1:
+ cfg_byte = 0xe8;
+ break;
+ case 2:
+ cfg_byte = 0xe6;
+ break;
+ case 3:
+ cfg_byte = 0xe4;
+ break;
+ case 4:
+ cfg_byte = 0xe2;
+ break;
+ case 5:
+ cfg_byte = 0xe1;
+ break;
+ case 6:
+ cfg_byte = 0xe0;
+ break;
+ default:
+ cfg_byte = 0xe0;
+ }
+
+ pci_write_config_byte (dev, cfg_addr, cfg_byte);
+}
+
+
+
+
+
+
 static void svia_configure(struct pci_dev *pdev)
 {
 	u8 tmp8;
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/cifspdu.h linux-ixp425/fs/cifs/cifspdu.h
--- linux-2.6.18/fs/cifs/cifspdu.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/cifspdu.h	2006-12-15 21:45:27.000000000 +1030
@@ -354,8 +354,34 @@
 	__u8 WordCount;
 } __attribute__((packed));
 /* given a pointer to an smb_hdr retrieve the value of byte count */
-#define BCC(smb_var) ( *(__u16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ) )
-#define BCC_LE(smb_var) ( *(__le16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ) )
+//#define BCC(smb_var) ( *(__u16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ) )
+//#define BCC_LE(smb_var) ( *(__le16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ) )
+
+// replace with alignment safe versions, by Freecom Technologies GmbH, berlin
+#define BCC_READ(smb_var)  \
+  ( ((__u16)(*((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) + 1))) + \
+   (((__u16)(*((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ))) << 8) )
+#define BCC_WRITE(smb_var, value)  \
+  { *((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) + 1) = (char)value; \
+    *((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount)) = (char)(value >> 8); }
+#define BCC_READ_LE(smb_var)  \
+  ( ((__u16)(*((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) ))) + \
+   (((__u16)(*((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) + 1 ))) << 8) )
+#define BCC_WRITE_LE(smb_var, value)  \
+  { *((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount)) = (char)value; \
+    *((char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) + 1) = (char)(value >> 8); }
+#define le16_to_cpu_align(wordptr)  \
+  ( ((__u16)(*((char *)(wordptr)))) + (((__u16)(*((char *)(wordptr) + 1))) << 8) )
+#define cpu_align(wordptr)  \
+  ( ((__u16)(*((char *)(wordptr) + 1))) + (((__u16)(*((char *)(wordptr)))) << 8) )
+#define le16_to_cpu_write_align(wordptr, value)  \
+  { *((char *)(wordptr)) = (char)(value); \
+    *((char *)(wordptr) + 1) = (char)((value) >> 8); }
+#define cpu_swap_align(wordptr)  \
+  { char c = *((char *)(wordptr)); \
+    *((char *)(wordptr)) = *((char *)(wordptr) + 1); \
+    *((char *)(wordptr) + 1) = c; }
+
 /* given a pointer to an smb_hdr retrieve the pointer to the byte area */
 #define pByteArea(smb_var) ((unsigned char *)smb_var + sizeof(struct smb_hdr) + (2* smb_var->WordCount) + 2 )
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/cifssmb.c linux-ixp425/fs/cifs/cifssmb.c
--- linux-2.6.18/fs/cifs/cifssmb.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/cifssmb.c	2006-12-15 21:25:34.000000000 +1030
@@ -373,7 +373,8 @@
 				pBCC = (pSMB->hdr.WordCount * 2) + 
 					sizeof(struct smb_hdr) +
 					(char *)pSMB;
-				if((total_size <= (*(u16 *)pBCC)) && 
+				// align safe, by Freecom
+				if((total_size <= cpu_align(pBCC)) && 
 				   (total_size < 
 					CIFSMaxBufSize+MAX_CIFS_HDR_SIZE)) {
 					return 0;
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/cifs_unicode.c linux-ixp425/fs/cifs/cifs_unicode.c
--- linux-2.6.18/fs/cifs/cifs_unicode.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/cifs_unicode.c	2006-12-15 21:27:18.000000000 +1030
@@ -38,11 +38,13 @@
 	int i;
 	int outlen = 0;
 
-	for (i = 0; (i < len) && from[i]; i++) {
+	// read "from" align safe, by Freecom
+	for (i = 0; (i < len) && le16_to_cpu_align(from + i); i++) {
 		int charlen;
 		/* 2.4.0 kernel or greater */
+		// read "from" align safe, by Freecom
 		charlen =
-		    codepage->uni2char(le16_to_cpu(from[i]), &to[outlen],
+		    codepage->uni2char(le16_to_cpu_align(from+i), &to[outlen],
 				       NLS_MAX_CHARSET_SIZE);
 		if (charlen > 0) {
 			outlen += charlen;
@@ -77,14 +79,14 @@
 			       ("cifs_strtoUCS: char2uni returned %d",
 				charlen));
 			/* A question mark */
-			to[i] = cpu_to_le16(0x003f);
+			le16_to_cpu_write_align(to+i, 0x003f);   // align safe, by Freecom
 			charlen = 1;
 		} else 
-			to[i] = cpu_to_le16(wchar_to[i]);
+			cpu_swap_align(to+i);   // align safe, by Freecom
 
 	}
 
-	to[i] = 0;
+	le16_to_cpu_write_align(to+i, 0);   // align safe, by Freecom
 	return i;
 }
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/cifs_unicode.h linux-ixp425/fs/cifs/cifs_unicode.h
--- linux-2.6.18/fs/cifs/cifs_unicode.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/cifs_unicode.h	2006-12-15 19:45:38.000000000 +1030
@@ -5,7 +5,7 @@
  *     Convert a unicode character to upper or lower case using
  *     compressed tables.
  *
- *   Copyright (c) International Business Machines  Corp., 2000,2005555555555555555555555555555555555555555555555555555555
+ *   Copyright (c) International Business Machines  Corp., 2000,2005
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -149,7 +149,9 @@
 {
 	int i = 0;
 
-	while (*ucs1++) {
+	// alignment safe, by Freecom Technologies GmbH, Berlin
+	while (*((char*)ucs1) && *((char*)ucs1 + 1)) {
+		ucs1++;
 		i++;
 		if (i >= maxlen)
 			break;
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/connect.c linux-ixp425/fs/cifs/connect.c
--- linux-2.6.18/fs/cifs/connect.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/connect.c	2006-12-15 18:43:28.000000000 +1030
@@ -304,9 +304,9 @@
 	memcpy(data_area_of_target,data_area_of_buf2,total_in_buf2);
 	total_in_buf += total_in_buf2;
 	pSMBt->t2_rsp.DataCount = cpu_to_le16(total_in_buf);
-	byte_count = le16_to_cpu(BCC_LE(pTargetSMB));
+	byte_count = BCC_READ_LE(pTargetSMB);
 	byte_count += total_in_buf2;
-	BCC_LE(pTargetSMB) = cpu_to_le16(byte_count);
+	BCC_WRITE_LE(pTargetSMB, byte_count);
 
 	byte_count = pTargetSMB->smb_buf_length;
 	byte_count += total_in_buf2;
@@ -2170,11 +2170,11 @@
 			if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 				if ((long) (bcc_ptr) % 2) {
 					remaining_words =
-					    (BCC(smb_buffer_response) - 1) /2;
+					    (BCC_READ(smb_buffer_response) - 1) /2;
 					bcc_ptr++;	/* Unicode strings must be word aligned */
 				} else {
 					remaining_words =
-						BCC(smb_buffer_response) / 2;
+						BCC_READ(smb_buffer_response) / 2;
 				}
 				len =
 				    UniStrnlen((wchar_t *) bcc_ptr,
@@ -2247,7 +2247,7 @@
 				len = strnlen(bcc_ptr, 1024);
 				if (((long) bcc_ptr + len) - (long)
 				    pByteArea(smb_buffer_response)
-					    <= BCC(smb_buffer_response)) {
+					    <= BCC_READ(smb_buffer_response)) {
 					kfree(ses->serverOS);
 					ses->serverOS = kzalloc(len + 1,GFP_KERNEL);
 					if(ses->serverOS == NULL)
@@ -2495,12 +2495,12 @@
 				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
-						    (BCC(smb_buffer_response)
+						    (BCC_READ(smb_buffer_response)
 						     - 1) / 2;
 						bcc_ptr++;	/* Unicode strings must be word aligned */
 					} else {
 						remaining_words =
-						    BCC
+						    BCC_READ
 						    (smb_buffer_response) / 2;
 					}
 					len =
@@ -2580,7 +2580,7 @@
 					len = strnlen(bcc_ptr, 1024);
 					if (((long) bcc_ptr + len) - (long)
 					    pByteArea(smb_buffer_response)
-					    <= BCC(smb_buffer_response)) {
+					    <= BCC_READ(smb_buffer_response)) {
 						if(ses->serverOS)
 							kfree(ses->serverOS);
 						ses->serverOS =
@@ -2898,11 +2898,11 @@
 				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
-						    (BCC(smb_buffer_response)
+						    (BCC_READ(smb_buffer_response)
 						     - 1) / 2;
 						bcc_ptr++;	/* Unicode strings must be word aligned */
 					} else {
-						remaining_words = BCC(smb_buffer_response) / 2;
+						remaining_words = BCC_READ(smb_buffer_response) / 2;
 					}
 					len =
 					    UniStrnlen((wchar_t *) bcc_ptr,remaining_words - 1);
@@ -2986,7 +2986,7 @@
 					len = strnlen(bcc_ptr, 1024);
 					if (((long) bcc_ptr + len) - 
                         (long) pByteArea(smb_buffer_response) 
-                            <= BCC(smb_buffer_response)) {
+                            <= BCC_READ(smb_buffer_response)) {
 						if(ses->serverOS)
 							kfree(ses->serverOS);
 						ses->serverOS = kzalloc(len + 1,GFP_KERNEL);
@@ -3139,7 +3139,7 @@
 		tcon->tidStatus = CifsGood;
 		tcon->tid = smb_buffer_response->Tid;
 		bcc_ptr = pByteArea(smb_buffer_response);
-		length = strnlen(bcc_ptr, BCC(smb_buffer_response) - 2);
+		length = strnlen(bcc_ptr, BCC_READ(smb_buffer_response) - 2);
         /* skip service field (NB: this field is always ASCII) */
 		bcc_ptr += length + 1;	
 		strncpy(tcon->treeName, tree, MAX_TREE_SIZE);
@@ -3147,7 +3147,7 @@
 			length = UniStrnlen((wchar_t *) bcc_ptr, 512);
 			if ((bcc_ptr + (2 * length)) -
 			     pByteArea(smb_buffer_response) <=
-			    BCC(smb_buffer_response)) {
+			    BCC_READ(smb_buffer_response)) {
 				kfree(tcon->nativeFileSystem);
 				tcon->nativeFileSystem =
 				    kzalloc(length + 2, GFP_KERNEL);
@@ -3164,7 +3164,7 @@
 			length = strnlen(bcc_ptr, 1024);
 			if ((bcc_ptr + length) -
 			    pByteArea(smb_buffer_response) <=
-			    BCC(smb_buffer_response)) {
+			    BCC_READ(smb_buffer_response)) {
 				kfree(tcon->nativeFileSystem);
 				tcon->nativeFileSystem =
 				    kzalloc(length + 1, GFP_KERNEL);
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/netmisc.c linux-ixp425/fs/cifs/netmisc.c
--- linux-2.6.18/fs/cifs/netmisc.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/netmisc.c	2006-12-15 18:43:40.000000000 +1030
@@ -869,14 +869,14 @@
 smbCalcSize(struct smb_hdr *ptr)
 {
 	return (sizeof (struct smb_hdr) + (2 * ptr->WordCount) +
-		2 /* size of the bcc field */ + BCC(ptr));
+		2 /* size of the bcc field */ + BCC_READ(ptr));
 }
 
 unsigned int
 smbCalcSize_LE(struct smb_hdr *ptr)
 {
 	return (sizeof (struct smb_hdr) + (2 * ptr->WordCount) +
-		2 /* size of the bcc field */ + le16_to_cpu(BCC_LE(ptr)));
+		2 /* size of the bcc field */ + BCC_READ_LE(ptr));
 }
 
 /* The following are taken from fs/ntfs/util.c */
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/sess.c linux-ixp425/fs/cifs/sess.c
--- linux-2.6.18/fs/cifs/sess.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/sess.c	2006-12-15 21:29:26.000000000 +1030
@@ -478,7 +478,7 @@
 	count = (long) bcc_ptr - (long) str_area;
 	smb_buf->smb_buf_length += count;
 
-	BCC_LE(smb_buf) = cpu_to_le16(count);
+	BCC_WRITE_LE(smb_buf, count);
 
 	iov[1].iov_base = str_area;
 	iov[1].iov_len = count; 
@@ -504,7 +504,7 @@
 	cFYI(1, ("UID = %d ", ses->Suid));
 	/* response can have either 3 or 4 word count - Samba sends 3 */
 	/* and lanman response is 3 */
-	bytes_remaining = BCC(smb_buf);
+	bytes_remaining = BCC_READ(smb_buf);
 	bcc_ptr = pByteArea(smb_buf);
 
 	if(smb_buf->WordCount == 4) {
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/cifs/transport.c linux-ixp425/fs/cifs/transport.c
--- linux-2.6.18/fs/cifs/transport.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/cifs/transport.c	2006-12-15 18:46:53.000000000 +1030
@@ -576,8 +576,7 @@
 			    sizeof (struct smb_hdr) -
 			    4 /* do not count RFC1001 header */  +
 			    (2 * midQ->resp_buf->WordCount) + 2 /* bcc */ )
-				BCC(midQ->resp_buf) = 
-					le16_to_cpu(BCC_LE(midQ->resp_buf));
+				BCC_WRITE(midQ->resp_buf, BCC_READ_LE(midQ->resp_buf));
 			midQ->resp_buf = NULL;  /* mark it so will not be freed
 						by DeleteMidQEntry */
 		} else {
@@ -757,7 +756,7 @@
 			    sizeof (struct smb_hdr) -
 			    4 /* do not count RFC1001 header */  +
 			    (2 * out_buf->WordCount) + 2 /* bcc */ )
-				BCC(out_buf) = le16_to_cpu(BCC_LE(out_buf));
+				BCC_WRITE(out_buf, BCC_READ_LE(out_buf));
 		} else {
 			rc = -EIO;
 			cERROR(1,("Bad MID state?"));
@@ -1002,7 +1001,7 @@
 			    sizeof (struct smb_hdr) -
 			    4 /* do not count RFC1001 header */  +
 			    (2 * out_buf->WordCount) + 2 /* bcc */ )
-				BCC(out_buf) = le16_to_cpu(BCC_LE(out_buf));
+				BCC_WRITE(out_buf, BCC_READ_LE(out_buf));
 		} else {
 			rc = -EIO;
 			cERROR(1,("Bad MID state?"));
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/jffs2/nodelist.h linux-ixp425/fs/jffs2/nodelist.h
--- linux-2.6.18/fs/jffs2/nodelist.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/jffs2/nodelist.h	2006-09-22 06:24:16.000000000 +0930
@@ -30,12 +30,10 @@
 #include "os-linux.h"
 #endif
 
-#define JFFS2_NATIVE_ENDIAN
-
 /* Note we handle mode bits conversion from JFFS2 (i.e. Linux) to/from
    whatever OS we're actually running on here too. */
 
-#if defined(JFFS2_NATIVE_ENDIAN)
+#if defined(CONFIG_JFFS2_NATIVE_ENDIAN)
 #define cpu_to_je16(x) ((jint16_t){x})
 #define cpu_to_je32(x) ((jint32_t){x})
 #define cpu_to_jemode(x) ((jmode_t){os_to_jffs2_mode(x)})
@@ -43,7 +41,7 @@
 #define je16_to_cpu(x) ((x).v16)
 #define je32_to_cpu(x) ((x).v32)
 #define jemode_to_cpu(x) (jffs2_to_os_mode((x).m))
-#elif defined(JFFS2_BIG_ENDIAN)
+#elif defined(CONFIG_JFFS2_BIG_ENDIAN)
 #define cpu_to_je16(x) ((jint16_t){cpu_to_be16(x)})
 #define cpu_to_je32(x) ((jint32_t){cpu_to_be32(x)})
 #define cpu_to_jemode(x) ((jmode_t){cpu_to_be32(os_to_jffs2_mode(x))})
@@ -51,7 +49,7 @@
 #define je16_to_cpu(x) (be16_to_cpu(x.v16))
 #define je32_to_cpu(x) (be32_to_cpu(x.v32))
 #define jemode_to_cpu(x) (be32_to_cpu(jffs2_to_os_mode((x).m)))
-#elif defined(JFFS2_LITTLE_ENDIAN)
+#elif defined(CONFIG_JFFS2_LITTLE_ENDIAN)
 #define cpu_to_je16(x) ((jint16_t){cpu_to_le16(x)})
 #define cpu_to_je32(x) ((jint32_t){cpu_to_le32(x)})
 #define cpu_to_jemode(x) ((jmode_t){cpu_to_le32(os_to_jffs2_mode(x))})
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/Kconfig linux-ixp425/fs/Kconfig
--- linux-2.6.18/fs/Kconfig	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/Kconfig	2006-09-22 06:24:16.000000000 +0930
@@ -1230,6 +1230,31 @@
 
 endchoice
 
+choice
+        prompt "JFFS2 endianness"
+        default JFFS2_NATIVE_ENDIAN
+        depends on JFFS2_FS
+        help
+          You can set here the default endianness of JFFS2 from
+          the available options. Don't touch if unsure.
+
+config JFFS2_NATIVE_ENDIAN
+        bool "native endian"
+        help
+          Uses a native endian bytestream.
+
+config JFFS2_BIG_ENDIAN
+        bool "big endian"
+        help
+          Uses a big endian bytestream.
+
+config JFFS2_LITTLE_ENDIAN
+        bool "little endian"
+        help
+          Uses a little endian bytestream.
+
+endchoice
+
 config CRAMFS
 	tristate "Compressed ROM file system support (cramfs)"
 	select ZLIB_INFLATE
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/nls/nls_base.c linux-ixp425/fs/nls/nls_base.c
--- linux-2.6.18/fs/nls/nls_base.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/nls/nls_base.c	2006-12-15 21:37:19.000000000 +1030
@@ -61,7 +61,7 @@
 			l &= t->lmask;
 			if (l < t->lval)
 				return -1;
-			*p = l;
+			WRITE_ALIGN(p, l);   // alignment safe, by Freecom
 			return nc;
 		}
 		if (n <= nc)
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/fs/nls/nls_utf8.c linux-ixp425/fs/nls/nls_utf8.c
--- linux-2.6.18/fs/nls/nls_utf8.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/fs/nls/nls_utf8.c	2006-12-15 21:37:08.000000000 +1030
@@ -27,7 +27,7 @@
 	int n;
 
 	if ( (n = utf8_mbtowc(uni, rawstring, boundlen)) == -1) {
-		*uni = 0x003f;	/* ? */
+		WRITE_ALIGN(uni, 0x003f);	/* ? */
 		n = -EINVAL;
 	}
 	return n;
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/asm-arm/arch-ixp4xx/fsg3.h linux-ixp425/include/asm-arm/arch-ixp4xx/fsg3.h
--- linux-2.6.18/include/asm-arm/arch-ixp4xx/fsg3.h	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/include/asm-arm/arch-ixp4xx/fsg3.h	2006-10-27 19:00:31.000000000 +0930
@@ -0,0 +1,51 @@
+/*
+ * include/asm-arm/arch-ixp4xx/fsg3.h
+ *
+ * FSG3 platform specific definitions
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define	FSG3_FLASH_BASE 	IXP4XX_EXP_BUS_BASE(0)
+#define	FSG3_FLASH_SIZE 	SZ_4M - 1
+
+
+#define FSG3_SYNC_KEY_PIN	4
+#define FSG3_RESET_KEY_PIN	9
+#define FSG3_UNPLUG_KEY_PIN	10
+#define	FSG3_SDA_PIN		12
+#define	FSG3_SCL_PIN		13
+
+
+/*
+ * FSG3 PCI IRQs
+ */
+#define FSG3_PCI_MAX_DEV	3
+#define FSG3_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define FSG3_PCI_INTA_PIN	6
+#define FSG3_PCI_INTB_PIN	7
+#define	FSG3_PCI_INTC_PIN	5
+
+#define FSG3_PCI_INTA_IRQ	IRQ_IXP4XX_GPIO6
+#define FSG3_PCI_INTB_IRQ	IRQ_IXP4XX_GPIO7
+#define FSG3_PCI_INTC_IRQ	IRQ_IXP4XX_GPIO5
+
+#define FSG3_LED_RING     0
+#define FSG3_LED_STARTUP  1
+#define FSG3_LED_USB      2
+#define FSG3_LED_SATA     3
+#define FSG3_LED_WAN      4
+#define FSG3_LED_WLAN     5
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/asm-arm/arch-ixp4xx/hardware.h linux-ixp425/include/asm-arm/arch-ixp4xx/hardware.h
--- linux-2.6.18/include/asm-arm/arch-ixp4xx/hardware.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/asm-arm/arch-ixp4xx/hardware.h	2006-09-22 06:30:55.000000000 +0930
@@ -41,6 +41,7 @@
 #include "platform.h"
 
 /* Platform specific details */
+#include "fsg3.h"
 #include "ixdp425.h"
 #include "coyote.h"
 #include "prpmc1100.h"
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h linux-ixp425/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h
--- linux-2.6.18/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h	2006-10-24 21:43:25.000000000 +0930
@@ -47,6 +47,7 @@
  * Queue Manager
  */
 #define IXP4XX_QMGR_BASE_PHYS		(0x60000000)
+#define IXP4XX_QMGR_BASE_VIRT           (0xFF00F000)
 #define IXP4XX_QMGR_REGION_SIZE		(0x00004000)
 
 /*
@@ -94,6 +95,43 @@
 #define IXP4XX_EXP_CFG3_OFFSET	0x2C
 
 /*
+ * Expansion BUS
+ *
+ * Expansion Bus 'lives' at either base1 or base 2 depending on the value of
+ * Exp Bus config registers:
+ *
+ * Setting bit 31 of IXP425_EXP_CFG0 puts SDRAM at zero,
+ * and The expansion bus to IXP425_EXP_BUS_BASE2
+ */
+#define IXP425_EXP_BUS_BASE1_PHYS	(0x00000000)
+#define IXP425_EXP_BUS_BASE2_PHYS	(0x50000000)
+#define IXP425_EXP_BUS_BASE2_VIRT	(0xF0000000)
+
+#define IXP425_EXP_BUS_BASE_PHYS	IXP425_EXP_BUS_BASE2_PHYS
+#define IXP425_EXP_BUS_BASE_VIRT	IXP425_EXP_BUS_BASE2_VIRT
+
+#define IXP425_EXP_BUS_REGION_SIZE	(0x08000000)
+#define IXP425_EXP_BUS_CSX_REGION_SIZE	(0x01000000)
+
+#define IXP425_EXP_BUS_CS0_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x00000000)
+#define IXP425_EXP_BUS_CS1_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x01000000)
+#define IXP425_EXP_BUS_CS2_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x02000000)
+#define IXP425_EXP_BUS_CS3_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x03000000)
+#define IXP425_EXP_BUS_CS4_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x04000000)
+#define IXP425_EXP_BUS_CS5_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x05000000)
+#define IXP425_EXP_BUS_CS6_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x06000000)
+#define IXP425_EXP_BUS_CS7_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x07000000)
+
+#define IXP425_EXP_BUS_CS0_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x00000000)
+#define IXP425_EXP_BUS_CS1_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x01000000)
+#define IXP425_EXP_BUS_CS2_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x02000000)
+#define IXP425_EXP_BUS_CS3_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x03000000)
+#define IXP425_EXP_BUS_CS4_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x04000000)
+#define IXP425_EXP_BUS_CS5_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x05000000)
+#define IXP425_EXP_BUS_CS6_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x06000000)
+#define IXP425_EXP_BUS_CS7_BASE_VIRT	(IXP425_EXP_BUS_BASE2_VIRT + 0x07000000)
+
+/*
  * Expansion Bus Controller registers.
  */
 #define IXP4XX_EXP_REG(x) ((volatile u32 *)(IXP4XX_EXP_CFG_BASE_VIRT+(x)))
@@ -415,6 +453,8 @@
  * IXP4XX_ naming convetions.
  *
  */
+#ifndef NO_LINUX_IXP4XX_USB
+
 # define IXP4XX_USB_REG(x)       (*((volatile u32 *)(x)))
 
 /* UDC Undocumented - Reserved1 */
@@ -424,7 +464,7 @@
 /* UDC Undocumented - Reserved3 */
 #define UDC_RES3	IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x000C)  
 /* UDC Control Register */
-#define UDCCR		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0000)  
+#define UDCCR		(IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0000));
 /* UDC Endpoint 0 Control/Status Register */
 #define UDCCS0		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0010)  
 /* UDC Endpoint 1 (IN) Control/Status Register */
@@ -607,6 +647,8 @@
 
 #define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
 
+#endif  /* NO_LINUX_IXP4XX_USB */
+
 #ifndef __ASSEMBLY__
 static inline int cpu_is_ixp46x(void)
 {
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/asm-arm/unistd.h linux-ixp425/include/asm-arm/unistd.h
--- linux-2.6.18/include/asm-arm/unistd.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/asm-arm/unistd.h	2006-09-25 20:50:14.000000000 +0930
@@ -376,7 +376,8 @@
 #undef __NR_ipc
 #endif
 
-#ifdef __KERNEL__
+// commented out by Freecom Technologies GmbH, Berlin
+//#ifdef __KERNEL__
 #include <linux/linkage.h>
 
 #define __sys2(x) #x
@@ -580,5 +581,6 @@
  */
 #define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
 
-#endif /* __KERNEL__ */
+// commented out by Freecom Technologies GmbH, Berlin
+//#endif /* __KERNEL__ */
 #endif /* __ASM_ARM_UNISTD_H */
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/input.h linux-ixp425/include/linux/input.h
--- linux-2.6.18/include/linux/input.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/input.h	2006-09-22 06:30:55.000000000 +0930
@@ -17,6 +17,10 @@
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <asm/types.h>
+#ifdef _LIBC_REENTRANT
+typedef unsigned long kernel_ulong_t;
+#define BITS_PER_LONG 32
+#endif
 #endif
 
 /*
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/nls.h linux-ixp425/include/linux/nls.h
--- linux-2.6.18/include/linux/nls.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/nls.h	2006-12-15 21:37:29.000000000 +1030
@@ -6,6 +6,11 @@
 /* unicode character */
 typedef __u16 wchar_t;
 
+// alignment safe, by Freecom Technologies GmbH, Berlin
+#define WRITE_ALIGN(wordptr, value)  \
+  { *((char *)(wordptr) + 1) = (char)(value); \
+    *((char *)(wordptr)) = (char)((value) >> 8); }
+
 struct nls_table {
 	char *charset;
 	char *alias;
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/pci_ids.h linux-ixp425/include/linux/pci_ids.h
--- linux-2.6.18/include/linux/pci_ids.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/pci_ids.h	2006-09-22 06:30:55.000000000 +0930
@@ -1313,6 +1313,7 @@
 #define PCI_DEVICE_ID_VIA_8378_0	0x3205
 #define PCI_DEVICE_ID_VIA_8783_0	0x3208
 #define PCI_DEVICE_ID_VIA_8237		0x3227
+#define PCI_DEVICE_ID_VIA_6421		0x3249
 #define PCI_DEVICE_ID_VIA_8251		0x3287
 #define PCI_DEVICE_ID_VIA_8237A		0x3337
 #define PCI_DEVICE_ID_VIA_8231		0x8231
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/ppp-comp.h linux-ixp425/include/linux/ppp-comp.h
--- linux-2.6.18/include/linux/ppp-comp.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/ppp-comp.h	2006-11-21 21:40:02.000000000 +1030
@@ -199,6 +199,121 @@
 #define CI_MPPE                18      /* config option for MPPE */
 #define CILEN_MPPE              6      /* length of config option */
 
+
+#define MPPE_PAD		4	/* MPPE growth per frame */
+#define MPPE_MAX_KEY_LEN	16	/* largest key length (128-bit) */
+
+/* option bits for ccp_options.mppe */
+#define MPPE_OPT_40		0x01	/* 40 bit */
+#define MPPE_OPT_128		0x02	/* 128 bit */
+#define MPPE_OPT_STATEFUL	0x04	/* stateful mode */
+/* unsupported opts */
+#define MPPE_OPT_56		0x08	/* 56 bit */
+#define MPPE_OPT_MPPC		0x10	/* MPPC compression */
+#define MPPE_OPT_D		0x20	/* Unknown */
+#define MPPE_OPT_UNSUPPORTED (MPPE_OPT_56|MPPE_OPT_MPPC|MPPE_OPT_D)
+#define MPPE_OPT_UNKNOWN	0x40	/* Bits !defined in RFC 3078 were set */
+
+/*
+ * This is not nice ... the alternative is a bitfield struct though.
+ * And unfortunately, we cannot share the same bits for the option
+ * names above since C and H are the same bit.  We could do a u_int32
+ * but then we have to do a htonl() all the time and/or we still need
+ * to know which octet is which.
+ */
+#define MPPE_C_BIT		0x01	/* MPPC */
+#define MPPE_D_BIT		0x10	/* Obsolete, usage unknown */
+#define MPPE_L_BIT		0x20	/* 40-bit */
+#define MPPE_S_BIT		0x40	/* 128-bit */
+#define MPPE_M_BIT		0x80	/* 56-bit, not supported */
+#define MPPE_H_BIT		0x01	/* Stateless (in a different byte) */
+
+/* Does not include H bit; used for least significant octet only. */
+#define MPPE_ALL_BITS (MPPE_D_BIT|MPPE_L_BIT|MPPE_S_BIT|MPPE_M_BIT|MPPE_H_BIT)
+
+/* Build a CI from mppe opts (see RFC 3078) */
+#define MPPE_OPTS_TO_CI(opts, ci)		\
+    do {					\
+	u_char *ptr = ci; /* u_char[4] */	\
+						\
+	/* H bit */				\
+	if (opts & MPPE_OPT_STATEFUL)		\
+	    *ptr++ = 0x0;			\
+	else					\
+	    *ptr++ = MPPE_H_BIT;		\
+	*ptr++ = 0;				\
+	*ptr++ = 0;				\
+						\
+	/* S,L bits */				\
+	*ptr = 0;				\
+	if (opts & MPPE_OPT_128)		\
+	    *ptr |= MPPE_S_BIT;			\
+	if (opts & MPPE_OPT_40)			\
+	    *ptr |= MPPE_L_BIT;			\
+	/* M,D,C bits not supported */		\
+    } while (/* CONSTCOND */ 0)
+
+/* The reverse of the above */
+#define MPPE_CI_TO_OPTS(ci, opts)		\
+    do {					\
+	u_char *ptr = ci; /* u_char[4] */	\
+						\
+	opts = 0;				\
+						\
+	/* H bit */				\
+	if (!(ptr[0] & MPPE_H_BIT))		\
+	    opts |= MPPE_OPT_STATEFUL;		\
+						\
+	/* S,L bits */				\
+	if (ptr[3] & MPPE_S_BIT)		\
+	    opts |= MPPE_OPT_128;		\
+	if (ptr[3] & MPPE_L_BIT)		\
+	    opts |= MPPE_OPT_40;		\
+						\
+	/* M,D,C bits */			\
+	if (ptr[3] & MPPE_M_BIT)		\
+	    opts |= MPPE_OPT_56;		\
+	if (ptr[3] & MPPE_D_BIT)		\
+	    opts |= MPPE_OPT_D;			\
+	if (ptr[3] & MPPE_C_BIT)		\
+	    opts |= MPPE_OPT_MPPC;		\
+						\
+	/* Other bits */			\
+	if (ptr[0] & ~MPPE_H_BIT)		\
+	    opts |= MPPE_OPT_UNKNOWN;		\
+	if (ptr[1] || ptr[2])			\
+	    opts |= MPPE_OPT_UNKNOWN;		\
+	if (ptr[3] & ~MPPE_ALL_BITS)		\
+	    opts |= MPPE_OPT_UNKNOWN;		\
+    } while (/* CONSTCOND */ 0)
+
+/* MPPE/MPPC definitions by J.D.*/
+#define MPPE_STATELESS          MPPE_H_BIT	/* configuration bit H */
+#define MPPE_40BIT              MPPE_L_BIT	/* configuration bit L */
+#define MPPE_56BIT              MPPE_M_BIT	/* configuration bit M */
+#define MPPE_128BIT             MPPE_S_BIT	/* configuration bit S */
+#define MPPE_MPPC               MPPE_C_BIT	/* configuration bit C */
+
+/*
+ * Definitions for Stac LZS.
+*/
+
+#define CI_LZS			17	/* config option for Stac LZS */
+#define CILEN_LZS		5	/* length of config option */
+
+#define LZS_OVHD		4	/* max. LZS overhead */
+#define LZS_HIST_LEN		2048	/* LZS history size */
+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
+
+#define LZS_MODE_NONE		0
+#define LZS_MODE_LCB		1
+#define LZS_MODE_CRC		2
+#define LZS_MODE_SEQ		3
+#define LZS_MODE_EXT		4
+
+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
+
 /*
  * Definitions for other, as yet unsupported, compression methods.
  */
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/ppp_defs.h linux-ixp425/include/linux/ppp_defs.h
--- linux-2.6.18/include/linux/ppp_defs.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/ppp_defs.h	2006-11-22 18:45:11.000000000 +1030
@@ -83,11 +83,13 @@
 #define PPP_CCPFRAG	0x80fb	/* CCP at link level (below MP bundle) */
 #define PPP_CCP		0x80fd	/* Compression Control Protocol */
 #define PPP_MPLSCP	0x80fd	/* MPLS Control Protocol */
+#define PPP_ECP		0x8053	/* Encryption Control Protocol */
 #define PPP_LCP		0xc021	/* Link Control Protocol */
 #define PPP_PAP		0xc023	/* Password Authentication Protocol */
 #define PPP_LQR		0xc025	/* Link Quality Report protocol */
 #define PPP_CHAP	0xc223	/* Cryptographic Handshake Auth. Protocol */
 #define PPP_CBCP	0xc029	/* Callback Control Protocol */
+#define PPP_EAP		0xc227	/* Extensible Authentication Protocol */
 
 /*
  * Values for FCS calculations.
@@ -99,6 +101,8 @@
 #ifdef __KERNEL__
 #include <linux/crc-ccitt.h>
 #define PPP_FCS(fcs, c) crc_ccitt_byte(fcs, c)
+#else
+#define PPP_FCS(fcs, c)	(((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])
 #endif
 
 /*
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/linux/reiserfs_fs.h linux-ixp425/include/linux/reiserfs_fs.h
--- linux-2.6.18/include/linux/reiserfs_fs.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/linux/reiserfs_fs.h	2006-11-13 19:16:39.000000000 +1030
@@ -969,6 +969,9 @@
 #   define ADDR_UNALIGNED_BITS  (3)
 #endif
 
+// avoid alignment exceptions, by Freecom Technologies GmbH, Berlin
+#define ADDR_UNALIGNED_BITS  (2)
+
 /* These are only used to manipulate deh_state.
  * Because of this, we'll use the ext2_ bit routines,
  * since they are little endian */
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/net/maclist.h linux-ixp425/include/net/maclist.h
--- linux-2.6.18/include/net/maclist.h	1970-01-01 09:30:00.000000000 +0930
+++ linux-ixp425/include/net/maclist.h	2006-09-22 06:30:55.000000000 +0930
@@ -0,0 +1,49 @@
+#ifndef _MACLIST_H
+#define _MACLIST_H 1
+/*
+ * Interfaces to the MAC repository
+ *
+ * Copyright (C) 2005 John Bowler
+ * Author: John Bowler <jbowler@acm.org>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Add a single entry, returns 0 on success else an error
+ * code.  Allocates memory, claims and releases a write
+ * lock.
+ */
+extern int maclist_add(const u8 id_to_add[6]);
+
+/*
+ * Return the current entry count, claims and releases a
+ * read lock.
+ */
+extern int maclist_count(void);
+
+/*
+ * Return the ID from the given entry.  Always succeeds.
+ * Claims and releases a write lock.
+ *
+ * If any entry has not been allocated for this key one
+ * is allocated.  If there are no remaining unallocated
+ * entries a new one is created.
+ *
+ * If the value of the key is less than maclist_count()
+ * the entry indexed by the key (i.e. for key 'n' the
+ * n'th entry starting at 0) will be returned if available.
+ * Otherwise the entry to be returned will be unpredictable
+ * but consistent for a given value of maclist_count().
+ */
+extern void maclist_read(u8 (*buffer_for_id)[6],
+		u32 key_of_entry_to_return);
+
+/*
+ * See the implementation in drivers/net/maclist.c for
+ * more information.
+ */
+#endif /*_MACLIST_H*/
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/include/scsi/scsi_host.h linux-ixp425/include/scsi/scsi_host.h
--- linux-2.6.18/include/scsi/scsi_host.h	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/include/scsi/scsi_host.h	2006-11-28 01:03:15.000000000 +1030
@@ -596,7 +596,9 @@
 	 * alignment to a long boundary.
 	 */
 	unsigned long hostdata[0]  /* Used for storage of host specific stuff */
-		__attribute__ ((aligned (sizeof(unsigned long))));
+		__attribute__ ((aligned (8)));
+	// avoid 64bit alignment trap, by Freecom Technologies GmbH, Berlin
+//		__attribute__ ((aligned (sizeof(unsigned long))));
 };
 
 #define		class_to_shost(d)	\
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/kernel/sys.c linux-ixp425/kernel/sys.c
--- linux-2.6.18/kernel/sys.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/kernel/sys.c	2006-10-25 18:35:34.000000000 +0930
@@ -680,6 +680,7 @@
  */
 asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user * arg)
 {
+	volatile int holdkey;  // Freecom
 	char buffer[256];
 
 	/* We only trust the superuser with rebooting the system. */
@@ -717,7 +718,16 @@
 	case LINUX_REBOOT_CMD_HALT:
 		kernel_halt();
 		unlock_kernel();
-		do_exit(0);
+
+		// make a restart instead, by Freecom Technologies GmbH, Berlin
+//		do_exit(0);
+
+		// wait until key pressed -> restart
+		do { gpio_line_get(FSG3_SYNC_KEY_PIN, &holdkey); } while (!holdkey);
+		while (holdkey)  gpio_line_get(FSG3_SYNC_KEY_PIN, &holdkey);
+
+		printk("Restarting system.\n");
+		machine_restart(NULL);
 		break;
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
Binary files linux-2.6.18/linux and linux-ixp425/linux differ
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/net/ipv4/ip_input.c linux-ixp425/net/ipv4/ip_input.c
--- linux-2.6.18/net/ipv4/ip_input.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/net/ipv4/ip_input.c	2007-05-07 16:32:37.000000000 +0930
@@ -272,6 +272,10 @@
 			return 0;
 	}
 
+	// speed up for locals, by Freecom
+	if(strcmp(skb->dev->name, "eth0") == 0)
+		return ip_local_deliver_finish(skb);
+
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb->dev, NULL,
 		       ip_local_deliver_finish);
 }
@@ -373,6 +377,7 @@
 int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct iphdr *iph;
+	struct in_device *in_dev;
 	u32 len;
 
 	/* When the interface is in promisc. mode, drop all the crap
@@ -431,6 +436,14 @@
 	/* Remove any debris in the socket control block */
 	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
+	// speed up for locals, by Freecom
+	if(strcmp(dev->name, "eth0") == 0) {
+		in_dev = in_dev_get(dev);
+		if(in_dev) if(in_dev->ifa_list)
+			if(skb->nh.iph->daddr == in_dev->ifa_list->ifa_address)
+				return ip_rcv_finish(skb);
+	}
+
 	return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL,
 		       ip_rcv_finish);
 
diff -BurN -X linux-2.6.18/Documentation/dontdiff linux-2.6.18/net/ipv4/ip_output.c linux-ixp425/net/ipv4/ip_output.c
--- linux-2.6.18/net/ipv4/ip_output.c	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/net/ipv4/ip_output.c	2007-05-07 16:31:40.000000000 +0930
@@ -153,6 +153,10 @@
 
 	skb->priority = sk->sk_priority;
 
+	// speed up for locals, by Freecom
+	if(strcmp(rt->u.dst.dev->name, "eth0") == 0)
+		return dst_output(skb);
+
 	/* Send it out. */
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
 		       dst_output);
@@ -283,6 +287,11 @@
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
 
+	// speed up for locals, by Freecom
+	if(skb->input_dev == 0)
+		if(strcmp(dev->name, "eth0") == 0)
+			return ip_finish_output(skb);
+
 	return NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, NULL, dev,
 		            ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
@@ -367,6 +376,10 @@
 
 	skb->priority = sk->sk_priority;
 
+	// speed up for locals, by Freecom
+	if(strcmp(rt->u.dst.dev->name, "eth0") == 0)
+		return dst_output(skb);
+
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
 		       dst_output);
 
@@ -1263,9 +1276,13 @@
 	skb->priority = sk->sk_priority;
 	skb->dst = dst_clone(&rt->u.dst);
 
-	/* Netfilter gets whole the not fragmented skb. */
-	err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, 
-		      skb->dst->dev, dst_output);
+	// speed up for locals, by Freecom
+	if(strcmp(skb->dst->dev->name, "eth0") == 0)
+		err = dst_output(skb);
+	else
+		/* Netfilter gets whole the not fragmented skb. */
+		err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, 
+			      skb->dst->dev, dst_output);
 	if (err) {
 		if (err > 0)
 			err = inet->recverr ? net_xmit_errno(err) : 0;
--- linux-2.6.18/arch/arm/tools/mach-types	2006-09-20 13:12:06.000000000 +0930
+++ linux-ixp425/arch/arm/tools/mach-types	2006-09-22 06:30:53.000000000 +0930
@@ -16,6 +16,7 @@
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
+freecom_fsg3		ARCH_FSG3		FREECOM_FSG3		1091
 ebsa110			ARCH_EBSA110		EBSA110			0
 riscpc			ARCH_RPC		RISCPC			1
 nexuspci		ARCH_NEXUSPCI		NEXUSPCI		3
